{"version":3,"file":"game.a59c560d88c38692f86b.bundle.js","mappings":";;;;;;;;;;;;;;AAAA,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,yBAAyB;;;;;;;;;;;;;;;ACA/D,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,eAAe;;;;;;;;;;;;;;;ACArD,iEAAe,qBAAuB,8BAA8B;;;;;;;;;;;;;;;ACApE,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,4BAA4B;;;;;;;;;;;;;;;ACAlE,iEAAe,qBAAuB,iCAAiC;;;;;;;;;;;;;;;ACAvE,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,0BAA0B;;;;;;;;;;;;;;;ACAhE,iEAAe,qBAAuB,wBAAwB;;;;;;;;;;;;;;;ACA9D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,8BAA8B;;;;;;;;;;;;;;;ACApE,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,yBAAyB;;;;;;;;;;;;;;;ACA/D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,yBAAyB;;;;;;;;;;;;;;;ACA/D,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,gBAAgB;;;;;;;;;;;;;;;ACAtD,iEAAe,qBAAuB,iBAAiB;;;;;;;;;;;;;;;ACAvD,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,4BAA4B;;;;;;;;;;;;;;;ACAlE,iEAAe,qBAAuB,iCAAiC;;;;;;;;;;;;;;;ACAvE,iEAAe,qBAAuB,wBAAwB;;;;;;;;;;;;;;;ACA9D,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,wBAAwB;;;;;;;;;;;;;;;ACA9D,iEAAe,qBAAuB,6BAA6B;;;;;;;;;;;;;;;ACAnE,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,4BAA4B;;;;;;;;;;;;;;;ACAlE,iEAAe,qBAAuB,4BAA4B;;;;;;;;;;;;;;;ACAlE,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;ACA3D;;;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3Be;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCqF;AAC3B;AAC1B;AACc;AACD;AACqB;AAClB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA,uBAAuB,CAAC;AACxB;AACA;AACA;AACA,yCAAyC,iEAAY;AACrD;AACA,gCAAgC,0DAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA,0BAA0B,+CAAU;AACpC;AACA,qCAAqC,CAAC;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,4DAAS;AACrC;AACA;AACA,8CAA8C,qCAAqC,iBAAiB,MAAM;AAC1G;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,QAAQ,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA,wBAAwB,CAAC;AACzB;AACA;AACA,yBAAyB,CAAC;AAC1B;AACA,YAAY,CAAC;AACb,YAAY,CAAC;AACb,UAAU;AACV,YAAY,CAAC;AACb,wBAAwB,CAAC,cAAc,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS,IAAI,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAgB;AACnC,mBAAmB,6DAAgB;AACnC;AACA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB,wCAAwC,sCAAsC;AAC9E,kDAAkD,SAAS,IAAI,KAAK;AACpE,uCAAuC,KAAK;AAC5C;AACA;AACA,QAAQ,CAAC;AACT;AACA,YAAY,mDAAS;AACrB,YAAY,mDAAS;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC,oCAAoC,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iBAAiB,gDAAO;AACxB,gBAAgB,mDAAS;AACzB;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,oBAAoB,IAAI,WAAW;AAClG;AACA;AACA;AACA;AACA,oBAAoB,gDAAO;AAC3B;AACA,4CAA4C,qDAAE,cAAc,OAAO,GAAG,OAAO,IAAI;AACjF,oBAAoB,mDAAS,WAAW,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAE,kBAAkB;AACjD,+BAA+B,qDAAE,oBAAoB;AACrD,0BAA0B,qDAAE,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,mDAAS;AACjB,0BAA0B,mDAAS;AACnC;AACA,gBAAgB,mDAAS;AACzB,cAAc;AACd,gBAAgB,mDAAS;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL,WAAW,gDAAO;AAClB;AACA;AACA,YAAY,CAAC,+BAA+B,gDAAO;AACnD;AACA,4BAA4B,mDAAS;AACrC;AACA,uBAAuB,mDAAS;AAChC;AACA,YAAY,mDAAS;AACrB;AACA;AACA,UAAU;AACV;AACA,YAAY,CAAC;AACb;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA,IAAI,oEAA2B;AAC/B;AACA,2BAA2B,0DAAK;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA,QAAQ,8CAAM;AACd,QAAQ,8CAAM;AACd,QAAQ,8CAAM;AACd;AACA,QAAQ,CAAC;AACT,MAAM;AACN,QAAQ,8CAAM,cAAc,8CAAM;AAClC,yBAAyB,8CAAM;AAC/B;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL,QAAQ,CAAC;AACT;AACA,KAAK;AACL,IAAI,CAAC;AACL,QAAQ,CAAC;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,CAAC;AAC3E;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP,0BAA0B,CAAC;AAC3B,IAAI,CAAC;AACL;AACA;AACO;AACP,YAAY,CAAC,uBAAuB,CAAC;AACrC;AACA;AACO;AACP,sBAAsB,CAAC;AACvB;AACA;AACA;AACA,wCAAwC,GAAG;AAC3C;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,KAAK;AACL;AACA;AACA,iEAAe,gDAAO,YAAY;;;;;;;;;;;;;;;;;;;AC3fF;AAKf;AAC6C;AACjB;;AAE9B;AACf;AACA;AACA;;AAEA,qBAAqB,8CAAS;AAC9B,sBAAsB,8CAAS;;AAE/B;AACA,iDAAiD,8CAAS;;AAE1D;;AAEA,gDAAgD,8CAAS,EAAE,8CAAS;AACpE;;AAEA;;AAEA;AACA;AACA,qCAAqC,gDAAO,CAAC,iEAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0DAAK;AACpB;AACA,yCAAyC;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,mDAAmD,8CAAS;;AAE5D;AACA,kDAAkD,8CAAS,EAAE,8CAAS;AACtE;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,yCAAI;AACpB,mBAAmB,0DAAK;AACxB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;AACA,2BAA2B,+CAAU;AACrC;AACA;;AAEA;AACA,iCAAiC,8CAAS;AAC1C;;AAEA;AACA,0BAA0B,8CAAS;;AAEnC;;AAEA;AACA;;AAEA;AACA,0BAA0B,8CAAS;AACnC;;AAEA;AACA;;AAEA;AACA,0BAA0B,8CAAS;AACnC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3HgC;AACJ;AAKV;AAGU;AAC8B;AACjB;AACW;AACJ;AAChD;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ,gDAAO;AACf;AACA;AACA,YAAY,gDAAO;AACnB,SAAS;AACT;AACA,QAAQ,gDAAO;AACf;AACA;AACA,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAK;AAC3C;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAc;AAC/B;AACA;AACA,6CAA6C,GAAG,GAAG,GAAG;AACtD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAQ;AACrC;AACA;AACA;AACA,2BAA2B,sDAAU,kBAAkB,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,2CAA2C,GAAG,GAAG,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sDAAU,uBAAuB,6CAAQ,CAAC,KAAK,EAAE,KAAK,EAAE;AAC3F;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wCAAwC,EAAE,GAAG,EAAE;AAC/C;AACA;AACA;AACA,uCAAuC,6CAAQ,CAAC,GAAG,EAAE,GAAG,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAAQ,CAAC,GAAG,EAAE,GAAG,EAAE;AACjE;AACA;AACA,2CAA2C,EAAE,GAAG,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA,4BAA4B;AAC5B,gBAAgB,6DAAoB;AACpC;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAQ;AACvB;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA,iDAAiD,+CAAU;AAC3D;AACA;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC,wBAAwB,gDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAS;AAC5C,iCAAiC,8CAAS;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1UkC;AACW;AAC7C;AACe,yBAAyB,+CAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,CAAC;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,CAAC,YAAY,qDAAC,OAAO;AAClD;AACA;AACA;AACA;AACA,iCAAiC,CAAC,YAAY,qDAAC,WAAW;AAC1D;AACA;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA,2BAA2B,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,CAAC,YAAY,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7He;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpD2D;AAC7B;AACmB;AACjB;AACA;AACkB;AAI5B;AACY;AACE;AACN;AAC4B;AAC1D;AACA,iBAAiB,2EAA8B;AAC/C;AACA;AACe;AACf;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA,2CAA2C,gDAAO,CAAC,iEAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAM;AAC7B;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,+CAAU,CAAC,+CAAM;AAC3C;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAgB;AAC5C;AACA;AACA;AACA;AACA,mBAAmB,+CAAM,KAAK,gDAAO,kCAAkC,+CAAM;AAC7E,mBAAmB,+CAAM,KAAK,gDAAO,mCAAmC,+CAAM;AAC9E;AACA,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAS;AACrC,4BAA4B,8CAAS;AACrC;AACA;AACA,iBAAiB,gDAAO;AACxB,gBAAgB,gDAAO;AACvB;AACA;AACA,yDAAyD,GAAG,GAAG,GAAG;AAClE;AACA;AACA,yDAAyD,GAAG,GAAG,GAAG;AAClE;AACA;AACA;AACA,wBAAwB,8DAAoB;AAC5C;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,sEAAsE,8CAAS,EAAE,8CAAS;AAC1F;AACA;AACA;AACA;AACA,4FAA4F,8CAAS,EAAE,8CAAS;AAChH;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4FAA4F,8CAAS,EAAE,8CAAS;AAChH;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnOkC;AACX;AACvB;AAIoB;AAKH;AACc;AACL;AACA;AACe;AACA;AACO;AACH;AACG;AAChD;AACe,qBAAqB,+CAAY;AAChD;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,KAAK,KAAK,GAAG,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C,4BAA4B,6CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC,YAAY,gDAAO;AACnB;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,6CAA6C,gDAAO;AACpD;AACA;AACA;AACA,oBAAoB,gDAAO;AAC3B;AACA,kBAAkB;AAClB,iCAAiC,gDAAO,iBAAiB,6CAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA,oBAAoB,gDAAO,YAAY,gDAAO;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA,6BAA6B,+CAAM;AACnC,4BAA4B,sDAAY;AACxC;AACA;AACA;AACA,8BAA8B,sDAAC;AAC/B,sBAAsB;AACtB,8BAA8B,sDAAC;AAC/B;AACA,oBAAoB,MAAM,YAAY,sDAAC;AACvC;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B,gBAAgB,6CAAI;AACpB;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB,oCAAoC,8DAAgB;AACpD,kCAAkC,0CAAK;AACvC;AACA,kCAAkC,CAAC;AACnC,8CAA8C,YAAY,kBAAkB;AAC5E;AACA,iCAAiC,QAAQ;AACzC,wDAAwD;AACxD;AACA;AACA;AACA,oBAAoB,CAAC;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB,gBAAgB,sDAAY;AAC5B;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA,kCAAkC,mDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA,8BAA8B,4CAAO;AACrC;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,6BAA6B,gDAAO;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA,iDAAiD,8CAAO;AACxD;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAM;AACzB,YAAY,qDAAY,CAAC,+CAAM;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B,2CAA2C;AAC3C,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5ZA;AACA;AACA;AACkD;AACX;AACK;AAC5C;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAQ,CAAC,GAAG,OAAO,GAAG,OAAO;AAC1D,YAAY,0DAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,mDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAY,SAAS,iDAAS,EAAE,iDAAS;AACxD;AACA;AACA;AACA;AACA,6BAA6B,gDAAQ,CAAC,GAAG,OAAO,GAAG,OAAO;AAC1D,YAAY,0DAAqB;AACjC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAY;AACnD;AACA;AACA,8BAA8B,mDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;ACnHiC;AACE;AACnC;AACe,mBAAmB,+CAAY;AAC9C,6DAA6D,4CAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfkC;AACF;AACJ;AACE;AACA;AAGD;AAKP;AAC8B;AAC9B;AAC6B;AACnD;AACyC;AACzC;AACA,eAAe,gDAAQ;AACvB;AACA;AACA,uBAAuB,sEAAkB;AACzC;AACA,iBAAiB,+CAAM,eAAe,+CAAM;AAC5C;AACA;AACA;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA,2BAA2B,+CAAM,GAAG,IAAI,+CAAM,GAAG;AACjD;AACA,QAAQ,+CAAM,gBAAgB,+CAAM;AACpC,QAAQ,gDAAO;AACf;AACA;AACA,iBAAiB,2EAA8B;AAC/C;AACe,0BAA0B,+CAAY;AACrD;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAAE;AACV;AACA;AACA;AACA;AACA,gDAAgD,2CAAE;AAClD;AACA;AACA;AACA,oBAAoB,CAAC,UAAU,KAAK;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,oBAAoB,+CAAM;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM;AACtB,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,gDAAO;AAC1B;AACA,0BAA0B,8DAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAO;AAC1B;AACA,+BAA+B,8DAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sDAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAM;AACtC,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM,eAAe,+CAAM,eAAe,+CAAM;AAChE;AACA;AACA,oBAAoB,+CAAM,gBAAgB,+CAAM,KAAK,+CAAM,gBAAgB,+CAAM;AACjF,oBAAoB,gDAAO;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAK;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAK;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChXA;AACA;AACA;AAC4B;AACW;AACM;AAC7C;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB,oBAAoB,6CAAM;AAC1B,iBAAiB;AACjB,aAAa;AACb;AACA,YAAY,CAAC;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,6CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB,kCAAkC,YAAY,kBAAkB;AAChE,qBAAqB,SAAS;AAC9B,+DAA+D,IAAI,qDAAC,OAAO;AAC3E,8DAA8D,IAAI,qDAAC,WAAW;AAC9E;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA,SAAS;AACT;AACA,QAAQ,CAAC;AACT;AACA,SAAS;AACT,QAAQ,CAAC;AACT;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtR6B;AACJ;AAC0B;AACnD;AAC4B;AACY;AACZ;AACA;AACH;AACI;AACC;AAC9B;AAC6B;AAC7B;AACmC;AACL;AACL;AACG;AACA;AACC;AACF;AACC;AACG;AACH;AACM;AACA;AACT;AACzB;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;AC5BgB;AAId;AACiB;AACyB;;AAE3D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,iEAAY;AAC5B,gBAAgB,iEAAY;;AAE5B,mBAAmB,iEAAY;;AAE/B,mBAAmB,+CAAU;AAC7B,mBAAmB,gDAAW;AAC9B,kBAAkB,+CAAU;AAC5B,kBAAkB,gDAAW;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,QAAQ,gDAAO;AACf;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;;AAEf,QAAQ,gDAAO;AACf,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL,mBAAmB,+CAAY;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,0DAAK;AAC3B,sBAAsB,0DAAK;AAC3B,sBAAsB,0DAAK;;AAE3B,kBAAkB,cAAc;AAChC,CAAC;;AAED,iEAAgB,sBAAsB;;;;;;;;;;;;;;;;;AC7GtC;AACA;AACO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;AC3EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA,gBAAgB,CAAC;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACvEgC;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,gDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,MAAM;AACN;AACA;AACO;AACP,IAAI,gDAAO;AACX;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;AC9G6B;AACqB;AACnB;AACyB;AACzD;AACA;AACA,uBAAuB,uDAAoD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAM;AAC7C;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV,IAAI,+CAAM,QAAQ,+CAAM;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAU;AACnC,yBAAyB,gDAAW;AACpC;AACA,oBAAoB,yCAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,2BAA2B,sEAAkB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,qCAAqC,EAAE,+CAAM;AACzD,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD,sBAAsB,+CAAM,IAAI,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/GO;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CwD;AACA;AACxB;AACF;AACgG;AAChE;AACQ;AACnB;AAC4C;;AAExF;AACP,IAAI,qDAAU;AACd,IAAI,uDAAY;AAChB,IAAI,qDAAW;AACf,IAAI,+CAAQ;AACZ,IAAI,qEAAmB;AACvB;;AAEO;AACP,IAAI,iEAAsB;;AAE1B,IAAI,gEAAqB;;AAEzB,IAAI,kEAAuB;AAC3B;AACA,IAAI,kEAAqB;AACzB,IAAI,0DAAc;AAClB,IAAI,2DAAoB;AACxB,IAAI,wDAAc;AAClB,IAAI,+CAAM;AACV,IAAI,2DAAe;AACnB,IAAI,0DAAgB;AACpB,IAAI,4DAAe;AACnB,IAAI,6DAAmB;AACvB,IAAI,gEAAgB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,CAAC;AACT,sBAAsB,CAAC;AACvB;AACA;AACA;AACA,cAAc;AACd;AACA,+BAA+B,CAAC;AAChC;AACA,SAAS;AACT;;AAEA;AACA,QAAQ,CAAC;AACT,wBAAwB,CAAC;AACzB;;AAEA,YAAY,CAAC;AACb,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DyB;AACzB;AAC8B;AACE;AACU;AACR;AACM;AACI;AACJ;AACwB;AAChE;AACmC;AAC4B;AACjC;AACG;AACmB;AACX;AACkB;AACd;AACA;AACJ;AACY;AACrD;AACA;AACA,IAAI,6CAAc;AAClB,UAAU,6CAAe;AACzB;AACA;AACA,QAAQ,qDAAU;AAClB,QAAQ,qDAAU;AAClB;AACA,QAAQ,mDAAQ;AAChB,QAAQ,mDAAQ;AAChB;AACA,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAO;AACpB,YAAY,gEAAmB;AAC/B;AACA;AACA,QAAQ,2DAAc;AACtB,QAAQ,uDAAe;AACvB;AACA;AACA;AACA;AACA,yBAAyB,qDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAM;AACV,IAAI,wDAAW;AACf;AACA,IAAI,4CAAc;AAClB;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,CAAC;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAM,qBAAqB,+CAAM;AAC9D,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,qDAAU;AAC1B;AACA;AACA;AACA,uBAAuB,+CAAM;AAC7B,IAAI,gDAAO;AACX;AACA,6BAA6B,qDAAY;AACzC,IAAI,gDAAO;AACX;AACA,2CAA2C,iDAAQ;AACnD,IAAI,gDAAO;AACX;AACA,2BAA2B,iDAAU;AACrC,IAAI,gDAAO;AACX;AACA,IAAI,gDAAO,mBAAmB,oDAAW;AACzC;AACA,IAAI,gDAAO,UAAU,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,QAAQ,CAAC;AACT,KAAK;AACL;AACA,QAAQ,CAAC;AACT,KAAK;AACL;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA,IAAI,+CAAiB;AACrB,YAAY,+CAAiB;AAC7B,YAAY,2DAAK;AACjB;AACA,sBAAsB,2CAAK;AAC3B;AACA,sBAAsB,CAAC;AACvB,kCAAkC,YAAY,kBAAkB;AAChE,sBAAsB,sDAAS,YAAY;AAC3C,qBAAqB,sDAAS;AAC9B,sBAAsB,sDAAS,yEAAyE;AACxG,wBAAwB,sDAAS,gEAAgE;AACjG,4CAA4C,IAAI,sDAAS,wEAAwE;AACjI;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA,YAAY,2DAAK;AACjB,SAAS;AACT,KAAK;AACL;AACA,IAAI,iDAAQ;AACZ,IAAI,iDAAa;AACjB,IAAI,kDAAU;AACd,IAAI,6DAAqB;AACzB;AACA,OAAO,gDAAO;AACd,QAAQ,2DAAa;AACrB,CAAC;;;;;;;;;;;;;;;;;;ACzLiC;AACO;AACzC;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA,UAAU,4CAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB;AACA,KAAK;AACL;AACA;AACA,+CAA+C,4CAAI;AACnD,KAAK;AACL;AACA;AACA,+BAA+B,sDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/D8B;AACM;AACM;AACV;AACV;AAC4C;AACvB;AACE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,iEAAY;AAClC,0BAA0B,iEAAY;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,CAAC;AACT;AACA,YAAY,CAAC;AACb;AACA;AACA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,CAAC;AACT;AACA,YAAY,CAAC;AACb;AACA;AACA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B,+CAAM;AAChC,KAAK;AACL;AACA;AACA,kBAAkB,0DAAK;AACvB;AACA;AACO;AACP,UAAU,2CAAE;AACZ;AACA;AACA,QAAQ,2CAAE;AACV,QAAQ,mDAAS;AACjB,QAAQ,mDAAS;AACjB;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC,mBAAmB,2CAAE;AAC9B,QAAQ,CAAC;AACT,MAAM;AACN,QAAQ,mDAAS;AACjB,QAAQ,mDAAS,KAAK,qDAAC;AACvB;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA,sBAAsB,6CAAQ;AAC9B;AACA,QAAQ,8CAAM,CAAC,2CAAE;AACjB,qBAAqB,8CAAM,CAAC,2CAAE,WAAW,6CAAQ;AACjD;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,gDAAO;AAC3B,2BAA2B,gDAAO;AAClC;AACA;AACA,wBAAwB,mBAAmB;AAC3C,6BAA6B,gDAAO;AACpC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,sCAAsC,gDAAO;AAC7C,SAAS;AACT;AACA,IAAI,gDAAO;AACX;AACA;AACO;AACP,mBAAmB,gDAAO;AAC1B,sBAAsB,gDAAO;AAC7B;AACA,sBAAsB,gDAAO;AAC7B;AACA;AACA,2CAA2C,2CAAE,SAAS,4CAAI,aAAa,gDAAO;AAC9E;AACA,sCAAsC,gDAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,SAAS;AACT,MAAM;AACN,2BAA2B,2CAAE,QAAQ,4CAAI;AACzC,YAAY,MAAM,OAAO,qDAAC,2BAA2B,qDAAC;AACtD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,gDAAO;AACX;AACA,IAAI,gDAAO;AACX;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,YAAY,CAAC,2BAA2B,CAAC;AACzC;AACA;AACO;AACP;AACA,IAAI,CAAC;AACL;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA,CAAC;AACD;AACA,iEAAe,MAAM;;;;;;;;;;;;;;;;;;AC9NrB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrC8B;AAIT;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAMuB;AACsD;AAC7C;AACO;AACoB;AACrC;AACmB;AACG;AACd;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAK,KAAK,yCAAE;AACpB;AACA;AACA;AACA,eAAe,kDAAQ;AACvB;AACA;AACA;AACA,gBAAgB,mDAAS;AACzB;AACA;AACA;AACA,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAM;AAChC,0BAA0B,gDAAM;AAChC;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,iCAAiC,sDAAS;AAC1C;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,iEAAY;AAC/B,IAAI,kDAAQ;AACZ;AACA,iBAAiB,iEAAY;AAC7B,IAAI,gDAAM;AACV;AACA,iBAAiB,iEAAY;AAC7B,IAAI,gDAAM;AACV;AACA,oBAAoB,iEAAY;AAChC,IAAI,mDAAS;AACb;AACA;AACA;AACA,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,IAAI,kDAAQ;AACZ,IAAI,gDAAM;AACV,IAAI,gDAAM;AACV,IAAI,mDAAS;AACb;AACA;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAM;AAClB,YAAY,gDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,YAAY,CAAC;AACb,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAQ;AACZ,IAAI,gDAAM;AACV,IAAI,gDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,kDAAQ;AAC3B,cAAc,gDAAM;AACpB,cAAc,gDAAM;AACpB;AACA;AACA;AACA,yBAAyB,OAAO,SAAS,2BAA2B,OAAO,EAAE,OAAO,EAAE;AACtF;AACA,IAAI,mDAAS;AACb,IAAI,mDAAS;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,mDAAS;AACb;AACA;AACO;AACP,SAAS,2CAAE;AACX,eAAe,MAAM;AACrB;AACA,uBAAuB,sDAAU;AACjC;AACA;AACA;AACA;AACA,IAAI,yDAAe;AACnB;AACA;AACO;AACP,oBAAoB,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB;AAC1C;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uCAAuC;AAC7D;AACA,QAAQ,gDAAM;AACd,QAAQ,gDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA,IAAI,gDAAO;AACX,IAAI,gDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA,UAAU;AACV;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAO;AAC3B,uBAAuB,gDAAM,QAAQ,gDAAM;AAC3C;AACA,QAAQ,gDAAO,wBAAwB,gDAAO;AAC9C,QAAQ,gDAAM;AACd;AACA;AACA;AACA,QAAQ,gDAAO;AACf,SAAS,gDAAM,QAAQ,gDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChXa;AACwB;AAClC;AACI;AAC2G;AACtG;AACwB;AAC3B;AACV;AACkD;AAClB;AACT;AACyB;AACP;AACtB;AACC;AACmC;AACA;AACX;AAC1B;AAC4C;AAChD;AACW;AAC/C;AACuD;AACA;AACI;AACV;AACA;AACjD;AACuD;AACF;AACA;AACrD;AAC0D;AACH;AACvD;AACmD;AACD;AAClD;AACyD;AACzD;AACA,eAAe,gDAAO;AACtB;AACA;AACA,WAAW,gDAAO;AAClB;AACA;AACA;AACA,WAAW,gDAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,gBAAgB,+CAAM,SAAS,+CAAM;AACrC;AACA,QAAQ,+CAAM,sBAAsB,+CAAM;AAC1C;AACA,iBAAiB,+CAAM,IAAI,+CAAM,MAAM,+CAAM,SAAS,+CAAM;AAC5D;AACA;AACA,oCAAoC,+CAAM,iBAAiB,+CAAM;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAU,kBAAkB,gDAAW;AACjE;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iCAAiC,gDAAO;AACxC;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA,IAAI,gDAAO;AACX;AACA;AACA;AACA,IAAI,gDAAO;AACX;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,yCAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA,YAAY,mDAAU,CAAC,+CAAM,IAAI,+CAAM;AACvC;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA,gCAAgC,+CAAM;AACtC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA,iEAAiE,2CAAE,QAAQ,4CAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAM,IAAI,+CAAM;AACtC;AACA,mBAAmB,sDAAM;AACzB;AACA;AACA;AACA,YAAY,+CAAM;AAClB,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAM;AACrB;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA,YAAY,mDAAU;AACtB,UAAU;AACV,YAAY,oDAAW;AACvB;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAU;AACtC;AACA,iCAAiC,uEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,mEAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAa,IAAI;AACzB;AACA;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mEAAW,EAAE,4CAAI;AACtE;AACA,sEAAsE,4CAAI;AAC1E;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAE;AAC5B;AACA,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,6BAA6B,uEAAkB,CAAC,+CAAM,IAAI,+CAAM;AAChE,kCAAkC,+CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,+BAA+B,uEAAkB,CAAC,+CAAM,KAAK,+CAAM,gBAAgB,+CAAM,KAAK,+CAAM;AACpG,8BAA8B,gDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAc,gBAAgB,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAc,gBAAgB,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAAM;AAC3C,qCAAqC,+CAAM;AAC3C;AACA;AACA;AACA;AACA,8BAA8B,+CAAM,IAAI,+CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM,uBAAuB,+CAAM,+CAA+C,+CAAM;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAQ;AAChD;AACA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAkB;AACvC,6CAA6C,wDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAM,IAAI,+CAAM;AAC7B;AACA;AACA,yBAAyB,+CAAM;AAC/B,+BAA+B,+CAAM;AACrC,mCAAmC,+CAAM,IAAI,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAkB;AACvC,6CAA6C,wDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAM,IAAI,+CAAM;AACnD;AACA,qBAAqB,yCAAE;AACvB,QAAQ,gDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAM,IAAI,+CAAM;AACjC;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,qBAAqB,+CAAM;AAC3B;AACA,6BAA6B,+CAAM;AACnC,mCAAmC,+CAAM;AACzC,uCAAuC,+CAAM,IAAI,+CAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,wDAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO,WAAW,gDAAO;AACzC,0BAA0B;AAC1B;AACA;AACA,gBAAgB,+CAAM,gBAAgB,+CAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,8BAA8B,+CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA,mCAAmC,uEAAkB;AACrD,2CAA2C,+CAAM,OAAO,+CAAM;AAC9D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,wDAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qEAAa;AAChE;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,+BAA+B,+CAAM,IAAI,+CAAM;AAC/C;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA,qCAAqC,kEAAY;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM,IAAI,+CAAM;AAC3C;AACA,0CAA0C,+CAAM,QAAQ,+CAAM;AAC9D;AACA;AACA,gBAAgB,+CAAM;AACtB,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B,yBAAyB,yCAAE;AAC3B;AACA;AACA;AACA;AACA;AACA,wCAAwC,+CAAU;AAClD;AACA,iDAAiD,uEAAkB;AACnE,uDAAuD,+CAAM,OAAO,+CAAM;AAC1E,qBAAqB;AACrB;AACA;AACA;AACA,oCAAoC,+CAAM;AAC1C;AACA,wCAAwC,uEAAkB;AAC1D,sCAAsC,uEAAkB;AACxD;AACA;AACA;AACA,4DAA4D,+CAAM;AAClE,0DAA0D,+CAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,gDAAgD;AAChD,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAM;AACzC,mCAAmC,+CAAM;AACzC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,iDAAK;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,yBAAyB,gDAAO;AAChC;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAM;AACrC;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM,IAAI,+CAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA,gBAAgB,mDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,2CAA2C,gEAAQ;AACnD;AACA,oBAAoB,6CAAI;AACxB;AACA,kBAAkB,CAAC;AACnB;AACA,IAAI,oDAAS;AACb,IAAI,oDAAS;AACb,CAAC;AACD;AACA,sBAAsB,6CAAI;AAC1B,mBAAmB,+CAAM,iBAAiB,+CAAM;AAChD;AACA,qBAAqB,6CAAI;AACzB;AACA,gBAAgB,+CAAM;AACtB,6BAA6B,+CAAU;AACvC;AACA,IAAI,+CAAM;AACV,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA,gBAAgB,+CAAM;AACtB,mBAAmB,+CAAU;AAC7B;AACA,IAAI,+CAAM;AACV,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA,IAAI,iDAAU;AACd,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA,IAAI,2DAAa;AACjB,CAAC;AACD;AACA,oBAAoB,6CAAI,uCAAuC;AAC/D;AACA,IAAI,8DAAgB;AACpB,CAAC;AACD;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA,oBAAoB,+CAAM,iBAAiB,+CAAM;AACjD,oBAAoB,+CAAM,UAAU,+CAAM,eAAe,+CAAM;AAC/D;AACA,qBAAqB,+CAAM;AAC3B,qBAAqB,+CAAM;AAC3B;AACA,kCAAkC,+CAAM;AACxC;AACA,gBAAgB,mDAAU;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,yCAAyC,kEAAU;AACnD;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,kEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,qBAAqB,uEAAkB;AACvC,iCAAiC,uEAAkB;AACnD;AACA,cAAc,gBAAgB;AAC9B,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,kDAAkD,sDAAQ;AAC1D;AACA;AACA;AACA,YAAY,8CAAS;AACrB,iBAAiB,8CAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,oBAAoB,8CAAS;AAC7B;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,oBAAoB,8CAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAE;AAC5B,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAQ;AAC3B;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAC;AAC3B;AACA,iBAAiB;AACjB;AACA,0BAA0B,sDAAC;AAC3B;AACA,iBAAiB;AACjB;AACA,gCAAgC,yDAAgB,YAAY,sDAAC;AAC7D;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA,mBAAmB,+CAAM;AACzB,mBAAmB,+CAAM;AACzB;AACA;AACA,2BAA2B,uEAAkB;AAC7C,sBAAsB,+CAAM;AAC5B;AACA,4BAA4B,sDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAE;AACvC,QAAQ,gDAAK;AACb;AACA;AACA,uBAAuB,+CAAM;AAC7B,uBAAuB,+CAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,sBAAsB,2CAAE,SAAS,4CAAI;AACrC;AACA;AACA,uCAAuC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAU;AACtD,4CAA4C,gDAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAY,OAAO,4CAAO;AACxD,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,gDAAO;AACvB;AACA,oBAAoB,gDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4CAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,6BAA6B,kEAAY;AACzC,wBAAwB,6CAAI;AAC5B;AACA,QAAQ,kDAAQ;AAChB,QAAQ,kDAAQ;AAChB,MAAM;AACN,sBAAsB,kDAAQ;AAC9B,QAAQ,kDAAQ;AAChB;AACA,IAAI,0DAAc;AAClB,CAAC;AACD;AACA,wBAAwB,6CAAI;AAC5B;AACA,QAAQ,kDAAQ;AAChB,QAAQ,kDAAQ;AAChB,MAAM;AACN,sBAAsB,kDAAQ;AAC9B,QAAQ,kDAAQ;AAChB;AACA,IAAI,0DAAc;AAClB,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM,IAAI,+CAAM;AAC3C;AACA,+BAA+B,+CAAM,QAAQ,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA;AACA;AACA;AACA,+BAA+B,sDAAM;AACrC;AACA,sBAAsB,mDAAQ;AAC9B,yBAAyB,yCAAE;AAC3B;AACA;AACA;AACA,yCAAyC,uEAAkB;AAC3D;AACA,wCAAwC,+CAAU;AAClD,6CAA6C,+CAAM,OAAO,+CAAM;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,iDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM,IAAI,+CAAM;AACzD;AACA,qBAAqB,sDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,mDAAU;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,oDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAI,iCAAiC;AAC1D;AACA,QAAQ,+CAAM;AACd,QAAQ,+CAAM,wBAAwB,oDAAW;AACjD,IAAI,oDAAW,CAAC,+CAAM;AACtB,CAAC;AACD;AACA,qBAAqB,6CAAI,gCAAgC;AACzD;AACA,QAAQ,+CAAM,wBAAwB,oDAAW;AACjD,IAAI,oDAAW,CAAC,+CAAM;AACtB,CAAC;AACD;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,QAAQ,+CAAM;AACd,QAAQ,qDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAM,IAAI,+CAAM;AAChD,cAAc;AACd,yBAAyB,+CAAM;AAC/B,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,+CAAM;AAC9B,wBAAwB,+CAAM;AAC9B;AACA;AACA,cAAc;AACd,uBAAuB,+CAAM;AAC7B,uBAAuB,+CAAM;AAC7B;AACA;AACA;AACA;AACA,YAAY,qDAAU;AACtB;AACA,YAAY,mDAAQ;AACpB;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA;AACA,YAAY,+CAAM;AAClB,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAkB;AACpD;AACA,gCAAgC,wBAAwB;AACxD;AACA,kCAAkC,uEAAkB;AACpD;AACA;AACA;AACA,cAAc;AACd,iCAAiC,uEAAkB;AACnD,iCAAiC,uEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAE;AACnB,QAAQ,gDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA,kCAAkC,gDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAkB;AACxD;AACA;AACA;AACA;AACA,wCAAwC,gDAAO;AAC/C;AACA;AACA,kCAAkC,gDAAO;AACzC,gCAAgC,4CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4CAAI;AACrD;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAO;AACP;AACA;AACA;AACA;AACA,oBAAoB,+CAAM,IAAI,+CAAM;AACpC;AACA,uBAAuB,uDAAU,sBAAsB,6CAAQ,CAAC,KAAK,EAAE,KAAK,EAAE;AAC9E;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA,yBAAyB,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,0BAA0B,EAAE,IAAI,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAgB;AAC9C;AACA,iCAAiC;AACjC,sCAAsC;AACtC,MAAM;AACN,sBAAsB,UAAU;AAChC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAkB;AACrD,gCAAgC,+CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAE;AACpB;AACA,KAAK;AACL,IAAI,iDAAK;AACT,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA,0BAA0B,6DAAa,EAAE,6DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,0BAA0B,CAAC;AAC3B,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,CAAC;AAC3B,2BAA2B,CAAC;AAC5B,2BAA2B,CAAC;AAC5B;AACA,0BAA0B,+CAAM,IAAI,+CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM;AAC/C,8BAA8B,yCAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAQ;AACtC;AACA;AACA;AACA;AACA,mDAAmD,+CAAM;AACzD;AACA,4BAA4B,+CAAM;AAClC,yDAAyD,+CAAU;AACnE;AACA;AACA,uCAAuC,uEAAkB;AACzD;AACA;AACA;AACA,sBAAsB,+CAAM,OAAO,+CAAM;AACzC;AACA;AACA;AACA,wCAAwC,+CAAM;AAC9C,wCAAwC,+CAAM;AAC9C;AACA,iBAAiB,+CAAM;AACvB,gCAAgC,+CAAU,CAAC,+CAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,iDAAK;AACb;AACA;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,mDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA;AACA;AACA,gCAAgC,+CAAU,CAAC,+CAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,mDAAQ;AACpB,SAAS;AACT;AACA;AACA,4CAA4C,4CAAI;AAChD;AACA,wBAAwB,6CAAI;AAC5B;AACA,IAAI,+CAAM;AACV,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qDAAO;AACpB;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAkB;AAC3C,2BAA2B,gDAAO;AAClC,uBAAuB,4CAAO;AAC9B;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,iDAAiD,oEAAU,CAAC;AAC5D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAE;AACxB;AACA,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B,SAAS;AACT,QAAQ,gDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,uBAAuB,gDAAO;AAC9B,wBAAwB,gDAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,EAAE,6DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oEAAQ;AACnD;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAI;AACpC;AACA;AACA;AACA;AACA,QAAQ,oEAA2B;AACnC,8CAA8C,kEAAY;AAC1D;AACA,gBAAgB,gDAAK,KAAK,yCAAE;AAC5B,yBAAyB,kDAAQ,4BAA4B,+CAAQ;AACrE;AACA;AACA;AACA,sBAAsB;AACtB;AACA,2BAA2B,+CAAQ;AACnC,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4CAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAO;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAiB;AACnD;AACA,gBAAgB,MAAM,SAAS,sDAAC;AAChC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAQ;AAC5B,0BAA0B,kDAAQ;AAClC,0BAA0B,kDAAQ;AAClC;AACA,wBAAwB,kDAAQ,eAAe,kDAAQ;AACvD,sBAAsB,kDAAQ;AAC9B,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAQ;AACtC,8BAA8B,kDAAQ;AACtC;AACA;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,QAAQ,CAAC,sCAAsC,gEAAgB,CAAC;AAChE;AACA;AACA,uBAAuB,gEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC,QAAQ,GAAG;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,kDAAQ;AAChG;AACA;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAU,QAAQ,qDAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,EAAE,6DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB,QAAQ,gDAAO;AACf;AACA;AACA,QAAQ,kDAAQ;AAChB,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,iDAAiD,uEAAU,CAAC;AAC5D,UAAU;AACV;AACA;AACA;AACA;AACA,6DAA6D,mEAAW;AACxE;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACz9FqE;AACtB;AACD;AACd;AACsB;AACV;AACe;AACJ;AACT;AAC/C;AACO;AACP;AACA,IAAI,mDAAY,CAAC,0DAAK;AACtB,IAAI,mDAAY,CAAC,iEAAY;AAC7B,IAAI,qDAAY,GAAG,iEAAY;AAC/B,IAAI,sDAAY,CAAC,0DAAK;AACtB,QAAQ,0DAAK;AACb;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,0DAAK;AACb,qBAAqB,0DAAK;AAC1B;AACA;AACA;AACO;AACP,IAAI,6CAAM;AACV,QAAQ,gDAAS;AACjB,QAAQ,gDAAS;AACjB,KAAK;AACL;AACA;AACO;AACP,uBAAuB,0DAAK;AAC5B,uBAAuB,oEAAuB;AAC9C;AACA;AACA;AACA,IAAI,sDAAe;AACnB;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP;AACA,eAAe,oEAAuB;AACtC;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,4CAAO;AACX;AACA,oBAAoB,uDAAQ,KAAK,uDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAU;AAClC;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAW;AACvB;AACA;AACA,4BAA4B,QAAQ;AACpC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC,QAAQ,EAAE;AACnB,KAAK;AACL,IAAI,CAAC;AACL;AACO;AACP,eAAe,CAAC;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL,IAAI,CAAC;AACL;;;;;;;;;;;;;;;;;;;;;;AC1I0C;AACI;AACT;AACrC;AACO;AACP,QAAQ,8CAAO;AACf,QAAQ,8CAAO;AACf,QAAQ,8CAAO;AACf,MAAM;AACN,QAAQ,8CAAO,oBAAoB,8CAAO;AAC1C,yBAAyB,8CAAO;AAChC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ;AACR,IAAI,CAAC;AACL,IAAI,sDAAe;AACnB;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA;AACO;AACP,oBAAoB,CAAC;AACrB,2BAA2B,CAAC;AAC5B;AACA,qBAAqB,0DAAK;AAC1B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FqC;;AAInB;AACY;AACY;AACZ;AACE;AACV;;AAEtB;AACsC;AACK;AACE;;AAED;AACI;AACA;AACP;AACH;AACI;;AAE1C;AACA,qBAAqB,oDAAiD;AACtE;AACA;AACA;AACA;AACA,CAAC;;;AAGD,uBAAuB,CAAC;;AAET;AACf;AACA;AACA;AACA,wBAAwB,+CAAM;AAC9B;AACA,sBAAsB,aAAa,qDAAC,uCAAuC;AAC3E,SAAS;;AAET;AACA;;AAEA;AACA,iCAAiC,8DAAgB;AACjD,iCAAiC,8DAAgB;;AAEjD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD,GAAG;AACrD,qEAAqE,kBAAkB,oBAAoB,iBAAiB,6BAA6B,YAAY;AACrK,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,2CAAE,UAAU,4CAAI;AACvD,gBAAgB,2CAAE;AAClB;AACA;AACA,4BAA4B,4CAAI;AAChC;AACA;;AAEA,sCAAsC,kCAAkC,GAAG,KAAK;AAChF,iBAAiB;AACjB,mCAAmC,4CAAI;;AAEvC,4DAA4D,IAAI;AAChE;;AAEA;AACA;AACA;AACA,aAAa;;AAEb,6BAA6B,CAAC;AAC9B;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA,YAAY,2CAAE,SAAS,4CAAI;AAC3B;AACA,4EAA4E,qDAAC,kBAAkB;AAC/F,4EAA4E,qDAAC,kBAAkB;AAC/F;AACA;AACA,2BAA2B,qDAAC;AAC5B;AACA,gBAAgB,2CAAE;AAClB;AACA,8DAA8D,qDAAC,aAAa;AAC5E,kBAAkB;AAClB;AACA,0DAA0D,qDAAC,cAAc;AACzE;AACA;AACA;;AAEA;;AAEA,QAAQ,CAAC,kBAAkB,uDAAa;;AAExC,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,MAAM,cAAc,qDAAC;AACzC,iBAAiB;AACjB,cAAc;AACd,gBAAgB,MAAM,SAAS,qDAAC;AAChC;AACA,SAAS;;;AAGT,QAAQ,CAAC;AACT,wBAAwB,CAAC;;AAEzB;;AAEA,YAAY,CAAC;AACb,YAAY,gDAAO;AACnB,SAAS;;AAET,QAAQ,CAAC;AACT,wBAAwB,CAAC;;AAEzB;;AAEA,YAAY,CAAC;AACb,YAAY,gDAAO;AACnB,SAAS;;AAET,QAAQ,CAAC;AACT;AACA,4BAA4B,MAAM,OAAO,qDAAC;;AAE1C,mCAAmC,oDAAU;AAC7C,oCAAoC,CAAC;AACrC;AACA;AACA;AACA,qCAAqC,UAAU,IAAI,qDAAC,gBAAgB;AACpE,qCAAqC,eAAe,IAAI,qDAAC,cAAc;AACvE,qCAAqC,oBAAoB,IAAI,qDAAC,aAAa;AAC3E;AACA;AACA;;AAEA,6BAA6B,CAAC;AAC9B,+BAA+B,CAAC;;AAEhC;AACA;AACA;;AAEA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,gBAAgB,uDAAU,oBAAoB,kDAAqB,cAAc;AACjF,aAAa;;AAEb;AACA,YAAY,CAAC;;AAEb;AACA,SAAS;;AAET,QAAQ,CAAC;AACT,mCAAmC,oDAAU,IAAI,qDAAC,kBAAkB,EAAE,8DAAgB,YAAY;AAClG,oCAAoC,CAAC;AACrC,8CAA8C,QAAQ,qCAAqC,mCAAmC;AAC9H,+BAA+B,QAAQ,cAAc,qDAAC,uBAAuB;;AAE7E,8CAA8C,QAAQ,qCAAqC,wCAAwC;AACnI,+BAA+B,QAAQ,cAAc,qDAAC,iBAAiB;;AAEvE,gDAAgD,QAAQ;AACxD,+BAA+B,QAAQ;AACvC,qCAAqC,UAAU,IAAI,qDAAC,gBAAgB;AACpE,qCAAqC,eAAe,IAAI,qDAAC,cAAc;AACvE,qCAAqC,oBAAoB,IAAI,qDAAC,aAAa;AAC3E;AACA;AACA;AACA,YAAY,CAAC;;;AAGb,6BAA6B,CAAC;AAC9B,0BAA0B,CAAC;AAC3B,6BAA6B,CAAC;AAC9B,+BAA+B,CAAC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAU,eAAe,kDAAqB,gBAAgB;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAU,sBAAsB,kDAAqB,kBAAkB;AACvF,aAAa;;;AAGb;;AAEA,SAAS;;AAET,QAAQ,CAAC;AACT,kCAAkC,+CAAM;AACxC;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA,iCAAiC,CAAC,4BAA4B,kBAAkB,oBAAoB,uBAAuB;AAC3H,4BAA4B,UAAU;AACtC;AACA;AACA,oBAAoB,uDAAU,uBAAuB,QAAQ,SAAS,UAAU,KAAK,gBAAgB;AACrG;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,gBAAgB,CAAC;AACjB;AACA,SAAS;;AAET;AACA,8BAA8B,CAAC,8BAA8B,UAAU;AACvE,wCAAwC,sBAAsB,SAAS,UAAU;AACjF;AACA,YAAY,CAAC;;AAEb;AACA,gBAAgB,uDAAU,uBAAuB,QAAQ,SAAS,UAAU,KAAK,gBAAgB;AACjG;;AAEA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA,yBAAyB,8DAAgB;AACzC,0BAA0B,gDAAO;;AAEjC;;AAEA,uBAAuB,CAAC;AACxB;AACA,gCAAgC,GAAG;AACnC,sBAAsB,8BAA8B,oBAAoB,WAAW,uBAAuB;AAC1G,iGAAiG,qDAAO,CAAC;AACzG,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,CAAC;AACvB,wBAAwB,CAAC;;AAEzB;AACA;AACA,YAAY,oDAAS;AACrB,YAAY,oDAAS;AACrB,SAAS;;;AAGT,QAAQ,CAAC;AACT;AACA;;AAEA,wDAAwD,GAAG,EAAE,wBAAwB;AACrF;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,+CAAM;AACtB,SAAS;;AAET;;AAEA,QAAQ,2CAAE;AACV;;AAEA;AACA;;AAEA,2BAA2B,uDAAU,wBAAwB,YAAY;AACzE;AACA;AACA;;AAEA;AACA,QAAQ,CAAC;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd,kDAAkD,MAAM,GAAG;AAC3D,qDAAqD,OAAO,GAAG;;AAE/D,iCAAiC,iBAAiB,WAAW,YAAY,EAAE,aAAa;AACxF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,2DAAQ;AAC/B;AACA;AACA;AACA,uBAAuB,6DAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,+CAAU;AAC7C,+BAA+B,EAAE,IAAI,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,gDAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,kBAAkB;AACtE,QAAQ,CAAC;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;ACrc+B;AACE;AACsC;AAOpD;AACnB;AACO;AACP,qBAAqB,gEAAkB;AACvC,qBAAqB,gEAAkB;AACvC;AACA;AACA;AACA;AACO;AACP,8BAA8B,8CAAS,OAAO,8CAAS,EAAE,8CAAS,EAAE,8CAAS;AAC7E;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,gEAAkB;AACrC,mBAAmB,gEAAkB;AACrC;AACA;AACA,sBAAsB,8CAAS;AAC/B,oBAAoB,8CAAS,UAAU;AACvC;AACA,sBAAsB,8CAAS;AAC/B,oBAAoB,8CAAS;AAC7B;AACA;AACA,sCAAsC,mBAAmB,kDAAa,GAAG;AACzE,0CAA0C,mBAAmB,kDAAa,GAAG;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,+CAAU,kBAAkB,gDAAW;AAC7D;AACA;;;;;;;;;;;;;;;;;;;;;;ACjD+B;AACE;AAGjB;AAGG;AACnB;AACO;AACP,oCAAoC,gDAAO,gCAAgC,+CAAM;AACjF,oCAAoC,gDAAO,iCAAiC,+CAAM;AAClF;AACA,uBAAuB,+CAAM,KAAK,0CAAO;AACzC,uBAAuB,+CAAM,KAAK,0CAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,SAAS,+CAAM,KAAK,0CAAO;AAC3B,SAAS,+CAAM,KAAK,0CAAO;AAC3B;AACA,SAAS,+CAAM;AACf,SAAS,+CAAM;AACf;AACA,SAAS,gDAAO,6BAA6B;AAC7C,SAAS,gDAAO;AAChB;AACA;AACA;AACA;AACO;AACP,iBAAiB,8CAAS;AAC1B,iBAAiB,8CAAS;AAC1B;AACA,mBAAmB,8CAAS;AAC5B,mBAAmB,8CAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,8CAAS,cAAc,8CAAS;AACjD;;;;;;;;;;;;;;;ACpDA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrJO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;AClBA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFqD;AACX;AACT;AAC6C;AAC7C;AACe;AACjB;AACA;AAC/B;AACwD;AACC;AACpB;AACrC;AAC8D;AACpB;AAC1C;AACA;AACA;AACA,IAAI,oDAAoD;AACxD;AACA,kBAAkB,gJAAkC;AACpD,wBAAwB,gLAAkD;AAC1E,2BAA2B,8JAAyC;AACpE,sBAAsB,sJAAqC;AAC3D;AACA;AACA,sBAAsB,8CAAS,CAAC,8DAAa,EAAE,8DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAM,QAAQ,+CAAM;AACtC;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP,yBAAyB,sDAAS,CAAC,uEAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAM;AACxB,mCAAmC,sEAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAE;AACtB,IAAI,gDAAO;AACX;AACA;AACA;AACA,yBAAyB,sEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAO;AACX,IAAI,gDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0DAAK;AAC9C,6BAA6B,OAAO;AACpC,2BAA2B,0DAAK,mCAAmC,MAAM;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAE;AACzB,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA,oCAAoC,sEAAkB;AACtD;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,kBAAkB,+CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,IAAI,OAAO,GAAG,oBAAoB,GAAG,0BAA0B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD,kBAAkB,sBAAsB;AACxC,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,IAAI,kBAAkB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa,GAAG,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,0DAAK;AACb;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnzBa;AAC5B;AAC2E;AAC5B;AACJ;AACF;AACT;AAC0C;AACpD;AACiD;AAC3C;AACkC;AACpC;AACsB;AACkB;AACrB;AAC+E;AAC5H;AACwC;AACU;AACH;AACR;AACa;AACZ;AACA;AACxC;AACiD;AACA;AACA;AACA;AACA;AACoB;AACK;AACqC;AAC/G;AACA;AACA;AACA,WAAW,iEAAO;AAClB,WAAW,iEAAO;AAClB,WAAW,iEAAO;AAClB,WAAW,iEAAO;AAClB,WAAW,iEAAO;AAClB;AACA;AACO;AACP,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC,+BAA+B,qDAAa;AACjD,IAAI,CAAC,+BAA+B,qDAAa;AACjD;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA,KAAK;AACL;AACA;AACO;AACP,yBAAyB,2DAAK;AAC9B;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB,CAAC;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB,IAAI,MAAM;AAC/E;AACA,kBAAkB,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAQ,CAAC;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB,CAAC;AAClB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,sBAAsB,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,CAAC;AAC/B;AACA,4BAA4B;AAC5B;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,CAAC;AACnB;AACA,yBAAyB,CAAC;AAC1B;AACA,sBAAsB;AACtB,mCAAmC,MAAM;AACzC,uBAAuB,MAAM;AAC7B,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,4BAA4B,gDAAM;AAClC,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS,sDAAE,UAAU,8CAAM,CAAC,2CAAE;AAC9B;AACA,YAAY,sDAAE;AACd;AACA;AACA;AACA,mCAAmC,sDAAE,WAAW;AAChD;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC,cAAc,2CAAE;AACrB,IAAI,CAAC;AACL,wBAAwB,CAAC;AACzB;AACA,aAAa,2CAAE;AACf,mBAAmB,mDAAY;AAC/B;AACA;AACA,mBAAmB,mDAAY;AAC/B;AACA,YAAY,2CAAE;AACd,mBAAmB,mDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,gDAAO;AACvB,gBAAgB,qDAAc;AAC9B,gBAAgB,iDAAQ;AACxB,cAAc;AACd;AACA,oBAAoB,mDAAY;AAChC,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA,IAAI,CAAC;AACL,YAAY,2CAAE;AACd,8BAA8B,uDAAU;AACxC;AACA;AACA;AACA,cAAc;AACd,gBAAgB,mDAAY;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,wBAAwB,gDAAM;AAC9B,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAK;AAC1C;AACA,gCAAgC,2CAAE;AAClC;AACA,yBAAyB,CAAC;AAC1B;AACA,kBAAkB,sDAAC,0BAA0B;AAC7C;AACA,iDAAiD,UAAU;AAC3D;AACA,wDAAwD,UAAU;AAClE,2DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA,8BAA8B,CAAC;AAC/B,0BAA0B,CAAC;AAC3B,yBAAyB,CAAC;AAC1B;AACA;AACA,gBAAgB,gDAAO;AACvB,YAAY,gDAAO;AACnB;AACA;AACA;AACA,4BAA4B,yDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAe;AAC5C;AACA,oBAAoB,gDAAO,6BAA6B,+DAAiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6DAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO;AACvB;AACA,SAAS;AACT;AACA;AACA,gBAAgB,gDAAO;AACvB;AACA,2BAA2B,uDAAS;AACpC;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD,cAAc;AACd,yCAAyC,mBAAmB;AAC5D,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAS;AAChC;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,uBAAuB,gDAAM;AAC7B,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS,sDAAC,sGAAsG;AAChH,SAAS,sDAAC;AACV,SAAS,sDAAC;AACV,oCAAoC,sDAAC,wBAAwB;AAC7D,SAAS,sDAAC;AACV,SAAS,sDAAC;AACV,SAAS,sDAAC;AACV;AACA,IAAI,CAAC;AACL;AACA;AACA,oBAAoB,CAAC;AACrB,QAAQ,iEAAoB;AAC5B,QAAQ,CAAC;AACT,QAAQ,2DAAK;AACb,QAAQ,sDAAe;AACvB;AACA;AACA,uBAAuB,kEAAY;AACnC,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACA,IAAI,CAAC,+BAA+B,2DAAK;AACzC,IAAI,CAAC;AACL;AACA,QAAQ,2DAAK;AACb,QAAQ,mDAAY;AACpB,KAAK;AACL;AACA,IAAI,CAAC,mBAAmB,kEAAY;AACpC,IAAI,CAAC;AACL,QAAQ,2DAAK;AACb,QAAQ,mDAAY;AACpB,KAAK;AACL;AACA,IAAI,CAAC;AACL,sBAAsB,gDAAM,CAAC,sDAAC;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,CAAC,+BAA+B,kEAAY;AAChD,IAAI,CAAC;AACL;AACA,QAAQ,2DAAK;AACb,QAAQ,qDAAY;AACpB,KAAK;AACL;AACA,IAAI,CAAC,+BAA+B,gDAAO;AAC3C,IAAI,CAAC;AACL;AACA,QAAQ,gDAAO;AACf,QAAQ,2DAAK;AACb,eAAe,kEAAqB,KAAK,kEAAqB;AAC9D,KAAK;AACL;AACA,IAAI,CAAC,gCAAgC,kEAAY;AACjD,IAAI,CAAC;AACL;AACA,QAAQ,gDAAO;AACf,QAAQ,2DAAK;AACb,QAAQ,yDAAY;AACpB,KAAK;AACL;AACA;AACO;AACP,oBAAoB,gDAAM;AAC1B,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,2CAAE,UAAU,4CAAI,eAAe,2CAAE,QAAQ,4CAAI;AACrE;AACA;AACA;AACA,YAAY,sDAAC;AACb,yDAAyD,yCAAI,gCAAgC;AAC7F;AACA;AACA,YAAY,sDAAC;AACb,2DAA2D,+CAAM,gCAAgC;AACjG,wDAAwD,+CAAM,WAAW;AACzE,eAAe,+CAAM,mCAAmC;AACxD,oBAAoB,aAAa;AACjC,2CAA2C,+CAAM,eAAe;AAChE;AACA;AACA,YAAY,sDAAC;AACb,sEAAsE,+CAAM,WAAW;AACvF;AACA;AACA,YAAY,sDAAC;AACb,6DAA6D,6CAAI,gCAAgC;AACjG;AACA;AACA,YAAY,sDAAC;AACb,0DAA0D,yCAAI,WAAW;AACzE;AACA;AACA,YAAY,sDAAC;AACb,wDAAwD,8CAAK,kCAAkC;AAC/F;AACA;AACA,YAAY,sDAAC;AACb,yDAAyD,8CAAK,mCAAmC;AACjG;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA,QAAQ,yCAAI;AACZ,QAAQ,sDAAa;AACrB,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA,YAAY,CAAC;AACb,YAAY,oDAAW,CAAC,CAAC;AACzB,UAAU;AACV,YAAY,CAAC;AACb,YAAY,oDAAW;AACvB;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL,QAAQ,oDAAW;AACnB,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA,QAAQ,+CAAM;AACd,QAAQ,2DAAK,cAAc,+CAAM;AACjC,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,4DAAK;AACb;AACA,QAAQ,6CAAI;AACZ,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA,QAAQ,yCAAI;AACZ,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,2DAAK;AACb;AACA,qBAAqB,8CAAK;AAC1B,aAAa,8CAAK;AAClB,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,2DAAK;AACb;AACA,QAAQ,8CAAK;AACb,KAAK;AACL;AACA;AACO;AACP,kBAAkB,gDAAM;AACxB,eAAe,sDAAC;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA,kCAAkC,CAAC;AACnC,oBAAoB,sDAAC,uCAAuC,gBAAgB,sDAAC,sBAAsB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAC,2BAA2B,0BAA0B,sDAAC,0BAA0B,OAAO,MAAM;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAY;AAClD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA,oBAAoB,yDAAY;AAChC,MAAM;AACN;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,wBAAwB,gDAAM;AAC9B,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,sDAAC,+BAA+B;AAC/E,oCAAoC,sDAAC,gBAAgB;AACrD,uCAAuC,sDAAC,2BAA2B;AACnE;AACA;AACA,QAAQ,2CAAE,SAAS,4CAAI;AACvB,uDAAuD,sDAAC,iBAAiB;AACzE;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL,wBAAwB,gDAAM;AAC9B,mBAAmB,2DAAU,CAAC,sDAAC;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA,4GAA4G,sDAAC,QAAQ;AACrH;AACA,0FAA0F,sDAAC,YAAY;AACvG;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA,sBAAsB,CAAC;AACvB;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,CAAC;AACjB;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA,iCAAiC,8DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,qDAAqD,uDAAO,CAAC;AAC7D;AACA,sCAAsC,uDAAU,iBAAiB,QAAQ;AACzE;AACA,0BAA0B,8CAAI;AAC9B,iBAAiB;AACjB;AACA,4BAA4B,CAAC;AAC7B;AACA,8BAA8B,SAAS,WAAW,QAAQ;AAC1D,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAU,iCAAiC,iBAAiB,GAAG,WAAW,GAAG,SAAS,KAAK,EAAE;AAC3H;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,CAAC,4BAA4B,wDAAc;AAC/C;AACA,IAAI,CAAC;AACL,6BAA6B,gDAAM;AACnC,mBAAmB,2DAAU,CAAC,sDAAC;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa,gDAAO;AACpB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,0CAA0C,SAAS,wBAAwB,SAAS;AACpF;AACA,gDAAgD,2CAAK;AACrD,QAAQ,CAAC;AACT;AACA,QAAQ,CAAC;AACT;AACA,YAAY,2DAAiB;AAC7B,SAAS;AACT;AACA;AACA;AACA,YAAY,6DAAmB;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,oBAAoB,gDAAM;AAC1B,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,yDAAM,CAAC;AACpD,kDAAkD,qEAAM,CAAC;AACzD,iDAAiD,yDAAM,CAAC;AACxD;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP,wBAAwB,gDAAM;AAC9B,eAAe,sDAAC;AAChB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,8DAAW,CAAC;AAC3E,8DAA8D,4DAAU,CAAC;AACzE;AACA;AACA,yCAAyC,sDAAC;AAC1C,gCAAgC,kBAAkB,8DAA8D,IAAI,sDAAC,eAAe;AACpI,MAAM,sDAAC,gBAAgB;AACvB;AACA,yCAAyC,sDAAC;AAC1C;AACA,mBAAmB,sDAAC,wBAAwB;AAC5C,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sDAAC;AAC1C,WAAW,sDAAC,oBAAoB;AAChC;AACA,eAAe,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,uBAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,sDAAC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,sDAAC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,gBAAgB;AACrE;AACA;AACA;AACA;AACA,MAAM,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,sBAAsB;AAClE;AACA,0CAA0C,sDAAC;AAC3C,gCAAgC,kBAAkB,OAAO,sDAAC,qBAAqB;AAC/E,MAAM,iBAAiB,EAAE,sDAAC,sBAAsB;AAChD,MAAM,iBAAiB,EAAE,gBAAgB,EAAE,sDAAC,mBAAmB;AAC/D,MAAM,sDAAC,oBAAoB;AAC3B,MAAM,sDAAC,oBAAoB;AAC3B,MAAM,iBAAiB,EAAE,sDAAC,qBAAqB;AAC/C,MAAM,iBAAiB,EAAE,sDAAC,wBAAwB;AAClD;AACA,4CAA4C,sDAAC;AAC7C,gCAAgC,kBAAkB,OAAO,sDAAC,wBAAwB;AAClF,MAAM,sDAAC,uBAAuB;AAC9B,MAAM,sDAAC,8BAA8B;AACrC;AACA;AACA;AACA;AACA,eAAe,sDAAC,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAC;AAC3C,WAAW,sDAAC,qBAAqB;AACjC,UAAU,sDAAC,yBAAyB;AACpC,UAAU,sDAAC,2BAA2B;AACtC,UAAU,sDAAC,qBAAqB;AAChC;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,kBAAkB,gDAAM;AACxB,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAC,kBAAkB,UAAU;AACzD;AACA;AACA;AACA,qCAAqC,IAAI,2BAA2B,IAAI;AACxE,gCAAgC,UAAU;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACA;AACO;AACP,kBAAkB,gDAAM;AACxB,eAAe,2DAAU,CAAC,sDAAC;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAE;AAC9B,4BAA4B,2CAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,2CAAE,UAAU,4CAAI;AACpC;AACA,wBAAwB,2CAAE;AAC1B;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA,2BAA2B,CAAC;AAC5B,wCAAwC,gCAAgC;AACxE,6CAA6C,6BAA6B;AAC1E;AACA,4BAA4B,kBAAkB;AAC9C,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA,gBAAgB,kDAAY,CAAC,sDAAC;AAC9B;AACA,mCAAmC,uDAAU,uBAAuB,kCAAkC,KAAK,gBAAgB;AAC3H;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAU,iBAAiB,gBAAgB;AAC9E;AACA;AACA,gCAAgC,8DAAgB;AAChD;AACA,cAAc;AACd;AACA;AACA;AACA,2BAA2B,2CAAE;AAC7B;AACA;AACA,gCAAgC,gDAAM;AACtC,uBAAuB,2DAAU,CAAC,sDAAC;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAC,SAAS,QAAQ,cAAc;AAC7D,6BAA6B,sDAAC,cAAc,QAAQ,YAAY;AAChE,6BAA6B,sDAAC,UAAU,QAAQ,UAAU;AAC1D,6BAA6B,sDAAC,WAAW,QAAQ,SAAS,sDAAC,UAAU,sDAAC,OAAO;AAC7E,6BAA6B,sDAAC,WAAW,QAAQ,kBAAkB,sDAAC,UAAU,sDAAC,OAAO;AACtF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA,YAAY,kDAAQ;AACpB,YAAY,0DAAc;AAC1B,SAAS;AACT;AACA;AACA;;;;;;;UC9iCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;;;;;WCFA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;;;;UEhDA;UACA;UACA;UACA;UACA","sources":["webpack://goroxels-client/./src/img/3rdcf.png","webpack://goroxels-client/./src/img/admin-badge.svg","webpack://goroxels-client/./src/img/arrow.svg","webpack://goroxels-client/./src/img/badges/jimbo.png","webpack://goroxels-client/./src/img/badges/ny24.png","webpack://goroxels-client/./src/img/badges/pepe.png","webpack://goroxels-client/./src/img/badges/pony.png","webpack://goroxels-client/./src/img/badges/scream.png","webpack://goroxels-client/./src/img/badges/star.png","webpack://goroxels-client/./src/img/badges/umum.png","webpack://goroxels-client/./src/img/badges/yoba.png","webpack://goroxels-client/./src/img/badges/z.png","webpack://goroxels-client/./src/img/chunkPlaceholder.png","webpack://goroxels-client/./src/img/cross.svg","webpack://goroxels-client/./src/img/disabled-color.svg","webpack://goroxels-client/./src/img/discord-logo-circle.svg","webpack://goroxels-client/./src/img/dots.svg","webpack://goroxels-client/./src/img/gg-logo.svg","webpack://goroxels-client/./src/img/goroxels.png","webpack://goroxels-client/./src/img/icon-desktop.svg","webpack://goroxels-client/./src/img/icon-phone.svg","webpack://goroxels-client/./src/img/mod-badge.svg","webpack://goroxels-client/./src/img/mouse/mouse-4mb.png","webpack://goroxels-client/./src/img/mouse/mouse-5mb.png","webpack://goroxels-client/./src/img/mouse/mouse-lmb.png","webpack://goroxels-client/./src/img/mouse/mouse-mmb.png","webpack://goroxels-client/./src/img/mouse/mouse-rmb.png","webpack://goroxels-client/./src/img/move-icon.svg","webpack://goroxels-client/./src/img/old-wipes/01.06.20.png","webpack://goroxels-client/./src/img/old-wipes/02.05.22.png","webpack://goroxels-client/./src/img/old-wipes/03.04.23.png","webpack://goroxels-client/./src/img/old-wipes/03.06.19.png","webpack://goroxels-client/./src/img/old-wipes/09.04.18.png","webpack://goroxels-client/./src/img/old-wipes/09.08.19.png","webpack://goroxels-client/./src/img/old-wipes/10.07.17.png","webpack://goroxels-client/./src/img/old-wipes/16.08.25.png","webpack://goroxels-client/./src/img/old-wipes/18.11.19.png","webpack://goroxels-client/./src/img/old-wipes/22.08.18.png","webpack://goroxels-client/./src/img/old-wipes/22.11.18.png","webpack://goroxels-client/./src/img/old-wipes/25.02.19.png","webpack://goroxels-client/./src/img/old-wipes/26.02.20.png","webpack://goroxels-client/./src/img/old-wipes/26.10.23.png","webpack://goroxels-client/./src/img/protectedPattern.png","webpack://goroxels-client/./src/img/stripes.png","webpack://goroxels-client/./src/img/telegram.svg","webpack://goroxels-client/./src/img/toolIcons/clicker.png","webpack://goroxels-client/./src/img/toolIcons/disable-cur.png","webpack://goroxels-client/./src/img/toolIcons/disable.png","webpack://goroxels-client/./src/img/toolIcons/floodfill.png","webpack://goroxels-client/./src/img/toolIcons/line.png","webpack://goroxels-client/./src/img/toolIcons/move.png","webpack://goroxels-client/./src/img/toolIcons/protect.png","webpack://goroxels-client/./src/img/toolIcons/revert.png","webpack://goroxels-client/./src/img/toolIcons/wand-cur.png","webpack://goroxels-client/./src/img/unavailable.png","webpack://goroxels-client/./src/img/user.svg","webpack://goroxels-client/./src/img/user2.png","webpack://goroxels-client/./src/img/vk-logo.svg","webpack://goroxels-client/./src/img/winamp/bg.png","webpack://goroxels-client/./src/img/winamp/bg2.png","webpack://goroxels-client/./src/img/winamp/digits.png","webpack://goroxels-client/./src/img/winamp/enableRadioBtn.png","webpack://goroxels-client/./src/img/winamp/hr-slider-btn-small.png","webpack://goroxels-client/./src/img/winamp/slider-btn.png","webpack://goroxels-client/./src/video/as.webm","webpack://goroxels-client/./src/video/brush.webm","webpack://goroxels-client/./src/video/brush2.webm","webpack://goroxels-client/./src/video/clicker.webm","webpack://goroxels-client/./src/video/clickerMouse.webm","webpack://goroxels-client/./src/video/ctrlZ.webm","webpack://goroxels-client/./src/video/flood.webm","webpack://goroxels-client/./src/video/line.webm","webpack://goroxels-client/./src/video/patternDemo.webm","webpack://goroxels-client/./src/video/phoneDrawing.mp4","webpack://goroxels-client/./src/video/toolC.webm","webpack://goroxels-client/./src/font/pixel/min5.png","webpack://goroxels-client/./src/font/pixel/min5.txt","webpack://goroxels-client/./src/font/pixel/winamp.png","webpack://goroxels-client/./src/font/pixel/winamp.txt","webpack://goroxels-client/./src/css/colorVars.css","webpack://goroxels-client/./src/css/style.css","webpack://goroxels-client/./src/img/badges/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/img/old-wipes/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/img/winamp/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/js/Bucket.js","webpack://goroxels-client/./src/js/Chat.js","webpack://goroxels-client/./src/js/Chunk.js","webpack://goroxels-client/./src/js/ChunkManager.js","webpack://goroxels-client/./src/js/MiniWindow.js","webpack://goroxels-client/./src/js/Pattern.js","webpack://goroxels-client/./src/js/Renderer.js","webpack://goroxels-client/./src/js/Socket.js","webpack://goroxels-client/./src/js/TempChunkPlaceholder.js","webpack://goroxels-client/./src/js/Tool.js","webpack://goroxels-client/./src/js/ToolManager.js","webpack://goroxels-client/./src/js/Window.js","webpack://goroxels-client/./src/js/assets.js","webpack://goroxels-client/./src/js/camera.js","webpack://goroxels-client/./src/js/constants.js","webpack://goroxels-client/./src/js/draggableInputs.js","webpack://goroxels-client/./src/js/fxcanvas.js","webpack://goroxels-client/./src/js/history.js","webpack://goroxels-client/./src/js/indexedDb.js","webpack://goroxels-client/./src/js/init.js","webpack://goroxels-client/./src/js/main.js","webpack://goroxels-client/./src/js/me.js","webpack://goroxels-client/./src/js/player.js","webpack://goroxels-client/./src/js/protocol.js","webpack://goroxels-client/./src/js/template.js","webpack://goroxels-client/./src/js/tools.js","webpack://goroxels-client/./src/js/ui/config.js","webpack://goroxels-client/./src/js/ui/toggles.js","webpack://goroxels-client/./src/js/user.js","webpack://goroxels-client/./src/js/utils/camera.js","webpack://goroxels-client/./src/js/utils/conversions.js","webpack://goroxels-client/./src/js/utils/cssColorsList.js","webpack://goroxels-client/./src/js/utils/math.js","webpack://goroxels-client/./src/js/utils/shapes.js","webpack://goroxels-client/./src/js/utils/strings.js","webpack://goroxels-client/./src/js/utils/webGL.js","webpack://goroxels-client/./src/js/winamp/player.js","webpack://goroxels-client/./src/js/windows.js","webpack://goroxels-client/webpack/bootstrap","webpack://goroxels-client/webpack/runtime/amd define","webpack://goroxels-client/webpack/runtime/chunk loaded","webpack://goroxels-client/webpack/runtime/compat get default export","webpack://goroxels-client/webpack/runtime/define property getters","webpack://goroxels-client/webpack/runtime/hasOwnProperty shorthand","webpack://goroxels-client/webpack/runtime/make namespace object","webpack://goroxels-client/webpack/runtime/publicPath","webpack://goroxels-client/webpack/runtime/jsonp chunk loading","webpack://goroxels-client/webpack/before-startup","webpack://goroxels-client/webpack/startup","webpack://goroxels-client/webpack/after-startup"],"sourcesContent":["export default __webpack_public_path__ + \"/img/3rdcf.png\";","export default __webpack_public_path__ + \"/img/admin-badge.svg\";","export default __webpack_public_path__ + \"/img/arrow.svg\";","export default __webpack_public_path__ + \"/img/jimbo.png\";","export default __webpack_public_path__ + \"/img/ny24.png\";","export default __webpack_public_path__ + \"/img/pepe.png\";","export default __webpack_public_path__ + \"/img/pony.png\";","export default __webpack_public_path__ + \"/img/scream.png\";","export default __webpack_public_path__ + \"/img/star.png\";","export default __webpack_public_path__ + \"/img/umum.png\";","export default __webpack_public_path__ + \"/img/yoba.png\";","export default __webpack_public_path__ + \"/img/z.png\";","export default __webpack_public_path__ + \"/img/chunkPlaceholder.png\";","export default __webpack_public_path__ + \"/img/cross.svg\";","export default __webpack_public_path__ + \"/img/disabled-color.svg\";","export default __webpack_public_path__ + \"/img/discord-logo-circle.svg\";","export default __webpack_public_path__ + \"/img/dots.svg\";","export default __webpack_public_path__ + \"/img/gg-logo.svg\";","export default __webpack_public_path__ + \"/img/goroxels.png\";","export default __webpack_public_path__ + \"/img/icon-desktop.svg\";","export default __webpack_public_path__ + \"/img/icon-phone.svg\";","export default __webpack_public_path__ + \"/img/mod-badge.svg\";","export default __webpack_public_path__ + \"/img/mouse-4mb.png\";","export default __webpack_public_path__ + \"/img/mouse-5mb.png\";","export default __webpack_public_path__ + \"/img/mouse-lmb.png\";","export default __webpack_public_path__ + \"/img/mouse-mmb.png\";","export default __webpack_public_path__ + \"/img/mouse-rmb.png\";","export default __webpack_public_path__ + \"/img/move-icon.svg\";","export default __webpack_public_path__ + \"/img/01.06.20.png\";","export default __webpack_public_path__ + \"/img/02.05.22.png\";","export default __webpack_public_path__ + \"/img/03.04.23.png\";","export default __webpack_public_path__ + \"/img/03.06.19.png\";","export default __webpack_public_path__ + \"/img/09.04.18.png\";","export default __webpack_public_path__ + \"/img/09.08.19.png\";","export default __webpack_public_path__ + \"/img/10.07.17.png\";","export default __webpack_public_path__ + \"/img/16.08.25.png\";","export default __webpack_public_path__ + \"/img/18.11.19.png\";","export default __webpack_public_path__ + \"/img/22.08.18.png\";","export default __webpack_public_path__ + \"/img/22.11.18.png\";","export default __webpack_public_path__ + \"/img/25.02.19.png\";","export default __webpack_public_path__ + \"/img/26.02.20.png\";","export default __webpack_public_path__ + \"/img/26.10.23.png\";","export default __webpack_public_path__ + \"/img/protectedPattern.png\";","export default __webpack_public_path__ + \"/img/stripes.png\";","export default __webpack_public_path__ + \"/img/telegram.svg\";","export default __webpack_public_path__ + \"/img/clicker.png\";","export default __webpack_public_path__ + \"/img/disable-cur.png\";","export default __webpack_public_path__ + \"/img/disable.png\";","export default __webpack_public_path__ + \"/img/floodfill.png\";","export default __webpack_public_path__ + \"/img/line.png\";","export default __webpack_public_path__ + \"/img/move.png\";","export default __webpack_public_path__ + \"/img/protect.png\";","export default __webpack_public_path__ + \"/img/revert.png\";","export default __webpack_public_path__ + \"/img/wand-cur.png\";","export default __webpack_public_path__ + \"/img/unavailable.png\";","export default __webpack_public_path__ + \"/img/user.svg\";","export default __webpack_public_path__ + \"/img/user2.png\";","export default __webpack_public_path__ + \"/img/vk-logo.svg\";","export default __webpack_public_path__ + \"/img/bg.png\";","export default __webpack_public_path__ + \"/img/bg2.png\";","export default __webpack_public_path__ + \"/img/digits.png\";","export default __webpack_public_path__ + \"/img/enableRadioBtn.png\";","export default __webpack_public_path__ + \"/img/hr-slider-btn-small.png\";","export default __webpack_public_path__ + \"/img/slider-btn.png\";","export default __webpack_public_path__ + \"/video/as.webm\";","export default __webpack_public_path__ + \"/video/brush.webm\";","export default __webpack_public_path__ + \"/video/brush2.webm\";","export default __webpack_public_path__ + \"/video/clicker.webm\";","export default __webpack_public_path__ + \"/video/clickerMouse.webm\";","export default __webpack_public_path__ + \"/video/ctrlZ.webm\";","export default __webpack_public_path__ + \"/video/flood.webm\";","export default __webpack_public_path__ + \"/video/line.webm\";","export default __webpack_public_path__ + \"/video/patternDemo.webm\";","export default __webpack_public_path__ + \"/video/phoneDrawing.mp4\";","export default __webpack_public_path__ + \"/video/toolC.webm\";","export default __webpack_public_path__ + \"/font/min5.png\";","export default __webpack_public_path__ + \"/font/min5.txt\";","export default __webpack_public_path__ + \"/font/winamp.png\";","export default __webpack_public_path__ + \"/font/winamp.txt\";","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","var map = {\n\t\"./jimbo.png\": \"./src/img/badges/jimbo.png\",\n\t\"./ny24.png\": \"./src/img/badges/ny24.png\",\n\t\"./pepe.png\": \"./src/img/badges/pepe.png\",\n\t\"./pony.png\": \"./src/img/badges/pony.png\",\n\t\"./scream.png\": \"./src/img/badges/scream.png\",\n\t\"./star.png\": \"./src/img/badges/star.png\",\n\t\"./umum.png\": \"./src/img/badges/umum.png\",\n\t\"./yoba.png\": \"./src/img/badges/yoba.png\",\n\t\"./z.png\": \"./src/img/badges/z.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/badges sync \\\\.png$\";","var map = {\n\t\"./01.06.20.png\": \"./src/img/old-wipes/01.06.20.png\",\n\t\"./02.05.22.png\": \"./src/img/old-wipes/02.05.22.png\",\n\t\"./03.04.23.png\": \"./src/img/old-wipes/03.04.23.png\",\n\t\"./03.06.19.png\": \"./src/img/old-wipes/03.06.19.png\",\n\t\"./09.04.18.png\": \"./src/img/old-wipes/09.04.18.png\",\n\t\"./09.08.19.png\": \"./src/img/old-wipes/09.08.19.png\",\n\t\"./10.07.17.png\": \"./src/img/old-wipes/10.07.17.png\",\n\t\"./16.08.25.png\": \"./src/img/old-wipes/16.08.25.png\",\n\t\"./18.11.19.png\": \"./src/img/old-wipes/18.11.19.png\",\n\t\"./22.08.18.png\": \"./src/img/old-wipes/22.08.18.png\",\n\t\"./22.11.18.png\": \"./src/img/old-wipes/22.11.18.png\",\n\t\"./25.02.19.png\": \"./src/img/old-wipes/25.02.19.png\",\n\t\"./26.02.20.png\": \"./src/img/old-wipes/26.02.20.png\",\n\t\"./26.10.23.png\": \"./src/img/old-wipes/26.10.23.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/old-wipes sync \\\\.png$\";","var map = {\n\t\"./bg.png\": \"./src/img/winamp/bg.png\",\n\t\"./bg2.png\": \"./src/img/winamp/bg2.png\",\n\t\"./digits.png\": \"./src/img/winamp/digits.png\",\n\t\"./enableRadioBtn.png\": \"./src/img/winamp/enableRadioBtn.png\",\n\t\"./hr-slider-btn-small.png\": \"./src/img/winamp/hr-slider-btn-small.png\",\n\t\"./slider-btn.png\": \"./src/img/winamp/slider-btn.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/winamp sync \\\\.png$\";","export default class Bucket{\r\n    constructor(delay, max){\r\n        this._allowance = 0;\r\n\r\n        this.delay = delay;\r\n        this.max = max;\r\n\r\n        this.lastCheck = Date.now();\r\n    }\r\n\r\n    get allowance () {\r\n        if(this.delay === 0) return Infinity;\r\n        \r\n        this._allowance += (Date.now() - this.lastCheck) / this.delay;\r\n\r\n        this.lastCheck = Date.now();\r\n\r\n        if(this._allowance > this.max) this._allowance = this.max;\r\n\r\n        return this._allowance\r\n    }\r\n\r\n    set allowance(c){\r\n        this._allowance = c;\r\n    }\r\n\r\n    spend(count){\r\n        if(this.delay === 0) return true;\r\n\r\n        let allow = this.allowance;\r\n\r\n        if(allow < count) return false;\r\n\r\n        this.allowance  = allow - count;\r\n\r\n        return true\r\n    }\r\n}","import { canvasName, downloaded, game, resolveWhenConfigDownloaded } from './config';\r\nimport { chat as chatEl, chatInput } from './ui/elements';\r\nimport globals from './globals';\r\nimport { translate as t_ } from './translate';\r\nimport cssColors from './utils/cssColorsList'\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport { htmlspecialchars } from './utils/misc';\r\n\r\n// currently chat supports only one channel\r\n// but socket is designed to handle many\r\n\r\nfunction pad(pad, str, padLeft) {\r\n    if (typeof str === 'undefined')\r\n        return pad;\r\n    if (padLeft) {\r\n        return (pad + str).slice(-pad.length);\r\n    } else {\r\n        return (str + pad).substring(0, pad.length);\r\n    }\r\n}\r\n\r\nconst colorRegEx = new RegExp(/\\[(#?[A-Z0-9]{1,8})*?\\]/gi);\r\n// https : / / host.com/img .png       ? q=321123\r\nconst imgRegEx = new RegExp(/http?s:\\/\\/.+?\\.(png|jpg|jpeg|gif)(\\?\\S+)?/i);\r\nconst goroxelsLinkRegEx = new RegExp(`^https?://${location.host}/.*`);\r\n\r\nclass Chat {\r\n    constructor() {\r\n        this.element = $('#chat');\r\n\r\n        this.logElems = {};\r\n\r\n        this.colorsEnabled = !JSON.parse(getOrDefault('disableColors', false));\r\n\r\n        this.muted = JSON.parse(getLS('muted')) || [];\r\n\r\n        this.channel = undefined;\r\n\r\n        this.initChatEvents();\r\n    }\r\n\r\n    loadChannelElements() {\r\n        [...$('#chatLog').children()].map(el => {\r\n            let channel = el.dataset.channel;\r\n            if (channel === 'local') {\r\n                channel = canvasName;\r\n            }\r\n            this.logElems[channel] = $(el);\r\n        })\r\n    }\r\n\r\n    // mobile version of hide/show\r\n    mobileShow() {\r\n        this.element.css('top', '0');\r\n    }\r\n\r\n    mobileHide() {\r\n        this.element.css('top', '-100vh');\r\n    }\r\n\r\n    setColors(state) {\r\n        this.colorsEnabled = state;\r\n\r\n        $('.chatColored').toggleClass('noColor', !state);\r\n    }\r\n\r\n    parseColors(str) {\r\n        // colors should be formatted like: [RED]test or [#FF0000]te[]st\r\n\r\n        let colorEntries = 0;\r\n\r\n        let regIter = str.matchAll(colorRegEx);\r\n        while (true) {\r\n            let {\r\n                value: entry,\r\n                done\r\n            } = regIter.next();\r\n            if (done) break;\r\n\r\n            let color = entry[1];\r\n\r\n            if (color) {\r\n                // test for \"#\" and mathing A-F a-f hex alphabet\r\n                if (color.startsWith('#') && !/[G-Zg-z]/.test(color)) {\r\n                    color = pad(color.slice(-1).repeat(6 + 1), color);\r\n                } else if (!cssColors[color]) continue;\r\n\r\n                str = str.replace(entry[0],\r\n                    `<div class=\"chatColored${this.colorsEnabled ? '' : ' noColor'}\" style=\"color:${color}\">`);\r\n                colorEntries++;\r\n            } else { // empty braces\r\n                if (colorEntries > 0) {\r\n                    str = str.replace(entry[0], '</div>');\r\n                    colorEntries--;\r\n                } else {\r\n                    // \"[\" and \"]\"\r\n                    str = str.replace(entry[0], '&#91;&#93;');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (colorEntries > 0) str += '</div>'.repeat(colorEntries);\r\n\r\n        return str\r\n    }\r\n    parseCoords(str) {\r\n        return str.replace(/\\((\\d{1,5}), ?(\\d{1,5})\\)/g,\r\n            `<a class=\"cordgo\" onclick=\"camera.centerOn($1, $2)\">$&</a>`)\r\n    }\r\n    parseImage(str) {\r\n        let matching = str.match(imgRegEx);\r\n\r\n        if (matching) {\r\n            let src = matching[0];\r\n            str = str.replace(src,\r\n                `<span class=\"imageLink\" onclick=\"globals.chat.toggleImage(this)\">${src}</span>`)\r\n        }\r\n\r\n        return str\r\n    }\r\n    toggleImage(target) {\r\n        const element = $(target);\r\n        const parent = element.parent();\r\n\r\n        const exists = !!$('img', parent).length;\r\n        if (exists) {\r\n            $('.imageLink', parent).css('cursor', 'zoom-in')\r\n            $('img', parent).remove();\r\n        } else {\r\n            $('.imageLink', parent).css('cursor', 'zoom-out');\r\n            const img = $(`<img src=\"${element.text()}\" class=\"chatImg\" onclick=\"globals.chat.toggleImage(this)\">`);\r\n            img.on('load', this.scroll.bind(this, this.channel));\r\n            parent.append(img);\r\n        }\r\n    }\r\n    parseGoroxelsLink(text) {\r\n        const firstArg = text.split(' ')[0];\r\n        if (!firstArg) return text;\r\n\r\n        const match = text.match(goroxelsLinkRegEx);\r\n        if (!match) return text;\r\n\r\n        return text.replace(match[0], `<a href=\"${match[0]}\">${match[0]}</a>`);\r\n    }\r\n\r\n    parseBB(str) {\r\n        // function does not checks for brackets order validity\r\n        let openedTags = [];\r\n\r\n        let regIter = str.matchAll(/\\[(\\/?[bi])\\]/gi);\r\n        while (true) {\r\n            let {\r\n                value: entry,\r\n                done\r\n            } = regIter.next();\r\n            if (done) break;\r\n\r\n            let tag = entry[1];\r\n            str = str.replace(entry[0],\r\n                `<${tag}>`);\r\n            if (!tag.startsWith('/'))\r\n                openedTags.push(tag);\r\n            else {\r\n                openedTags = openedTags.splice(openedTags.indexOf(tag.slice(1)));\r\n            }\r\n        }\r\n\r\n        while (openedTags.length) {\r\n            str += `</${openedTags.shift()}>`\r\n        }\r\n\r\n        return str\r\n    }\r\n\r\n    addMessage(message) {\r\n        $('.showChat').addClass('showChat-notify');\r\n        $('.chatNotif').addClass('active');\r\n\r\n        const channel = message.ch;\r\n\r\n        if (message.server)\r\n            return this.addServerMessage(message.msg, channel);\r\n\r\n        let text = htmlspecialchars(message.msg),\r\n            nick = htmlspecialchars(message.nick);\r\n\r\n        const realNick = nick;\r\n\r\n        if (nick === 'Goroh') {\r\n            nick = `<span style=\"text-shadow:0 0 3px\">[#0]${nick}</span>`\r\n        }\r\n\r\n        try {\r\n            text = this.parseColors(text);\r\n            text = this.parseBB(text);\r\n            text = this.parseCoords(text);\r\n            text = this.parseGoroxelsLink(text);\r\n            text = this.parseImage(text);\r\n\r\n            nick = this.parseColors(nick);\r\n        } catch (e) {\r\n            console.log(e);\r\n        }\r\n\r\n        const isMuted = ~this.muted.indexOf(realNick);\r\n\r\n        const msgEl = $(\r\n            `<div class=\"chatMessage\" ${isMuted ? 'style=\"display:none\"' : ''}>\r\n            <div class=\"messageNick\" data-nick=\"${realNick}\">${nick}:</div>\r\n            <div class=\"messageText\">${text}</div>\r\n        </div>`);\r\n\r\n        $('.messageNick', msgEl).on('click', function () {\r\n            const visibleNick = this.innerText.slice(0, -1);\r\n            chatInput[0].value += visibleNick + ', ';\r\n            chatInput.trigger('focus');\r\n        })\r\n\r\n        this.logElems[channel].append(msgEl);\r\n\r\n        this.afterAddingMessage(channel);\r\n    }\r\n\r\n    addLocalMessage(text, channel) {\r\n        text = this.parseColors(text);\r\n        text = this.parseBB(text);\r\n        text = this.parseCoords(text);\r\n        text = this.parseGoroxelsLink(text);\r\n        text = this.parseImage(text);\r\n\r\n        const msgEl = $(\r\n            `<div class=\"chatMessage\">\r\n                <div class=\"messageText\">${text}</div>\r\n            </div>`)\r\n\r\n        this.logElems[channel].append(msgEl);\r\n\r\n        this.afterAddingMessage(channel);\r\n    }\r\n\r\n\r\n\r\n    switchChannel(channel) {\r\n        if (this.channel === channel) {\r\n            return;\r\n        }\r\n\r\n        const channelAlias = channel;\r\n        if (channel === 'local') {\r\n            channel = canvasName;\r\n        }\r\n\r\n        for (let ch of Object.values(this.logElems)) {\r\n            ch.hide();\r\n        }\r\n        this.logElems[channel].show();\r\n\r\n        $(`#chatChannels>div`).removeClass('selected');\r\n        $(`#chatChannels>div[data-channel=\"${channelAlias}\"]`).addClass('selected');\r\n\r\n        this.scroll(channel, true);\r\n\r\n        this.channel = channel;\r\n    }\r\n\r\n    addServerMessage(text, channel) {\r\n        this.addLocalMessage(text, channel);\r\n    }\r\n\r\n    afterAddingMessage(channel) {\r\n        const el = this.logElems[channel];\r\n        if (el.children().length > game.chatLimit) {\r\n            el.children()[0].remove();\r\n        }\r\n        this.scroll(channel);\r\n    }\r\n\r\n    // handles messages to send\r\n    handleMessage(message) {\r\n        if (message.startsWith('/')) {\r\n            this.handleCommand(message);\r\n        } else {\r\n            if (!globals.socket.connected) {\r\n                chatInput.val(message);\r\n                return;\r\n            }\r\n            globals.socket.sendChatMessage(message, this.channel);\r\n        }\r\n    }\r\n\r\n    sendWhisper(target, message) {\r\n        globals.socket.sendChatWhisper(message, this.channel, target);\r\n    }\r\n\r\n    // handles chat commands\r\n    handleCommand(command) {\r\n        let args = command.split(' ');\r\n\r\n        const cmd = args[0];\r\n        args = args.slice(1);\r\n\r\n        switch (cmd) {\r\n            case '/mute': {\r\n                const nick = args.join(' ');\r\n                this.mute(nick);\r\n\r\n                break\r\n            }\r\n            case '/unmute': {\r\n                const nick = args.join(' ');\r\n                this.unmute(nick);\r\n\r\n                break\r\n            }\r\n            case '/w': {\r\n                if (args.length < 2) {\r\n                    return this.addLocalMessage('Usage: /w &lt;targetAccountId&gt; &lt;message&gt;');\r\n                }\r\n                const id = args[0];\r\n                const msg = args.slice(1).join(' ');\r\n\r\n                if (globals.socket.connected) {\r\n                    this.sendWhisper(id, msg);\r\n                    this.addLocalMessage(`${t_('chat.you')} -> id${id}: <i>${msg}</i>`, this.channel);\r\n                    chatInput.val(`/w ${id} `);\r\n                }\r\n\r\n                break\r\n            }\r\n            case '/help': {\r\n                const commands =\r\n                    `/mute ${t_('chat.muteDesc')}<br>` +\r\n                    `/unmute ${t_('chat.unmuteDesc')}<br>` +\r\n                    `/w ${t_('chat.wDesc')}`;\r\n\r\n                this.addLocalMessage(commands, this.channel);\r\n            }\r\n        }\r\n    }\r\n\r\n    mute(nick) {\r\n        const pref = '<b>mute:</b> ';\r\n\r\n        if (!nick.length || nick.length > 32) {\r\n            return this.addLocalMessage(pref + t_('Wrong nick length'))\r\n        }\r\n        if (~this.muted.indexOf(nick)) {\r\n            return this.addLocalMessage(pref + t_('Player is already muted'))\r\n        }\r\n\r\n        this.muted.push(nick);\r\n        setLS('muted', JSON.stringify(this.muted));\r\n\r\n        $('.messageNick').each((_, el) => {\r\n            if (el.dataset.nick === nick) {\r\n                el.parentElement.style.display = 'none';\r\n            }\r\n        })\r\n    }\r\n\r\n    unmute(nick) {\r\n        let pref = '<b>unmute:</b> ', index;\r\n\r\n        if (!nick.length || nick.length > 32) {\r\n            return this.addLocalMessage(pref + t_('Wrong nick length'))\r\n        }\r\n        if (!~(index = this.muted.indexOf(nick))) {\r\n            return this.addLocalMessage(pref + t_('Player is not muted'))\r\n        }\r\n\r\n        this.muted.splice(index, 1);\r\n        setLS('muted', JSON.stringify(this.muted));\r\n\r\n        $('.messageNick').each((_, el) => {\r\n            if (el.dataset.nick === nick) {\r\n                el.parentElement.style.display = 'block';\r\n            }\r\n        })\r\n    }\r\n\r\n    initChatEvents() {\r\n        chatInput.on('input', () => {\r\n            const value = chatInput.val();\r\n            if (imgRegEx.test(value) || goroxelsLinkRegEx.test(value)) {\r\n                chatInput.css('color', 'white');\r\n            } else {\r\n                chatInput.css('color', '');\r\n            }\r\n        })\r\n    }\r\n\r\n    // this function scrolls only if player scrolled chat log to the end\r\n    scroll(channel = 'global', force = false) {\r\n        const el$ = this.logElems[channel];\r\n        const el = el$.parent()[0];\r\n        const lastElemHeight = el$.children().slice(-1).innerHeight() || 0;\r\n        // 2 is message margin and 5 is just for fun\r\n        const scrolled = (el.scrollHeight - el.scrollTop - el.clientHeight - lastElemHeight) <= 2 + 5;\r\n        if (scrolled || force) {\r\n            el.scrollBy(0, 999);\r\n        }\r\n    }\r\n}\r\n\r\nconst chat = new Chat();\r\n\r\nexport function initChat() {\r\n    $(document).on('keydown', e => {\r\n        if(globals.lockInputs) return;\r\n        if (e.key !== 'Enter') return;\r\n\r\n        if ($('#chatInput').is(':focus') || globals.mobile) {\r\n            // send if focused\r\n            const message = chatInput.val();\r\n            if (!message.length)\r\n                return chatInput.trigger('blur');\r\n\r\n            chatInput.val('');\r\n\r\n            chat.handleMessage(message);\r\n        } else {\r\n            // or focus if not\r\n            $('#chatInput').trigger('focus');\r\n        }\r\n    });\r\n\r\n    $('#chatChannels>div').on('click', (e) => {\r\n        const ch = e.target.dataset.channel;\r\n        chat.switchChannel(ch);\r\n        setLS('chatChannel', ch);\r\n    });\r\n\r\n    resolveWhenConfigDownloaded().then(() => {\r\n        chat.loadChannelElements();\r\n        chat.switchChannel(getLS('chatChannel') || 'global');\r\n    })\r\n\r\n    initChatHeightWorkaround();\r\n}\r\n\r\n\r\n\r\nexport function toggleChat() {\r\n    $('.chatNotif').removeClass('active');\r\n\r\n    if (chatEl.css('display') === 'none') {\r\n        chatEl.show();\r\n        chatEl.css('left', '');\r\n\r\n        $('.chatNotif').hide();\r\n    } else {\r\n        chatEl.css('left', -chatEl.width() - 30);\r\n        setTimeout(() => chatEl.hide(), 500);\r\n\r\n        $('.chatNotif').show();\r\n    }\r\n}\r\n\r\nexport function initMobileChatToggle() {\r\n    $('.showChat').on('click', () => {\r\n        $('.showChat').removeClass('showChat-notify');\r\n        chat.mobileShow()\r\n    });\r\n    $('#hideChat').on('click', () => {\r\n        $('.showChat').removeClass('showChat-notify');\r\n        chat.mobileHide()\r\n    });\r\n}\r\n\r\nfunction initChatHeightWorkaround() {\r\n    // -webkit-fill-available does not work since\r\n    // the best way to define height that i know \r\n    // for the moment is through the script\r\n\r\n    function fixChatHeight() {\r\n        document.documentElement.style.setProperty('--gorox-chat-height', $(window).height() + 'px');\r\n    }\r\n\r\n    $(window).on('resize', fixChatHeight);\r\n    fixChatHeight();\r\n}\r\n\r\nexport function fixChatPosition() {\r\n    const paletteHeight = $('#palette').innerHeight();\r\n    $('#chat').css('bottom', paletteHeight + 4);\r\n}\r\n\r\nexport function toggleEmojis(state) {\r\n    state ? $('#emotions').show() : $('#emotions').hide();\r\n}\r\n\r\nexport function updateEmojis(list) {\r\n    const container = $('#emotions');\r\n    let html = '';\r\n\r\n    for (let el of list) {\r\n        html += `<div class=\"emotion\">${el}</div>`;\r\n    }\r\n\r\n    container.html(html);\r\n\r\n    $('div', container).on('click', e => {\r\n        $('#chatInput')[0].value += e.target.innerText;\r\n        $('#chatInput').trigger('focus');\r\n    })\r\n}\r\n\r\nexport default globals.chat = chat;","import Pattern from './Pattern';\nimport {\n    chunkSize,\n    bgrPalette,\n    game\n} from './config'\nimport protectedPatternUrl from '../img/protectedPattern.png';\nimport { getLS } from './utils/localStorage';\n\nexport default class Chunk {\n    constructor(x, y, buffer) {\n        this.x = x;\n        this.y = y;\n\n        this.width = chunkSize;\n        this.height = chunkSize;\n\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.canvas.height = chunkSize;\n\n        this.ctx = this.canvas.getContext('2d');\n\n        this.imgData = this.ctx.createImageData(chunkSize, chunkSize);\n        this.view = new Uint32Array(this.imgData.data.buffer);\n\n        // protected\n\n        // chunksized means the canvas with sizes of the chunk, filled with \"protected\" pattern\n        this.protectedPatternChunkSized = null;\n        this._protectedPattern = new Pattern(protectedPatternUrl);\n        this._protectedPattern.onload = () => {\n            this.needRender = true;\n            // pattern shift is an offset, to shift\n            // the texture for current chunk, because it might not\n            // be dividable by chunk size (pattern misjoint between chunks in result)\n            const patternShift = [\n                (this.x * this.width) % this._protectedPattern.canvas.width,\n                (this.y * this.height) % this._protectedPattern.canvas.height\n            ]\n\n            if(getLS('protectDebug') === '1'){\n                const canv = this.protectedPatternChunkSized = document.createElement('canvas');\n                canv.width = this.width; canv.height = this.height;\n                const canvCtx = canv.getContext('2d');\n                canvCtx.fillStyle = 'rgb(0,255,0)';\n                canvCtx.fillRect(0, 0, this.width, this.height);\n            }else{\n                this.protectedPatternChunkSized = this._protectedPattern.createFilledCanvas(this.width, this.height, patternShift[0], patternShift[1]);\n            }\n        }\n\n        this.pCanvas = document.createElement('canvas');\n        this.pCanvas.width = this.pCanvas.height = chunkSize;\n\n        this.pCtx = this.pCanvas.getContext('2d');\n        this.pImgData = this.pCtx.createImageData(chunkSize, chunkSize);\n        this.pView = new Uint32Array(this.pImgData.data.buffer);\n\n        this.needRender = true;\n\n        this.fromBuffer(buffer);\n    }\n\n    render() {\n        if (this.needRender) {\n            this.needRender = false;\n            this.ctx.putImageData(this.imgData, 0, 0);\n\n            if (game.showProtected) {\n                if(getLS('protectDebug') === '1'){\n                    this.ctx.globalAlpha = 1;\n                }else{\n                    this.ctx.globalAlpha = 0.7;\n                }\n\n                this.pCtx.putImageData(this.pImgData, 0, 0);\n                if(this.protectedPatternChunkSized !== null){\n                    this.pCtx.globalCompositeOperation = 'source-in';\n                    this.pCtx.drawImage(this.protectedPatternChunkSized, 0, 0);\n                    this.pCtx.globalCompositeOperation = 'source-over'; // back to default\n                }\n\n                this.ctx.drawImage(this.pCanvas, 0, 0);\n\n                this.ctx.globalAlpha = 1;\n            }\n        }\n    }\n\n    fromBuffer(buf) {\n        let col, isProtected;\n        for (let i = 0; i < buf.byteLength; i++) {\n            col = buf[i];\n            isProtected = col & 0x80;\n\n            isProtected && (this.pView[i] = 0xFFFF0000);\n            this.view[i] = bgrPalette[col & 0x7F];\n        }\n    }\n\n    get(x, y) {\n        return this.view[x + y * chunkSize]\n    }\n\n    set(x, y, c) {\n        const i = x + y * chunkSize\n\n        this.view[i] = c;\n\n        this.needRender = true;\n    }\n\n    setProtect(x, y, state) {\n        const i = x + y * chunkSize;\n        this.pView[i] = state ? 0xFFFF0000 : 0;\n\n        this.needRender = true;\n    }\n\n    getProtect(x, y) {\n        const i = x + y * chunkSize;\n        return !!this.pView[i];\n    }\n}","import globals from './globals';\r\nimport Chunk from './Chunk';\r\nimport {\r\n    bgrPalette,\r\n    argbToId,\r\n    boardWidth, boardHeight, chunkSize, canvasId\r\n} from './config';\r\nimport {\r\n    boardToChunk\r\n} from './utils/conversions'\r\nimport TempChunkPlaceholder from './TempChunkPlaceholder';\r\nimport { apiRequest } from './utils/api';\r\nimport { getLS, setLS } from './utils/localStorage';\r\nimport { isChunkVisible } from './utils/camera';\r\n\r\nconst CHUNK_LOADING_THREADS = 5;\r\nconst CHUNK_CACHE_NAME = 'chunks-cache-v1';\r\nconst cacheApiSupported = ('caches' in window);\r\n\r\nexport default class ChunkManager {\r\n    constructor() {\r\n        this.chunks = new Map();\r\n\r\n        this.loadingChunks = new Set();\r\n\r\n        this.checkQueue = [];\r\n        this._checkInterval = null;\r\n        this.checking = false;\r\n        this.chunkHashes = null;\r\n\r\n        // globals.socket.on('chunk', (cx, cy, cdata) => {\r\n        //     let key = this.getChunkKey(cx, cy);\r\n        //     if (this.loadingChunks.has(key)){\r\n        //         this.loadingChunks.delete(key);\r\n        //     }\r\n\r\n        //     let chunk = new Chunk(cx, cy, cdata);\r\n        //     this.chunks.set(key, chunk);\r\n\r\n        //     globals.renderer.needRender = true;\r\n        // })\r\n\r\n        globals.socket.on('place', (x, y, col) => {\r\n            this.setChunkPixel(x, y, col);\r\n\r\n            globals.renderer.needRender = true;\r\n        })\r\n\r\n        globals.socket.on('protect', (x, y, state) => {\r\n            this.setProtect(x, y, state);\r\n\r\n            globals.renderer.needRender = true;\r\n        });\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.loadSavedChunkHashes();\r\n        this.initCheckInterval();\r\n    }\r\n\r\n    loadSavedChunkHashes() {\r\n        this.chunkHashes = JSON.parse(getLS(`chunkHashes`, true)) ?? {};\r\n    }\r\n    saveChunkHashes() {\r\n        setLS(`chunkHashes`, JSON.stringify(this.chunkHashes), true);\r\n    }\r\n\r\n    initCheckInterval() {\r\n        this._checkInterval = setInterval(async () => {\r\n            if (!this.checkQueue.length || this.checking) return;\r\n            this.checking = true;\r\n\r\n            // console.log(this.checkQueue.size);\r\n\r\n            try {\r\n                // converting to array to remove checked chunks\r\n                const asArr = this.checkQueue//[...this.checkQueue];\r\n                await this.checkChunks(asArr.splice(0, 32).map(this.fromChunkKey));\r\n\r\n                // this.checkQueue = new Set(asArr);\r\n            } finally {\r\n                this.checking = false;\r\n            }\r\n        }, 1);\r\n    }\r\n\r\n    async checkChunks(chunkList) {\r\n        // some chunks may not have hash\r\n        let chunksListFinal = [];\r\n        let hashList = [];\r\n        for (let [cx, cy] of chunkList) {\r\n            if (!isChunkVisible(cx, cy)) continue;\r\n            if (this.loadingChunks.has(this.getChunkKey(cx, cy))) continue;\r\n\r\n            const hash = this.chunkHashes[`${cx},${cy}`];\r\n            if (typeof hash === 'string' && hash.length >= 16) {\r\n                // this is intentional: the array is flattened\r\n                chunksListFinal.push(cx, cy);\r\n                hashList.push(hash);\r\n            } else {\r\n                this.requestChunk(cx, cy);\r\n            }\r\n        }\r\n\r\n        if (!hashList.length) return;\r\n\r\n        const chunksFormatted = JSON.stringify(chunksListFinal);\r\n        const hashesFormatted = JSON.stringify(hashList);\r\n\r\n        const params = new URLSearchParams();\r\n        params.set('canvas', canvasId);\r\n        params.set('chunks', chunksFormatted);\r\n        params.set('hashes', hashesFormatted);\r\n\r\n        const resp = await apiRequest(`/chunks/check?${params.toString()}`);\r\n\r\n        const respData = await resp.json();\r\n        if (respData.errors) return;\r\n\r\n        if (!Array.isArray(respData)) {\r\n            throw new Error('Server returned unknown shit: ' + respData);\r\n        }\r\n\r\n        for (let i = 0; i < chunksListFinal.length; i += 2) {\r\n            const [cx, cy] = [chunksListFinal[i], chunksListFinal[i + 1]];\r\n\r\n            const isActual = respData[i / 2];\r\n            if (isActual) {\r\n                this.loadChunkFromCache(cx, cy);\r\n            } else {\r\n                delete this.chunkHashes[`${cx},${cy}`];\r\n                this.saveChunkHashes();\r\n\r\n                this.requestChunk(cx, cy);\r\n            }\r\n        }\r\n    }\r\n\r\n    clearChunks() {\r\n        this.chunks.clear();\r\n    }\r\n\r\n    getChunkKey(x, y) {\r\n        return x << 16 | y\r\n    }\r\n\r\n    fromChunkKey(key) {\r\n        return [\r\n            key >> 16,\r\n            key & 0xFFFF\r\n        ]\r\n    }\r\n\r\n    reloadChunks(chunksToReload) {\r\n        if (!chunksToReload) {\r\n            this.clearChunks();\r\n        } else {\r\n            for (const { x: cx, y: cy } of chunksToReload) {\r\n                this.chunks.delete(this.getChunkKey(cx, cy));\r\n            }\r\n        }\r\n    }\r\n\r\n    async requestChunk(x, y) {\r\n        let key = this.getChunkKey(x, y);\r\n\r\n        if (!this.loadingChunks.has(key) &&\r\n            this.loadingChunks.size < CHUNK_LOADING_THREADS) {\r\n\r\n            this.loadingChunks.add(key);\r\n\r\n            try {\r\n                const resp = await apiRequest(`/chunks/get?canvas=${canvasId}&x=${x}&y=${y}`, {\r\n                    credentials: 'omit'\r\n                });\r\n\r\n                const newHash = resp.headers.get('X-Compressed-Hash');\r\n                if (newHash && cacheApiSupported) {\r\n                    this.chunkHashes[`${x},${y}`] = newHash;\r\n                    this.saveChunkHashes();\r\n\r\n                    const cache = await caches.open(CHUNK_CACHE_NAME);\r\n                    await cache.put(`${canvasId}-${x}-${y}`, resp.clone());\r\n                }\r\n\r\n                // use pako only if chunk got from socket\r\n                // const cdataCompressed = await resp.arrayBuffer();\r\n                // const cdata = Pako.inflate(cdataCompressed);\r\n\r\n                await this.loadChunkFromResp(x, y, resp);\r\n            } finally {\r\n                if (this.loadingChunks.has(key)) {\r\n                    this.loadingChunks.delete(key);\r\n                }\r\n            }\r\n            // globals.socket.requestChunk(x, y);\r\n        }\r\n    }\r\n\r\n    async loadChunkFromCache(x, y) {\r\n        const chunkKey = this.getChunkKey(x, y);\r\n        if (this.loadingChunks.has(chunkKey)) return;\r\n\r\n        this.loadingChunks.add(chunkKey);\r\n\r\n        try {\r\n            const cache = await caches.open(CHUNK_CACHE_NAME);\r\n            const resp = await cache.match(`${canvasId}-${x}-${y}`);\r\n            if (!resp) {\r\n                console.log('cache no match');\r\n                delete this.chunkHashes[`${x},${y}`];\r\n                this.saveChunkHashes();\r\n\r\n                this.loadChunk(x, y);\r\n                return;\r\n            }\r\n\r\n            await this.loadChunkFromResp(x, y, resp, true);\r\n\r\n        } finally {\r\n            this.loadingChunks.delete(chunkKey);\r\n        }\r\n    }\r\n\r\n    async loadChunkFromResp(x, y, resp, cached = false) {\r\n        const cdata = await resp.arrayBuffer();\r\n\r\n        let chunk = new Chunk(x, y, new Uint8Array(cdata));\r\n        this.chunks.set(this.getChunkKey(x, y), chunk);\r\n\r\n        if (!cached) {\r\n            chunk.render(); // workaround because TempChunkPlaceholder getting zeroes until chunk is rendered once\r\n            new TempChunkPlaceholder(x, y).save(chunk.canvas);\r\n        }\r\n\r\n        globals.renderer.needRender = true;\r\n    }\r\n\r\n    loadChunk(x, y) {\r\n        if (!cacheApiSupported) {\r\n            // old method (threaded chunk queue)\r\n            this.requestChunk(x, y);\r\n            return;\r\n        }\r\n\r\n        // new method (bulk chunk check for updates)\r\n        const chunkKey = this.getChunkKey(x, y);\r\n        if (this.checkQueue.includes(chunkKey) || this.checking || this.loadingChunks.has(chunkKey)) {\r\n            return;\r\n        }\r\n\r\n        this.checkQueue.push(this.getChunkKey(x, y));\r\n    }\r\n\r\n    clearLoadingChunks() {\r\n        this.loadingChunks = new Set;\r\n    }\r\n\r\n    hasChunk(x, y) {\r\n        let key = this.getChunkKey(x, y);\r\n\r\n        return this.chunks.has(key);\r\n    }\r\n\r\n    getChunk(x, y) {\r\n        let key = this.getChunkKey(x, y);\r\n\r\n        if (!this.chunks.has(key)) {\r\n            return 0\r\n        }\r\n        return this.chunks.get(key)\r\n    }\r\n\r\n    getChunkPixel(x, y) {\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n        let chunk = this.getChunk(cx, cy);\r\n\r\n        if (!chunk || x < 0 || y < 0) return -1\r\n\r\n        let argb = chunk.get(offx, offy);\r\n\r\n        return argbToId[argb]\r\n    }\r\n\r\n    setChunkPixel(x, y, col) {\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n\r\n        let key = this.getChunkKey(cx, cy);\r\n        if (this.chunks.has(key)) {\r\n            this.chunks.get(key).set(offx, offy, bgrPalette[col])\r\n        }\r\n    }\r\n\r\n    setProtect(x, y, state) {\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n\r\n        let key = this.getChunkKey(cx, cy);\r\n        if (this.chunks.has(key)) {\r\n            this.chunks.get(key).setProtect(offx, offy, state)\r\n        }\r\n    }\r\n\r\n    getProtect(x, y) {\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n        let chunk = this.getChunk(cx, cy);\r\n        if (!chunk) return -1\r\n\r\n        return chunk.getProtect(offx, offy);\r\n    }\r\n\r\n    // for the screenshot function\r\n    dumpAll() {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = boardWidth;\r\n        canvas.height = boardHeight;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        this.chunks.forEach(chunk => {\r\n            if (!chunk.canvas) return;\r\n\r\n            const offX = chunk.x * chunkSize,\r\n                offY = chunk.y * chunkSize;\r\n\r\n            ctx.drawImage(chunk.canvas, offX, offY)\r\n        })\r\n        return canvas\r\n    }\r\n}","import EventEmitter from 'events';\r\nimport { translate as t } from './translate';\r\n\r\nexport default class MiniWindow extends EventEmitter{\r\n    // 0=0 1=ok, 2=ok+cancel\r\n    constructor(title='', closeButtons=1){\r\n        super();\r\n\r\n        this.title = title;\r\n\r\n        this._closeButtons = closeButtons;\r\n\r\n        this.element = null;\r\n        this.bodyElement = null;\r\n\r\n        this.closed = false;\r\n\r\n        this._create();\r\n    }\r\n\r\n    _create(){\r\n        const html = $(`\r\n        <div class=\"miniWindow\">\r\n            <div class=\"miniWindowTitle\">\r\n                ${this.title}\r\n            </div>\r\n            <div class=\"miniWindowBody\">\r\n            </div>\r\n            <div class=\"miniWindowButtons\">\r\n            </div>\r\n        </div>\r\n        `);\r\n\r\n        const buttons = [];\r\n        if(this._closeButtons >= 1){\r\n            const okButton = $(`<button>${t('OK')}</button>`);\r\n            okButton.on('click', this.buttonHandler.bind(this, 'ok'));\r\n            buttons.push(okButton);\r\n        }\r\n        if(this._closeButtons >= 2){\r\n            const cancelButton = $(`<button>${t('Cancel')}</button>`);\r\n            cancelButton.on('click', this.buttonHandler.bind(this, 'cancel'));\r\n            buttons.push(cancelButton);\r\n        }\r\n        \r\n        buttons.forEach(b => $('.miniWindowButtons', html).append(b));\r\n\r\n        this.element = html;\r\n        this.bodyElement = $('.miniWindowBody', html);\r\n    }\r\n\r\n    buttonHandler(buttonName){\r\n        const event = {\r\n            _cancelledClose: false,\r\n            cancelClose: function(){ this._cancelledClose = true }\r\n        }\r\n\r\n        switch(buttonName){\r\n            case 'ok':\r\n                this.emit('okClicked', event);\r\n                break;\r\n            case 'cancel':\r\n                this.emit('cancelClicked', event);\r\n        }\r\n\r\n        if(!event._cancelledClose){\r\n            this.close();\r\n        }\r\n    }\r\n\r\n      center() {\r\n        if (!this.element || this.closed) {\r\n            return;\r\n        }\r\n\r\n        const $window = $(window);\r\n        const windowWidth = $window.width();\r\n        const windowHeight = $window.height();\r\n        \r\n        const elementWidth = this.element.outerWidth();\r\n        const elementHeight = this.element.outerHeight();\r\n\r\n        const left = Math.max(0, (windowWidth - elementWidth) / 2);\r\n        const top = Math.max(0, (windowHeight - elementHeight) / 2);\r\n\r\n        this.element.css({\r\n            position: 'fixed',\r\n            left: left + 'px',\r\n            top: top + 'px',\r\n            transform: 'none'\r\n        });\r\n    }\r\n\r\n    close(){\r\n        this.removeAllListeners();\r\n        this.element.remove();\r\n        this.closed = true;\r\n    }\r\n}\r\n\r\nexport class SelectMiniWindow extends MiniWindow {\r\n    constructor(selects, callback, title){\r\n        if(!selects.length) throw new Error('no selects, no way to close the window!');\r\n\r\n        super(title, 0);\r\n\r\n        this.selects = selects;\r\n        this.callback = callback;\r\n        this._sel_create();\r\n    }\r\n\r\n    _sel_create(){\r\n        for(const select of this.selects){\r\n            const selectEl = $(`<button>${select.text}</button>`);\r\n            selectEl.one('click', () => this.onChosen(select.id));\r\n\r\n            this.bodyElement.append(selectEl);\r\n        }\r\n    }\r\n\r\n    onChosen(id){\r\n        this.close();\r\n\r\n        this.callback(id);\r\n    }\r\n}","export default class Pattern{\r\n    constructor(url){\r\n        this.url = url;\r\n        this.loaded = false;\r\n\r\n        this.canvas = null\r\n\r\n        this._load()\r\n    }\r\n\r\n    _load(){\r\n        const canvas = document.createElement('canvas');\r\n        \r\n        const img = new Image();\r\n        img.src = this.url;\r\n\r\n        img.onload = () => {\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n\r\n            canvas.getContext('2d').drawImage(img, 0, 0);\r\n\r\n            this.canvas = canvas;\r\n\r\n            this.loaded = true;\r\n            this.onload();\r\n        }\r\n    }\r\n\r\n    createFilledCanvas(width, height, offsetX, offsetY){\r\n        const ctx = this.canvas.getContext('2d');\r\n        const pattern = ctx.createPattern(this.canvas, 'repeat');\r\n\r\n        const filledCanvas = document.createElement('canvas');\r\n        filledCanvas.width = width;\r\n        filledCanvas.height = height;\r\n\r\n        const filledCtx = filledCanvas.getContext('2d');\r\n        \r\n        filledCtx.fillStyle = pattern;\r\n        \r\n        // this \"save restore\" shit is copied from stackoverflow\r\n        // it's needed to actually shift the pattern\r\n        filledCtx.save();\r\n        filledCtx.translate(offsetX, offsetY);\r\n        filledCtx.fillRect(-offsetX, -offsetY, width, height);\r\n        filledCtx.restore();\r\n\r\n        return filledCanvas;\r\n    }\r\n\r\n    onload(){}\r\n}","import ChunkPlaceholder from '../img/chunkPlaceholder.png';\r\nimport camera from './camera';\r\nimport { chunkSize, hexPalette } from './config';\r\nimport globals from './globals';\r\nimport Pattern from './Pattern';\r\nimport { getVisibleChunks } from './utils/camera';\r\nimport {\r\n    halfMap,\r\n    insanelyLongMobileBrowserCheck\r\n} from './utils/misc';\r\nimport template from './template';\r\nimport shapes from './utils/shapes';\r\nimport player from './player';\r\nimport TempChunkPlaceholder from './TempChunkPlaceholder';\r\n\r\nconst isMobile = insanelyLongMobileBrowserCheck();\r\n\r\n\r\nexport default class Renderer {\r\n    /**\r\n     * \r\n     * @param {CanvasRenderingContext2D} ctx \r\n     */\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n        this.canvas = this.ctx.canvas;\r\n\r\n        this.chunkPlaceholderPattern = new Pattern(ChunkPlaceholder);\r\n        this.chunkPlaceholderPattern.onload = () => {\r\n            this.needRender = true;\r\n        }\r\n        this.chunkPreviews = {};\r\n\r\n        this.needRender = true;\r\n\r\n        this.preRendered = {\r\n            brush: {\r\n                canvas: undefined,\r\n                ctx: undefined,\r\n                imageData: undefined,\r\n\r\n                circle: undefined,\r\n            }\r\n        }\r\n\r\n        this.preRender();\r\n    }\r\n\r\n    preRender(){\r\n        this.preRenderBrush();\r\n    }\r\n\r\n    preRenderBrush(){\r\n        // TODO make it render only before brush used\r\n        // because it renders on every zoom\r\n        const size = player.brushSize,\r\n            zoom = camera.zoom;\r\n        \r\n        if(zoom < 1) return\r\n\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvas.height = zoom*(size+1);\r\n        const ctx = canvas.getContext('2d');\r\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\r\n\r\n        const r = size/2;\r\n\r\n        const circle = shapes.filledCircle(0, 0, r);\r\n        let circleMatrix = [];\r\n        for(let y = 0; y < size+1; y++){\r\n            circleMatrix.push((new Array(size+1)).fill(0))\r\n        }\r\n        \r\n        circle.forEach(([x, y]) => {\r\n            circleMatrix[x+r][y+r] = 1;\r\n        })\r\n        \r\n        ctx.beginPath();\r\n        ctx.lineWidth = zoom / 4;\r\n        ctx.strokeStyle = hexPalette[player.color];\r\n        ctx.lineCap = 'square';\r\n\r\n        ctx.fillStyle = 'blue';\r\n\r\n        for(let x = 0; x < size; x++){\r\n            for(let y = 0; y < size; y++){\r\n                if(isBound(x, y)) continue;\r\n\r\n                let upper = isBound(x, y-1),\r\n                    left = isBound(x - 1, y),\r\n                    right = isBound(x + 1, y),\r\n                    bottom = isBound(x, y + 1);\r\n\r\n                if(upper){\r\n                    ctx.moveTo(x*zoom, y*zoom);\r\n                    ctx.lineTo((x+1)*zoom, y*zoom);\r\n                }\r\n                if(left){\r\n                    ctx.moveTo(x*zoom, y*zoom);\r\n                    ctx.lineTo(x*zoom, (y+1)*zoom);\r\n                }\r\n                if(right){\r\n                    ctx.moveTo((x+1)*zoom, y*zoom);\r\n                    ctx.lineTo((x+1)*zoom, (y+1)*zoom);\r\n                }\r\n                if(bottom){\r\n                    ctx.moveTo((x+1)*zoom, (y+1)*zoom);\r\n                    ctx.lineTo(x*zoom, (y+1)*zoom);\r\n                }\r\n            }\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n\r\n        function isBound(x, y){\r\n            // check is pixel opaque/out of array\r\n\r\n            if(x < 0 || x >= size || y < 0 || y >= size) return true;\r\n\r\n            return !circleMatrix[x][y];\r\n        }\r\n\r\n        this.preRendered.brush.canvas = canvas;\r\n        this.preRendered.brush.ctx = canvas;\r\n        this.preRendered.brush.imageData = canvas;\r\n        this.preRendered.brush.circle = circle;\r\n    }\r\n\r\n    requestRender(){\r\n        if(this.needRender){\r\n            this.needRender = false;\r\n\r\n            this.render()\r\n        }\r\n\r\n        globals.fxRenderer.render();\r\n    }\r\n\r\n    correctSmoothing(){\r\n        if(isMobile) return;\r\n\r\n        if (camera.zoom < 1) {\r\n            this.ctx.imageSmoothingEnabled = true;\r\n            this.ctx.canvas.style.imageRendering = 'auto'\r\n        } else {\r\n            this.ctx.imageSmoothingEnabled = false;\r\n            this.ctx.canvas.style.imageRendering = 'pixelated'\r\n        }\r\n    }\r\n\r\n    render() {\r\n        // smooth when zoom < 1, pixelated otherwise\r\n        this.correctSmoothing();\r\n\r\n        let visibleChunks = getVisibleChunks();\r\n\r\n        // clear veiwport\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        let camX = camera.x + halfMap[0] - ((this.canvas.width >> 1) / camera.zoom);\r\n        let camY = camera.y + halfMap[1] - ((this.canvas.height >> 1) / camera.zoom);\r\n\r\n        let zoom = camera.zoom;\r\n\r\n        if(zoom === 1){\r\n            // for Firefox, to render normally at least on zoom 1\r\n            camX = Math.floor(camX)\r\n            camY = Math.floor(camY)\r\n        }\r\n\r\n        this.ctx.save();\r\n        this.ctx.translate(Math.floor(-camX*zoom), Math.floor(-camY*zoom));\r\n        this.ctx.scale(zoom, zoom);\r\n\r\n        visibleChunks.forEach(chunkCord => {\r\n            let [cx, cy] = chunkCord;\r\n\r\n            let offX = cx * chunkSize;\r\n            let offY = cy * chunkSize;\r\n\r\n\r\n            if (!globals.chunkManager.hasChunk(cx, cy)){\r\n                globals.chunkManager.loadChunk(cx, cy);\r\n\r\n                // search for chunk preview placeholder\r\n                let chunkPreview = this.chunkPreviews[`${cx}-${cy}`];\r\n                if(!chunkPreview){\r\n                    // create one if not found (one-time op)\r\n                    chunkPreview = this.chunkPreviews[`${cx}-${cy}`] = {\r\n                        loaded: false,\r\n                        data: null\r\n                    };\r\n                    new TempChunkPlaceholder(cx, cy).load().then(imgData => {\r\n                        chunkPreview.data = imgData;\r\n                        chunkPreview.loaded = true;\r\n                        this.needRender = true;\r\n                    });\r\n                }else if (chunkPreview.loaded && chunkPreview.data !== null){\r\n                    // or, render it if it's loaded and found in db\r\n                    this.ctx.drawImage(chunkPreview.data, offX, offY, chunkSize, chunkSize);\r\n\r\n                    // also render default placeholder over it, to clarify we are dealing with preview\r\n                    if(this.chunkPlaceholderPattern.loaded){\r\n                        this.ctx.globalAlpha = 0.5;\r\n                        this.ctx.drawImage(this.chunkPlaceholderPattern.canvas, offX, offY, chunkSize, chunkSize);\r\n                        this.ctx.globalAlpha = 1;\r\n                    }\r\n                }else {\r\n\r\n                    // fallback to default placeholder if available\r\n                    if(this.chunkPlaceholderPattern.loaded)\r\n                        this.ctx.drawImage(this.chunkPlaceholderPattern.canvas, offX, offY, chunkSize, chunkSize);\r\n                }\r\n\r\n                return\r\n            }\r\n            \r\n            const chunk = globals.chunkManager.getChunk(cx, cy);\r\n\r\n            chunk.render();\r\n            this.ctx.drawImage(chunk.ctx.canvas, offX, offY);\r\n        });\r\n\r\n        this.ctx.restore();\r\n    }\r\n}\r\n\r\n","import EventEmitter from 'events';\r\nimport pako from 'pako'\r\n\r\nimport {\r\n    OPCODES,\r\n    STRING_OPCODES\r\n} from './protocol';\r\nimport {\r\n    canvasId,\r\n    canvasName,\r\n    palette\r\n} from './config'\r\nimport globals from './globals'\r\nimport User from './user';\r\nimport chat from './Chat';\r\nimport { captchaModal } from './windows';\r\nimport Window, { Modal } from './Window';\r\nimport player, { updatePlaced } from './player';\r\nimport { translate as t } from './translate';\r\nimport { htmlspecialchars } from './utils/misc';\r\n\r\nexport default class Socket extends EventEmitter {\r\n    constructor(port) {\r\n        super();\r\n\r\n        const scheme = location.protocol.startsWith('https') ? 'wss' : 'ws';\r\n        const host = location.hostname || 'localhost';\r\n        this.url = `${scheme}://${host}:${port}`;\r\n\r\n        this.pendingPixels = {};\r\n\r\n        this.connectedOnce = false;\r\n\r\n        this.reconnectFactor = 1;\r\n\r\n        this.connect();\r\n    }\r\n\r\n    get connected() {\r\n        return this.socket && this.socket.readyState === WebSocket.OPEN\r\n    }\r\n\r\n    connect() {\r\n        this.socket = new WebSocket(this.url);\r\n        this.socket.binaryType = 'arraybuffer';\r\n\r\n        this.socket.onopen = () => {\r\n            this.sendChatSubscribe('global', this.connectedOnce);\r\n            this.sendChatSubscribe(canvasName, this.connectedOnce);\r\n            this.sendCanvas(canvasId);\r\n\r\n            this.emit('opened');\r\n            console.log('Socket has been connected');\r\n\r\n            if (!this.connectedOnce) this.connectedOnce = true;\r\n        }\r\n\r\n        this.socket.onmessage = this.onmessage.bind(this);\r\n\r\n        this.socket.onclose = () => {\r\n            this.emit('closed');\r\n            Object.values(globals.users).forEach(u => u.close(u.id));\r\n            globals.users = {};\r\n\r\n            globals.chunkManager.clearLoadingChunks();\r\n\r\n            const reconnectDelay = Math.min(this.reconnectFactor * 1000 - Math.random() * 1000, 60_000);\r\n            setTimeout(() => {\r\n                console.log('reconnect');\r\n                this.reconnect();\r\n                this.reconnectFactor *= 1.5;\r\n            }, reconnectDelay);\r\n        }\r\n    }\r\n\r\n    close() {\r\n        this.socket.close();\r\n    }\r\n\r\n    reconnect() {\r\n        this.socket.onmessage = null;\r\n        this.socket.onopen = null;\r\n        this.socket.onclose = null;\r\n\r\n        this.connect();\r\n    }\r\n\r\n    onmessage({\r\n        data: message\r\n    }) {\r\n        if (typeof message === 'string') {\r\n            this.onStringMessage(message);\r\n        } else {\r\n            // must be ping\r\n            if (!message.byteLength) return;\r\n\r\n            this.onBinaryMessage(message);\r\n        }\r\n    }\r\n\r\n    onStringMessage(msg) {\r\n        let decoded;\r\n        try {\r\n            decoded = JSON.parse(msg);\r\n        } catch (e) {\r\n            console.log('onStringMessage message decoding error: ' + e, 'message: ' + msg);\r\n            return\r\n        }\r\n\r\n        switch (decoded.c) {\r\n            case STRING_OPCODES.userJoin: {\r\n                const {\r\n                    nick: name,\r\n                    userId,\r\n                    id,\r\n                    registered,\r\n                    role\r\n                } = decoded;\r\n\r\n                let sameUser;\r\n                if (name) {\r\n                    sameUser = Object.values(globals.users).find(u => u.name === name);\r\n                }\r\n\r\n                if (sameUser) {\r\n                    globals.users[id] = sameUser;\r\n                    sameUser.newConnection(id);\r\n                } else {\r\n                    const user = globals.users[id] = new User(name, id, userId, registered, role);\r\n                    user.loadBadges()\r\n                        .then(user.updateBadges.bind(user))\r\n                        .catch(e => console.error('failed to load badges', e));\r\n                }\r\n\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.userLeave: {\r\n                const id = decoded.id;\r\n\r\n                if (globals.users[id]) globals.users[id].close(id);\r\n\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.error: {\r\n                decoded.errors.forEach(error => {\r\n                    if (error === 'error.captcha') {\r\n                        if (!Window.Exists('Captcha'))\r\n                            captchaModal();\r\n                    }\r\n                    let msg;\r\n                    if (typeof error === 'object') {\r\n                        msg = t('socketErr.' + error.msg) + error.data ?? '';\r\n                    } else {\r\n                        msg = t('socketErr.' + error);\r\n                    }\r\n                    toastr.error(msg, t('Error from the Socket:'), {\r\n                        preventDuplicates: true,\r\n                        timeOut: 30000,\r\n                    });\r\n                });\r\n\r\n                break;\r\n            }\r\n\r\n            case STRING_OPCODES.chatMessage: {\r\n                chat.addMessage(decoded)\r\n\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.alert: {\r\n                // todo  \r\n                if (decoded.type === 0) {\r\n                    toastr.info(decoded.msg, 'ALERT', {\r\n                        timeOut: 1000 * 60 * 5,\r\n                        extendedTimeOut: 1000 * 60 * 5\r\n                    });\r\n                } else {\r\n                    const safeMsg = htmlspecialchars(decoded.msg);\r\n                    const m = new Modal;\r\n                    m.init();\r\n                    const mBody = $(\r\n                        `<div style=\"margin:0;padding:5px;text-align:center;\">\r\n                            <h1>ADMIN:</h1>\r\n                            <p>${safeMsg}</p>\r\n                            <button style=\"padding: 8px;\">OK</button>\r\n                        </div>`)\r\n                    m.contEl.appendChild(mBody[0]);\r\n\r\n                    $('button', mBody).on('click', () => {\r\n                        m.close();\r\n                    });\r\n                }\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.me: {\r\n                player.id = decoded.id;\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.reload: {\r\n                location.reload();\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.reloadChunks: {\r\n                const toReload = decoded.chunks;\r\n                globals.chunkManager.reloadChunks(toReload);\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    onBinaryMessage(msg) {\r\n        const dv = new DataView(msg);\r\n\r\n        switch (dv.getUint8(0)) {\r\n            case OPCODES.captcha: {\r\n                captchaModal();\r\n                break\r\n            }\r\n            case OPCODES.chunk: {\r\n                const cx = dv.getUint8(1);\r\n                const cy = dv.getUint8(2);\r\n\r\n                const chunkData = pako.inflate(dv.buffer.slice(3));\r\n\r\n                this.emit('chunk', cx, cy, chunkData);\r\n\r\n                break\r\n            }\r\n\r\n            case OPCODES.place: {\r\n                const x = dv.getUint16(1);\r\n                const y = dv.getUint16(3);\r\n                const col = dv.getUint8(5);\r\n\r\n                const id = dv.getUint32(5);\r\n\r\n                this.onIncomingPixel([x, y, col], id);\r\n                break\r\n            }\r\n\r\n            case OPCODES.online: {\r\n                const count = dv.getUint16(1);\r\n\r\n                this.emit('online', count);\r\n                break\r\n            }\r\n\r\n            case OPCODES.pixels: {\r\n                const isProtect = !!dv.getUint8(1),\r\n                    uid = dv.getUint32(2, false);\r\n                let x, y, col;\r\n                for (let i = 6; i < dv.byteLength; i += 5) {\r\n                    x = dv.getUint16(i);\r\n                    y = dv.getUint16(i + 2);\r\n                    col = dv.getUint8(i + 4);\r\n\r\n                    if (col > palette.length) continue;\r\n\r\n                    if (isProtect) {\r\n                        this.emit('protect', x, y, col);\r\n                    } else {\r\n                        this.emit('place', x, y, col, uid);\r\n                    }\r\n                }\r\n\r\n                const user = globals.users[uid];\r\n                if (user) user.updateCoords(col, x, y);\r\n\r\n                break\r\n            }\r\n\r\n            case OPCODES.ping: {\r\n                this.reconnectFactor = 1;\r\n\r\n                this.socket.send(new Uint8Array([OPCODES.ping]));\r\n                break\r\n            }\r\n\r\n            case OPCODES.placeBatch: {\r\n                const PIXEL_LENGTH = 9;\r\n\r\n                const totalPixels = (dv.byteLength - 1) / PIXEL_LENGTH;\r\n                if (totalPixels % 1 !== 0) {\r\n                    console.warn('TotalPixels length is not integer');\r\n                }\r\n\r\n                for (let off = 1; off < dv.byteLength; off += PIXEL_LENGTH) {\r\n                    const x = dv.getUint16(off);\r\n                    const y = dv.getUint16(off + 2);\r\n                    const c = dv.getUint8(off + 4);\r\n                    const placerId = dv.getUint32(off + 5);\r\n\r\n                    if (c > palette.length) continue;\r\n\r\n                    this.onIncomingPixel([x, y, c], placerId);\r\n                }\r\n                break\r\n            }\r\n\r\n            case OPCODES.updateRadio: {\r\n                const type = dv.getUint8(1);\r\n                this.emit('radio', type);\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    onIncomingPixel([x, y, col], id) {\r\n        const user = globals.users[id];\r\n        if (user) user.updateCoords(col, x, y);\r\n\r\n        const key = x + ',' + y;\r\n        let timeout = this.pendingPixels[key];\r\n        if (timeout) {\r\n            clearTimeout(timeout);\r\n            delete this.pendingPixels[key];\r\n        }\r\n\r\n        this.emit('place', x, y, col, id);\r\n\r\n        // does not work, id is not player id\r\n        if (id === player.id)\r\n            updatePlaced(player.placedCount++);\r\n    }\r\n\r\n    requestChunk(x, y) {\r\n        let dv = new DataView(new ArrayBuffer(1 + 1 + 1));\r\n        dv.setUint8(0, OPCODES.chunk);\r\n        dv.setUint8(1, x);\r\n        dv.setUint8(2, y);\r\n\r\n        this.socket.send(dv.buffer)\r\n    }\r\n\r\n    sendPixel(x, y, c) {\r\n        let dv = new DataView(new ArrayBuffer(1 + 5))\r\n\r\n        dv.setUint8(0, OPCODES.place);\r\n        dv.setUint16(1, x);\r\n        dv.setUint16(3, y);\r\n        dv.setUint8(5, c);\r\n\r\n        this.socket.send(dv.buffer);\r\n    }\r\n\r\n    sendPixels(pixels, isProtect = false) {\r\n        let dv = new DataView(new ArrayBuffer(6 + pixels.length * 5))\r\n\r\n        dv.setUint8(0, OPCODES.pixels);\r\n        dv.setUint8(1, isProtect ? 1 : 0); // isProtect\r\n        for (let i = 0; i < pixels.length; i++) {\r\n            let offset = i * 5 + 6;\r\n            const [x, y, col] = pixels[i];\r\n\r\n            dv.setUint16(offset, x);\r\n            dv.setUint16(offset + 2, y);\r\n            dv.setUint8(offset + 4, col);\r\n        }\r\n\r\n        this.socket.send(dv.buffer)\r\n    }\r\n\r\n    sendCanvas(id) {\r\n        const dv = new DataView(new ArrayBuffer(2));\r\n        dv.setUint8(0, OPCODES.canvas);\r\n        dv.setUint8(1, id);\r\n\r\n        this.socket.send(dv.buffer);\r\n    }\r\n\r\n    sendChatSubscribe(channel, isReconnect) {\r\n        const packet = {\r\n            c: STRING_OPCODES.subscribeChat,\r\n            ch: channel,\r\n            reconnect: isReconnect\r\n        }\r\n\r\n        this.socket.send(JSON.stringify(packet));\r\n    }\r\n\r\n    sendChatMessage(text, channel, whisper = false) {\r\n        const packet = {\r\n            c: STRING_OPCODES.chatMessage,\r\n            msg: text,\r\n            ch: channel\r\n        }\r\n\r\n        if (whisper) packet.whisper = whisper;\r\n\r\n        this.socket.send(JSON.stringify(packet));\r\n    }\r\n\r\n    sendChatWhisper(text, channel, whisperId) {\r\n        return this.sendChatMessage(text, channel, whisperId);\r\n    }\r\n\r\n    sendAlert(to, text, isModal = false) {\r\n        const packet = {\r\n            c: STRING_OPCODES.alert,\r\n            to,\r\n            msg: text,\r\n            type: isModal ? 1 : 0\r\n        }\r\n\r\n        this.socket.send(JSON.stringify(packet));\r\n    }\r\n}","// this class is for loading/getting saved chunk placeholder,\r\n// based on the previous loaded chunk image\r\n\r\nimport { canvasId, chunkSize } from './config.js';\r\nimport * as idxDb from './indexedDb.js'\r\nimport { resizeCanvas } from './utils/misc';\r\n\r\nexport default class TempChunkPlaceholder {\r\n    constructor(chunkX, chunkY) {\r\n        this.x = chunkX;\r\n        this.y = chunkY;\r\n    }\r\n\r\n    // load from localStorage\r\n    async load() {\r\n        return new Promise((res, rej) => {\r\n            const dbKey = `${canvasId}-${this.x}-${this.y}`;\r\n            idxDb.addInitCallback(async () => {\r\n                try {\r\n                    const chunkData = await this._loadFromDb(dbKey);\r\n                    const chunkCanvas = this._fromData(chunkData);\r\n\r\n                    res(chunkCanvas);\r\n                } catch (error) {\r\n                    rej(error);\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    async _loadFromDb(dbKey) {\r\n        return new Promise((res, rej) => {\r\n            let transaction = idxDb.database.transaction(\"chunkPlaceholders\", \"readonly\");\r\n\r\n            let request = transaction.objectStore(\"chunkPlaceholders\").get(dbKey);\r\n    \r\n            request.onsuccess = function () {\r\n                const chunk = request.result;\r\n\r\n                if(chunk === undefined) return res(null);\r\n                return res(chunk);\r\n            };\r\n    \r\n            request.onerror = function (event) {\r\n                rej(request.error);\r\n            };\r\n    \r\n            transaction.onabort = function () {\r\n                rej(request.error);\r\n            };\r\n        })\r\n    }\r\n\r\n    _fromData(savedChunk){\r\n        const canvas = document.createElement('canvas');\r\n\r\n        if(savedChunk){\r\n            canvas.width = savedChunk.width;\r\n            canvas.height = savedChunk.height;\r\n    \r\n            const ctx = canvas.getContext('2d');\r\n            \r\n            const imageData = ctx.createImageData(canvas.width, canvas.height);\r\n            imageData.data.set(savedChunk.data);\r\n    \r\n            ctx.putImageData(imageData, 0, 0);\r\n        }\r\n\r\n        return resizeCanvas(canvas, chunkSize, chunkSize);\r\n    }\r\n\r\n    async save(chunkCanvas){\r\n        return new Promise((res, rej) => {\r\n            const dbKey = `${canvasId}-${this.x}-${this.y}`;\r\n            idxDb.addInitCallback(async () => {\r\n                try {\r\n                    await this._saveToDb(dbKey, chunkCanvas);\r\n\r\n                    res();\r\n                } catch (error) {\r\n                    rej(error);\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    async _saveToDb(dbKey, chunkCanvas){\r\n        return new Promise((res, rej) => {\r\n            // 50x50 is hardcoded size for all previews\r\n            const resizedChunkCanvas = resizeCanvas(chunkCanvas, 50, 50);\r\n            const resizedImgData = resizedChunkCanvas.getContext('2d').getImageData(0, 0, 50, 50);\r\n\r\n            let transaction = idxDb.database.transaction(\"chunkPlaceholders\", \"readwrite\");\r\n\r\n            let request = transaction.objectStore(\"chunkPlaceholders\").put({\r\n                'chunk_key': dbKey,\r\n\r\n                width: resizedImgData.width,\r\n                height: resizedImgData.height,\r\n                data: resizedImgData.data,\r\n            });\r\n    \r\n            request.onsuccess = function () {\r\n                res();\r\n            };\r\n    \r\n            request.onerror = function (event) {\r\n                rej(request.error);\r\n            };\r\n    \r\n            transaction.onabort = function () {\r\n                rej(request.error);\r\n            };\r\n        })\r\n    }\r\n}","import EventEmitter from 'events'\r\nimport { ROLE } from './constants';\r\n\r\nexport default class Tool extends EventEmitter{\r\n    constructor(name, defaultKey=null, iconURL=null, minRole=ROLE.GUEST){\r\n        super();\r\n\r\n        this.name = name;\r\n        this.icon = iconURL;\r\n\r\n        this.defaultKey = defaultKey;\r\n        this.key = defaultKey ? defaultKey.toString() : undefined;\r\n\r\n        this.requiredRole = minRole;\r\n    }\r\n}","import EventEmitter from 'events';\r\nimport globals from './globals';\r\nimport tools from './tools';\r\nimport camera from './camera';\r\nimport player from './player';\r\nimport {\r\n    screenToBoardSpace\r\n} from './utils/conversions';\r\nimport {\r\n    insanelyLongMobileBrowserCheck,\r\n    stringifyKeyEvent,\r\n    decodeKey\r\n} from './utils/misc';\r\nimport { getLS, setLS } from './utils/localStorage';\r\nimport me from './me';\r\nimport { coords as coordsEl } from './ui/elements';\r\n\r\nimport downArrow from '../img/arrow.svg';\r\n\r\nconst coords = coordsEl[0];\r\n\r\nfunction updatePlayerCoords(clientX, clientY) {\r\n    let [newX, newY] = screenToBoardSpace(clientX, clientY);\r\n\r\n    if (newX === player.x && newY === player.y) {\r\n        return\r\n    }\r\n\r\n    player.x = newX;\r\n    player.y = newY;\r\n\r\n    coords.innerText = `(${player.x}, ${player.y})`\r\n\r\n    if (player.color != -1 && camera.zoom > 1)\r\n        globals.renderer.needRender = true;\r\n}\r\n\r\nconst isMobile = insanelyLongMobileBrowserCheck();\r\n\r\nexport default class ToolManager extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n\r\n        this.tools = tools;\r\n        this.tool = tools.mover;\r\n\r\n        this._keyBinds = {};\r\n        this._colorBinds = {};\r\n        this.activeTools = {};\r\n\r\n        this.addTools();\r\n        this.loadBinds();\r\n        this.initEvents();\r\n\r\n        this.ctrlDown = false;\r\n        this.altDown = false;\r\n\r\n        this.toolChangeBlocked = false;\r\n\r\n        me.callOnLoaded(this.filterTools.bind(this));\r\n    }\r\n\r\n    filterTools() {\r\n        Object.keys(this.tools).forEach(name => {\r\n            if (this.tools[name].requiredRole > me.role) {\r\n                delete this._keyBinds[this.tools[name].key];\r\n\r\n                if (isMobile) {\r\n                    $(`#tool_${name}`).remove();\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    addTools() {\r\n        const toolsEl = document.getElementById('tools');\r\n        let hiddenToolsEl = null;\r\n\r\n        Object.keys(this.tools).forEach(name => {\r\n            const tool = this.tools[name];\r\n\r\n            if (isMobile) {\r\n                if (!tool.icon) return;\r\n\r\n                let el = document.createElement('div');\r\n                el.classList = 'toolContainer';\r\n                el.id = `tool_${name}`;\r\n                let img = document.createElement('img');\r\n                img.className = 'toolIcon';\r\n                img.src = tool.icon;\r\n\r\n                el.appendChild(img);\r\n\r\n                if(toolsEl.childElementCount >= 5){\r\n                    if(!hiddenToolsEl){\r\n                        hiddenToolsEl = document.createElement('div');\r\n                        hiddenToolsEl.style.display = 'none';\r\n\r\n                        const showAllButton = document.createElement('div');\r\n                        showAllButton.className = 'showAllToolsButton';\r\n                        const showAllImg = document.createElement('img');\r\n                        showAllImg.src = downArrow;\r\n\r\n                        showAllButton.append(showAllImg);\r\n\r\n                        showAllButton.addEventListener('click', e => {\r\n                            const state = parseInt(showAllButton.dataset.state ?? 0);\r\n                            hiddenToolsEl.style.display = state ? 'none' : '';\r\n                            showAllImg.style.transform = state ? '' : 'rotate(180deg)';\r\n                            showAllButton.dataset.state = state ? '0' : '1';\r\n                        });\r\n\r\n                        toolsEl.append(hiddenToolsEl, showAllButton);\r\n                    }\r\n\r\n                    hiddenToolsEl.append(el);\r\n                }else{\r\n                    toolsEl.appendChild(el);\r\n                }\r\n\r\n                el.addEventListener('pointerdown', this.selectTool.bind(this, tool));\r\n\r\n                if (tool.name === 'mover')\r\n                    this.selectTool(tool);\r\n            } else {\r\n                if (player)\r\n                    this._keyBinds[tool.key] = tool;\r\n            }\r\n        })\r\n    }\r\n\r\n    getToolKey(tool) {\r\n        for (const [key, value] of Object.entries(this.tools)) {\r\n            if (tool === value) return key;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    selectTool(tool) {\r\n        if (this.toolChangeBlocked) return;\r\n\r\n        let oldToolEl = document.getElementsByClassName('toolContainer selected')[0]\r\n        if (oldToolEl)\r\n            oldToolEl.className = 'toolContainer';\r\n\r\n        const toolKey = this.getToolKey(tool);\r\n        const curToolEl = document.getElementById(`tool_${toolKey}`);\r\n        curToolEl.classList = ['toolContainer selected'];\r\n\r\n        this.tool.emit('deselected');\r\n        this.tool = tool;\r\n        this.tool.emit('selected');\r\n    }\r\n\r\n    blockToolChange() {\r\n        this.toolChangeBlocked = true;\r\n    }\r\n\r\n    unblockToolChange() {\r\n        this.toolChangeBlocked = false;\r\n    }\r\n\r\n    initEvents() {\r\n        let em = globals.eventManager;\r\n\r\n        if (isMobile) {\r\n            em.on('zoom', zoom => {\r\n                camera.zoom *= zoom + 1;\r\n                camera.checkZoom();\r\n                globals.renderer.needRender = true;\r\n                globals.fxRenderer.needRender = true;\r\n            });\r\n\r\n            em.on('mousedown', e => {\r\n                updatePlayerCoords(e.clientX, e.clientY);\r\n            });\r\n\r\n            em.on('mousemove', e => {\r\n                updatePlayerCoords(e.clientX, e.clientY);\r\n            });\r\n\r\n            let events = [\r\n                ['mousedown', 'down'],\r\n                ['mousemove', 'move'],\r\n                ['mouseup', 'up']\r\n            ];\r\n\r\n            events.forEach(event => {\r\n                const [realEvent, myEvent] = event;\r\n                em.on(realEvent, e => {\r\n                    let tool = this.tool;\r\n                    if (e && e.gesture) {\r\n                        this.tool.emit('_gesture');\r\n                        tool = this.tools.mover;\r\n                    }\r\n                    if (!tool) return\r\n\r\n                    // emit to selected tool\r\n                    tool.emit(myEvent, e);\r\n                    // emit to other subscribers\r\n                    this.emit(myEvent, e);\r\n                });\r\n            });\r\n        } else {\r\n            em.on('mouseup', e => {\r\n                // if (e.button === 2) {\r\n                //     player.switchColor(-1);\r\n                //     player.switchSecondColor(-1);\r\n                // }\r\n            });\r\n            em.on('mousemove', e => {\r\n                updatePlayerCoords(e.clientX, e.clientY);\r\n\r\n                this.tool.emit('move', e)\r\n                this.emit('move', e);\r\n            });\r\n\r\n            const keydown = (e) => {\r\n                if(globals.lockInputs) return;\r\n\r\n                let str = stringifyKeyEvent(e);\r\n                if (!str) return;\r\n\r\n                const tool = this._keyBinds[str];\r\n\r\n                if (tool) {\r\n                    // TODO\r\n                    this.tool = tool; // , \r\n                    // ?   mousemove  down\r\n                    //    up\r\n                    tool.emit('down', e);\r\n                }\r\n            }\r\n            em.on('keydown', keydown);\r\n            em.on('mousedown', keydown);\r\n\r\n\r\n            const keyup = (e) => {\r\n                if(globals.lockInputs) return;\r\n\r\n                let strEvKey = stringifyKeyEvent(e);\r\n                if (!strEvKey) return;\r\n\r\n                const tool = this._keyBinds[strEvKey];\r\n\r\n                for (let name of Object.keys(this.tools)) {\r\n                    const tool2 = this.tools[name];\r\n\r\n                    if (!tool2.key || tool2 === tool)\r\n                        continue;\r\n\r\n                    const tool2keyDecoded = decodeKey(tool2.key);\r\n\r\n                    if (strEvKey === tool2.key || \r\n                        // make up event on single Alt, because after that keyup on the \r\n                        // primary key will no longer match the tool key string (i.e. up=\"V\" vs key=\"ALT+V\")\r\n                        \r\n                        (strEvKey.startsWith('Alt') && tool2keyDecoded.alt) || \r\n                        (strEvKey.startsWith('Ctrl') && tool2keyDecoded.ctrl)) {\r\n                            tool2.emit('up', e)\r\n                        }\r\n                }\r\n\r\n                if (tool) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n\r\n                    tool.emit('up', e);\r\n                }\r\n            }\r\n            em.on('keyup', keyup);\r\n            em.on('mouseup', keyup);\r\n\r\n            em.on('wheel', e => {\r\n                const oldZoom = camera.zoom;\r\n                camera.zoomTo(e.deltaY);\r\n\r\n                const dx = e.clientX - window.innerWidth / 2;\r\n                const dy = e.clientY - window.innerHeight / 2;\r\n\r\n                camera.moveTo((dx / oldZoom), (dy / oldZoom));\r\n                camera.moveTo(-(dx / camera.zoom), -(dy / camera.zoom));\r\n\r\n                if (localStorage.getItem('iHaveProblems') === 'yes') {\r\n                    camera.x = Math.round(camera.x); camera.y = Math.round(camera.y);\r\n                    globals.renderer.needRender = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        function specKeysHandlers(e) {\r\n            this.ctrlDown = e.ctrlKey;\r\n            this.altDown = e.altKey;\r\n        }\r\n\r\n        em.on('keydown', specKeysHandlers.bind(this));\r\n        em.on('keyup', specKeysHandlers.bind(this));\r\n\r\n        // TODO: add listener directly to ToolManager, istead of tool itself, avoiding cyclic check\r\n        em.on('tick', e => {\r\n            Object.keys(this.tools).forEach(name => {\r\n                const tool = this.tools[name];\r\n                if (tool.listenerCount('tick') > 0) {\r\n                    tool.emit('tick', e);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    changeKey(tool, key, deleteOld=true) {\r\n        if(deleteOld){\r\n            const oldKey = tool.key;\r\n            delete this._keyBinds[oldKey];\r\n        }\r\n\r\n        tool.key = key;\r\n        this._keyBinds[key] = tool\r\n    }\r\n\r\n    loadBinds() {\r\n        const str = getLS('keyBinds');\r\n        let newBinds;\r\n        try {\r\n            newBinds = JSON.parse(str);\r\n            if (!newBinds)\r\n                return;\r\n        } catch {\r\n            toastr.error('Error on parsing key binds from local storage');\r\n            localStorage.removeItem('keyBinds');\r\n            return\r\n        }\r\n\r\n        // clearing keybinds ahead of time\r\n        // it's not safe to delete them in for loop\r\n        this._keyBinds = {};\r\n        let toolname;\r\n        for (let key of Object.keys(newBinds)) {\r\n            if (toolname = this.findByName(key)){\r\n                this.changeKey(this.tools[toolname], newBinds[key], false);                \r\n            }\r\n        }\r\n    }\r\n\r\n    saveBinds() {\r\n        let toSave = {};\r\n\r\n        for (const tool of Object.values(tools)) {\r\n            if (!tool.key) continue;\r\n\r\n            toSave[tool.name] = tool.key;\r\n        }\r\n\r\n        setLS('keyBinds', JSON.stringify(toSave));\r\n    }\r\n\r\n    findByName(name) {\r\n        const keys = Object.keys(this.tools);\r\n        return keys.find(key => this.tools[key].name === name)\r\n    }\r\n\r\n    initColorBinds() {\r\n\r\n    }\r\n\r\n    loadColorBinds() {\r\n\r\n    }\r\n}","// copied from template 3.0\r\n// copyright GOROX\r\n\r\nimport jQuery from 'jquery';\r\nimport closeSVG from '../img/cross.svg'\r\nimport { translate as t } from './translate';\r\n\r\nlet windows = [];\r\nwindow.windows = windows;\r\n\r\nexport default class Window {\r\n    static Exists(title) {\r\n        return windows.some(x => x.title === title)\r\n    }\r\n    static Find(title) {\r\n        return windows.find(x => x.title === title)\r\n    }\r\n    constructor(config) {\r\n        // all values also will be loaded from config few lines below\r\n\r\n        // title can be passed instead of config\r\n        if (typeof config == 'string')\r\n            config = { title: config }\r\n\r\n        this.created = false;\r\n\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        this.title = \"\";\r\n\r\n        this.parent = document.body;\r\n\r\n        // do not set to false if closeable\r\n        this.moveable = true;\r\n        this.closeable = true;\r\n        this.closed = false;\r\n\r\n        this.center = false;\r\n\r\n        // here\r\n        Object.assign(this, config);\r\n\r\n        if (Window.Exists(this.title)) {\r\n            this.oldWindow = Window.Find(this.title);\r\n            return\r\n        }\r\n\r\n        this.created = true;\r\n\r\n        if (!this.block) { // for static windows like chat\r\n            this.block = this.createParentBlock();\r\n            this.moveTo(this.x, this.y); // user defined coordinates\r\n            this.parent.appendChild(this.block);\r\n        }\r\n\r\n        if (this.center) {\r\n            this.moveToCenter();\r\n            // :    \r\n            setTimeout(() => this.moveToCenter());\r\n        }\r\n\r\n        this.addFeatures();\r\n\r\n        windows.push(this);\r\n    }\r\n\r\n    get width() {\r\n        return this.element?.getBoundingClientRect().width;\r\n    }\r\n\r\n    get height() {\r\n        return this.element?.getBoundingClientRect().height;\r\n    }\r\n\r\n    get left() {\r\n        return this.x;\r\n    }\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    get top() {\r\n        return this.y;\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n\r\n    updateTitle(newTitle, temp = false) {\r\n        if (!temp) {\r\n            this.title = newTitle;\r\n        }\r\n        const head = $('.windowTitle', this.element);\r\n\r\n        // this makes \".innerHtml = ...\" of method below purposeless\r\n        // since html is not saved here\r\n        head.text(newTitle);\r\n    }\r\n\r\n    createParentBlock() {\r\n        let el = document.createElement('div');\r\n        el.className = 'window';\r\n        this.element = el;\r\n\r\n        let head = document.createElement('div');\r\n        head.className = 'windowHeader'\r\n        head.innerHTML = '<h3 class=\"windowTitle\">' + this.title + '</h3>';\r\n        el.appendChild(head);\r\n\r\n        if (this.closeable) {\r\n            const closer = document.createElement('div');\r\n            closer.className = 'closeWindow';\r\n            closer.innerHTML = '<div></div>';\r\n\r\n            closer.addEventListener('pointerdown', event => {\r\n                // prevent window moving\r\n                event.stopPropagation();\r\n            });\r\n            closer.addEventListener('click', () => this.close());\r\n            head.appendChild(closer);\r\n        }\r\n\r\n        let body = document.createElement('div');\r\n        body.className = 'windowBody';\r\n        el.appendChild(body);\r\n        this.body = body;\r\n\r\n        return el\r\n    }\r\n\r\n    moveTo(x, y) {\r\n        const rect = this.block.getBoundingClientRect();\r\n        const w = rect.width,\r\n            h = rect.height;\r\n\r\n        this.x = Math.max(-w + 10, x);\r\n        this.y = Math.max(-h + 10, y);\r\n\r\n        this.x = Math.min(window.innerWidth - 10, this.x);\r\n        this.y = Math.min(window.innerHeight - 10, this.y);\r\n\r\n        this.block.style.left = this.x + 'px';\r\n        this.block.style.top = this.y + 'px';\r\n    }\r\n\r\n    moveBy(x, y) {\r\n        this.moveTo(this.x + x, this.y + y);\r\n    }\r\n\r\n    moveToCenter() {\r\n        let windowWidth = window.innerWidth,\r\n            windowHeight = window.innerHeight;\r\n\r\n        let blockWidth = this.block.offsetWidth,\r\n            blockHeight = this.block.offsetHeight;\r\n\r\n        this.moveTo(\r\n            windowWidth / 2 - blockWidth / 2,\r\n            windowHeight / 2 - blockHeight / 2\r\n        );\r\n    }\r\n\r\n    addFeatures() {\r\n        if (this.moveable) {\r\n            $(this.block).on('pointerdown', e => {\r\n                let self = this;\r\n                let lastX = e.clientX;\r\n                let lastY = e.clientY;\r\n\r\n                jQuery(document).on('pointermove', moved)\r\n\r\n                function moved(e) {\r\n                    e = e.originalEvent;\r\n                    let movedX = e.clientX - lastX;\r\n                    let movedY = e.clientY - lastY;\r\n\r\n                    lastX = e.clientX;\r\n                    lastY = e.clientY;\r\n\r\n                    self.moveBy(movedX, movedY);\r\n                }\r\n\r\n                jQuery(document).one('pointerup pointerleave', () => {\r\n                    jQuery(document).off('pointermove', moved);\r\n                });\r\n            });\r\n\r\n            $(this.body).on('pointerdown', e => {\r\n                e.stopPropagation();\r\n            })\r\n        }\r\n\r\n        // for window be in screen after\r\n        // screen rotation\r\n        window.addEventListener('orientationchange', () => {\r\n            setTimeout(() => {\r\n                this.moveTo(this.x, this.y);\r\n            }, 500);\r\n        })\r\n    }\r\n\r\n    close() {\r\n        jQuery(this.block).remove();\r\n        this.closed = true;\r\n        windows.splice(windows.indexOf(this), 1);\r\n    }\r\n}\r\n\r\nlet Modal_exists = false;\r\nexport class Modal {\r\n    static get isRunning() {\r\n        return Modal_exists\r\n    }\r\n    static set isRunning(val) {\r\n        return Modal_exists = val;\r\n    }\r\n\r\n    constructor() {\r\n        if (Modal.isRunning)\r\n            throw new Error('Modal is running');\r\n\r\n        this.body = null;\r\n\r\n    }\r\n    \r\n    init() {\r\n        const els =\r\n        $(`<div class=\"modalBg\">\r\n            <div class=\"modalCont\">\r\n            </div>\r\n            </div>`);\r\n            \r\n            this.bgEl = els[0];\r\n        this.contEl = this.bgEl.children[0];\r\n        \r\n        $(document.body).append(els);\r\n\r\n        Modal.isRunning = true;\r\n    }\r\n\r\n    close() {\r\n        Modal.isRunning = false;\r\n        this.bgEl.remove();\r\n    }\r\n}\r\n\r\nexport class ConfirmModal extends Modal {\r\n    constructor(msg, cb = null) {\r\n        super();\r\n\r\n        this.msg = msg;\r\n        this.cb = cb;\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        super.init();\r\n\r\n        const mBody = $(\r\n            `<div style=\"margin:0;padding:5px;text-align:center;color:var(--light-text)\">\r\n                <p>${this.msg}</p>\r\n                <button class='confirmBtn' style=\"padding: 8px;\">${t('OK')}</button>\r\n                <button class='cancelBtn' style=\"padding: 8px;\">${t('Cancel')}</button>\r\n            </div>`)\r\n        this.contEl.appendChild(mBody[0]);\r\n\r\n        $('button', mBody).on('click', () => {\r\n            this.close();\r\n        });\r\n\r\n        $('.confirmBtn', mBody).on('click', () => {\r\n            if (this.cb) this.cb(true);\r\n        });\r\n        $('.cancelBtn', mBody).on('click', () => {\r\n            if (this.cb) this.cb(false);\r\n        });\r\n    }\r\n}","import '../css/colorVars.css'\r\nimport '../css/style.css'\r\nimport '../../node_modules/toastr/build/toastr.css'\r\n\r\nimport '../img/vk-logo.svg';\r\nimport '../img/discord-logo-circle.svg';\r\nimport '../img/gg-logo.svg';\r\nimport '../img/stripes.png';\r\nimport '../img/dots.svg';\r\nimport '../img/goroxels.png';\r\nimport '../img/move-icon.svg';\r\n\r\nimport '../img/telegram.svg';\r\n\r\nimport '../video/clickerMouse.webm'\r\nimport '../video/clicker.webm'\r\nimport '../video/as.webm'\r\nimport '../video/toolC.webm'\r\nimport '../video/brush.webm'\r\nimport '../video/brush2.webm'\r\nimport '../video/line.webm'\r\nimport '../video/flood.webm'\r\nimport '../img/unavailable.png'\r\nimport '../video/ctrlZ.webm'\r\nimport '../video/patternDemo.webm'\r\nimport '../video/phoneDrawing.mp4'\r\nimport '../img/3rdcf.png'\r\n\r\nexport default {}","import globals from './globals'\nimport {\n    boardWidth,\n    boardHeight\n} from './config'\nimport EventEmitter from 'events';\nimport { getOrDefault, setLS } from './utils/localStorage';\n\nconst camera = {\n    x: null, y: null,\n    zoom: null,\n    minX: null, minY: null, \n    maxX: null, maxY: null,\n\n    minZoom: 0.1,\n    maxZoom: 64,\n\n    // when it's needed to disable moving\n    noMoving: false,\n\n    init(){\n        Object.assign(this, {\n            x: +getOrDefault('posX', 0, true),\n            y: +getOrDefault('posY', 0, true),\n\n            zoom: +getOrDefault('zoom', 1, true),\n\n            minX: -boardWidth/2,\n            minY: -boardHeight/2,\n            maxX: boardWidth/2,\n            maxY: boardHeight/2,\n        })\n        if(isNaN(this.x) || isNaN(this.y) || isNaN(this.zoom)){\n            this.x = 0;\n            this.y = 0;\n            this.zoom = 1;\n        }\n    },\n\n    centerOn(x, y){\n        globals.renderer.needRender = true;\n        globals.fxRenderer.needRender = true;\n        if(this.noMoving) return;\n        \n        this.x = x - this.maxX;\n        this.y = y - this.maxY;\n\n        this.clampPos();\n    },\n\n    moveTo(movx, movy){\n        globals.renderer.needRender = true;\n        if(this.noMoving) return;\n\n        this.x += movx;\n        this.y += movy;\n\n        this.clampPos();\n    },\n\n    clampPos(){\n        this.x = Math.min(Math.max(this.x, this.minX), this.maxX);\n        this.y = Math.min(Math.max(this.y, this.minY), this.maxY);\n    },\n\n    zoomTo(dir){\n        if(dir < 0){\n            this.zoom = this.zoom * 2 | 0 || 1;\n        }else{\n            this.zoom = this.zoom / 2;\n        }\n        this.checkZoom();\n\n        this.emit('zoom', this.zoom);\n\n        globals.renderer.needRender = true;\n        globals.fxRenderer.needRender = true;\n\n        globals.renderer.preRender();\n    },\n\n    checkZoom(){\n        this.zoom = Math.min(Math.max(this.zoom, this.minZoom), this.maxZoom)\n    }, \n\n    disableMove(){\n        this.noMoving = true;\n    },\n\n    enableMove(){\n        this.noMoving = false;\n    },\n\n    __proto__: new EventEmitter\n}\n\nlet lastX, lastY, lastZ;\nsetInterval(() => {\n    const newX = camera.x,\n        newY = camera.y,\n        newZ = camera.zoom;\n\n    if(lastX != newX) setLS('posX', newX, true);\n    if(lastY != newY) setLS('posY', newY, true);\n    if(lastZ != newZ) setLS('zoom', newZ, true);\n\n    lastX = newX; lastY = newY; lastZ = newZ;\n}, 3000);\n\nexport default (window.camera = camera);","// key codes to human readable string\r\n// !deprecated!\r\nexport const keys = { // others are ok with charCodeAt\r\n    8: \"Backspace\",\r\n    9: \"Tab\",\r\n    12: \"Clear\",\r\n    13: \"Enter\",\r\n    16: \"Shift\",\r\n    17: \"Control\",\r\n    18: \"Alt\",\r\n    19: \"Pause\",\r\n    20: \"CapsLock\",\r\n    27: \"Escape\",\r\n    32: \"Space\",\r\n    33: \"PageUp\",\r\n    34: \"PageDown\",\r\n    35: \"End\",\r\n    36: \"Home\",\r\n    37: \"ArrowLeft\",\r\n    38: \"ArrowUp\",\r\n    39: \"ArrowRight\",\r\n    40: \"ArrowDown\",\r\n    45: \"Insert\",\r\n    46: \"Delete\",\r\n    112: \"F1\",\r\n    113: \"F2\",\r\n    114: \"F3\",\r\n    115: \"F4\",\r\n    116: \"F5\",\r\n    117: \"F6\",\r\n    118: \"F7\",\r\n    119: \"F8\",\r\n    120: \"F9\",\r\n    121: \"F10\",\r\n    122: \"F11\",\r\n    123: \"F12\",\r\n    144: \"NumLock\",\r\n    145: \"ScrollLock\",\r\n    48: \"0\",\r\n    49: \"1\",\r\n    50: \"2\",\r\n    51: \"3\",\r\n    52: \"4\",\r\n    53: \"5\",\r\n    54: \"6\",\r\n    55: \"7\",\r\n    56: \"8\",\r\n    57: \"9\",\r\n    106: \"*\",\r\n    107: \"+\",\r\n    109: \"-\",\r\n    111: \"/\",\r\n    186: \";\",\r\n    187: \"=\",\r\n    188: \",\",\r\n    189: \"-\",\r\n    190: \".\",\r\n    191: \"/\",\r\n    192: \"`\",\r\n    219: \"[\",\r\n    220: \"\\\\\",\r\n    221: \"]\",\r\n    222: \"'\"\r\n}\r\n\r\nexport const ROLE = {\r\n    BANNED: -1,\r\n    GUEST: 0,\r\n    USER: 1,\r\n    TRUSTED: 2,\r\n    MOD: 3,\r\n    ADMIN: 4\r\n}\r\nexport const ROLE_I = {};\r\nObject.keys(ROLE).forEach(x => ROLE_I[ROLE[x]] = x);\r\n\r\n","export function initDraggableInputs() {\r\n    const DRAG_THRESHOLD = 5;\r\n\r\n    document.querySelectorAll('input[type=number].valueDrag').forEach(input => {\r\n        input.style.cursor = 'ew-resize';\r\n\r\n        let startX = 0;\r\n        let startValue = 0;\r\n        let dragging = false;\r\n        let armed = false;\r\n\r\n        const step = () => {\r\n            let s = parseFloat(input.step);\r\n            return isNaN(s) || s <= 0 ? 1 : s;\r\n        };\r\n\r\n        const min = () => {\r\n            let m = parseFloat(input.min);\r\n            return isNaN(m) ? -Infinity : m;\r\n        };\r\n\r\n        const max = () => {\r\n            let m = parseFloat(input.max);\r\n            return isNaN(m) ? Infinity : m;\r\n        };\r\n\r\n        input.addEventListener('mousedown', e => {\r\n            if (e.button !== 0) return;\r\n            armed = true;\r\n            dragging = false;\r\n            startX = e.clientX;\r\n            startValue = parseFloat(input.value) || 0;\r\n            e.preventDefault();\r\n        });\r\n\r\n        document.addEventListener('mousemove', e => {\r\n            if (!armed) return;\r\n            let dx = e.clientX - startX;\r\n\r\n            if (!dragging && Math.abs(dx) >= DRAG_THRESHOLD) {\r\n                dragging = true;\r\n\r\n                input.blur();\r\n                document.body.style.userSelect = 'none';\r\n                document.body.style.cursor = 'ew-resize';\r\n            }\r\n\r\n            if (dragging) {\r\n                let val = startValue + dx * step();\r\n                val = Math.min(max(), Math.max(min(), val));\r\n                input.value = val;\r\n                input.dispatchEvent(new Event('input', { bubbles: true }));\r\n            }\r\n        });\r\n\r\n        document.addEventListener('mouseup', e => {\r\n            if (!armed) return;\r\n            if (dragging) {\r\n                input.dispatchEvent(new Event('change', { bubbles: true }));\r\n            }\r\n            \r\n            if(e.target === input){\r\n                $(input).trigger('focus');\r\n            }\r\n\r\n            document.body.style.userSelect = '';\r\n            document.body.style.cursor = '';\r\n            armed = false;\r\n            dragging = false;\r\n        });\r\n    });\r\n}","import globals from './globals';\r\n\r\nexport const FX_STATE = {\r\n    IN_PROCESS: 0, // to force renderer to render\r\n    FINISHED: 1, // render when it's needed (next canvas update)\r\n    REMOVED: 2 // don't render and delete\r\n}\r\n\r\nexport class FX {\r\n    constructor(renderFunc) {\r\n        this.renderFunc = renderFunc;\r\n\r\n        this.removed = false;\r\n    }\r\n\r\n    render(ctx) {\r\n        return this.renderFunc(ctx);\r\n    }\r\n\r\n    remove() {\r\n        this.removed = true;\r\n    }\r\n}\r\n\r\nexport class FXRenderer {\r\n    constructor() {\r\n        // three layers\r\n        this.fxList = [[], [], []];\r\n        this.ctx = globals.fxCtx;\r\n\r\n        this.needRender = true;\r\n        this.needClear = false;\r\n    }\r\n\r\n    add(fx, layer = 0) {\r\n        this.fxList[layer].push(fx);\r\n\r\n        this.needRender = true;\r\n    }\r\n\r\n    /*\r\n      You can request it by returning zero in rendering\r\n      functions or explicitly \r\n    */\r\n    requestRender() {\r\n        this.needRender = true;\r\n    }\r\n\r\n    render() {\r\n        if (!this.needRender) return;\r\n\r\n        this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n\r\n        this.needRender = false;\r\n\r\n        for (let layer = 0; layer < this.fxList.length; layer++) {\r\n            this.fxList[layer].forEach(fx => {\r\n                try {\r\n                    if (fx.removed) return this.remove(fx);\r\n\r\n                    let r = fx.render(this.ctx);\r\n\r\n\r\n                    if (r == FX_STATE.REMOVED) {\r\n                        this.remove(fx);\r\n                    } else if (r == FX_STATE.IN_PROCESS) {\r\n                        this.needRender = true;\r\n                    }\r\n                } catch (error) {\r\n                    console.error(error);\r\n                }\r\n\r\n            })\r\n        }\r\n    }\r\n\r\n    remove(fx) {\r\n        for (let layer = 0; layer < this.fxList.length; layer++) {\r\n            let idx = this.fxList[layer].indexOf(fx);\r\n            if (idx != -1) {\r\n                this.fxList[layer][idx].remove();\r\n                this.fxList[layer].splice(idx, 1);\r\n                this.needRender = true;\r\n                break\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n// fxRenderer is loaded later then tools/template\r\n// so here is the workaround\r\nlet _deferredFX = [];\r\nexport function addFX(fx, layer) {\r\n    if (globals.fxRenderer) {\r\n        globals.fxRenderer.add(fx, layer);\r\n    } else _deferredFX.push([fx, layer]);\r\n}\r\n\r\nexport function removeFX(fx) {\r\n    globals.fxRenderer.remove(fx);\r\n}\r\nlet fxi = setInterval(() => {\r\n    if (globals.fxRenderer) {\r\n        clearInterval(fxi);\r\n        for (let [fx, layer] of _deferredFX) {\r\n            addFX(fx, layer);\r\n        }\r\n        _deferredFX = [];\r\n    }\r\n}, 5);","import camera from \"./camera\";\r\nimport { boardHeight, boardWidth } from \"./config\";\r\nimport { FX } from \"./fxcanvas\";\r\nimport { boardToScreenSpace } from \"./utils/conversions\";\r\n\r\n// require wipes dynamically, parsing the file name of each\r\nconst requireOldWipe = require.context('../img/old-wipes', false, /\\.png$/);\r\n\r\nconst namePathEntries = requireOldWipe.keys().map(key => {\r\n    const module = requireOldWipe(key);\r\n    const path = module.default;\r\n    const fname = path.match(/([\\.\\d]+)\\.png$/)[1];\r\n\r\n    return [fname, path];\r\n}).sort(([name1], [name2]) => {\r\n    // sort by date\r\n    const [day1, month1, year1] = name1.split('.').map(Number);\r\n    const [day2, month2, year2] = name2.split('.').map(Number);\r\n    \r\n    if (year1 !== year2) return year2 - year1;\r\n    if (month1 !== month2) return month2 - month1;\r\n    return day2 - day1;\r\n});\r\n\r\nexport const wipes = Object.fromEntries(namePathEntries);\r\n\r\nlet historyFx = null, fxCtx = null, prevCameraState;\r\nexport async function showHistoryCanvas(name) {\r\n    unloadHistoryCanvas();\r\n\r\n\r\n    const canvasImg = await loadHistoryCanvas(wipes[name]);\r\n\r\n    // saving and changing camera borders\r\n    // (the thing that helps you not get lost when moving canvas)\r\n    prevCameraState = cloneCameraProps(camera);\r\n\r\n    camera.minX = -canvasImg.width / 2;\r\n    camera.minY = -canvasImg.height / 2;\r\n    camera.maxX = canvasImg.width / 2;\r\n    camera.maxY = canvasImg.height / 2;\r\n\r\n    camera.x = 0;\r\n    camera.y = 0;\r\n    camera.zoom = camera.minZoom;\r\n\r\n    globals.renderer.needRender = true;\r\n\r\n    // need to center it in the current canvas, otherwise \r\n    // even camera borders change will not help\r\n    const canvasStartX = boardWidth/2 - canvasImg.width/2;\r\n    const canvasStartY = boardHeight/2 - canvasImg.height/2;\r\n\r\n    historyFx = new FX(ctx => {\r\n        if (fxCtx === null) {\r\n            fxCtx = ctx;\r\n            // hiding real canvas\r\n            ctx.canvas.style.backgroundColor = 'gray';\r\n        }\r\n\r\n        const zoom = camera.zoom\r\n        const topLeftPos = boardToScreenSpace(canvasStartX, canvasStartY);\r\n\r\n        ctx.drawImage(canvasImg, ...topLeftPos, canvasImg.width * zoom, canvasImg.height * zoom);\r\n\r\n        return 1;\r\n    });\r\n\r\n    globals.fxRenderer.add(historyFx, 1);\r\n}\r\n\r\nasync function loadHistoryCanvas(path) {\r\n    return new Promise((res, rej) => {\r\n        const img = new Image();\r\n\r\n        img.style.imageRendering = 'pixelated';\r\n\r\n        img.onload = () => res(img);\r\n        img.onerror = rej;\r\n\r\n        img.src = path;\r\n    });\r\n}\r\n\r\nfunction cloneCameraProps(){\r\n    const { x, y, zoom, minX, minY, maxX, maxY } = camera;\r\n    return { x, y, zoom, minX, minY, maxX, maxY };\r\n}\r\n\r\nexport function unloadHistoryCanvas() {\r\n    globals.fxRenderer.remove(historyFx);\r\n    if (fxCtx) {\r\n        fxCtx.canvas.style.backgroundColor = '';\r\n        fxCtx = null;\r\n    }\r\n    if (prevCameraState) {\r\n        const { x, y, zoom, minX, minY, maxX, maxY } = prevCameraState;\r\n        Object.assign(camera, { x, y, zoom, minX, minY, maxX, maxY });\r\n    }\r\n}\r\n\r\nfunction sortDates(dates) {\r\n    return dates.sort((a, b) => {\r\n        const [dayA, monthA, yearA] = a.split('.').map(Number);\r\n        const [dayB, monthB, yearB] = b.split('.').map(Number);\r\n        \r\n        const dateA = new Date(2000 + yearA, monthA - 1, dayA);\r\n        const dateB = new Date(2000 + yearB, monthB - 1, dayB);\r\n        \r\n        return dateA - dateB;\r\n    });\r\n}","export let initiated = false;\r\nexport let database = null;\r\n\r\nlet deferredCallbacks = [];\r\n\r\nexport function init() {\r\n    let openRequest = indexedDB.open(\"db\", 1);\r\n\r\n    function onDone(){\r\n        initiated = true;\r\n        execCallbacks();\r\n    }\r\n\r\n    openRequest.onupgradeneeded = function () {\r\n        database = openRequest.result;\r\n        if (!database.objectStoreNames.contains('chunkPlaceholders')) {\r\n            database.createObjectStore('chunkPlaceholders', { keyPath: 'chunk_key' });\r\n        }\r\n\r\n        onDone();\r\n    };\r\n\r\n    openRequest.onsuccess = () => {\r\n        database = openRequest.result;\r\n        onDone();\r\n    };\r\n}\r\n\r\nfunction execCallbacks(){\r\n    deferredCallbacks.forEach(cb => {\r\n        try {\r\n            cb(database);   \r\n        } catch (error) {\r\n            console.error(error);\r\n        }\r\n    })\r\n    deferredCallbacks.length = 0;\r\n}\r\n\r\nexport function addInitCallback(cb) {\r\n    if (initiated) {\r\n        cb(database);\r\n        return;\r\n    }\r\n\r\n    deferredCallbacks.push(cb);\r\n}","import { initChat, initMobileChatToggle } from \"./Chat\";\nimport { initDraggableInputs } from \"./draggableInputs\";\nimport globals from \"./globals\";\nimport player from \"./player\";\nimport { importTemplateFromUrl, initHandlers, initTemplateMobileMove, initTemplateMoveByMouse, loadValues } from \"./template\";\nimport { initCoordsClick, initUISettings } from \"./ui/config\";\nimport { initMenuResizer, initMobileMenuToggler } from \"./ui/toggles\";\nimport { startWinampRadio } from \"./winamp/player\";\nimport { initButtons, initHelpButton, initOnlineViewer, showHelpIfFirstTime } from \"./windows\";\n\nexport function initInputs() {\n    loadValues();\n    initHandlers();\n    initButtons();\n    initChat();\n    initDraggableInputs();\n}\n\nexport function initOtherCoolFeatures() {\n    initTemplateMobileMove();\n\n    importTemplateFromUrl();\n\n    initTemplateMoveByMouse();\n    initModMenu();\n    initMobileMenuToggler();\n    initUISettings();\n    initMobileChatToggle();\n    initHelpButton();\n    player.init();\n    initCoordsClick();\n    initOnlineViewer();\n    initMenuResizer();\n    showHelpIfFirstTime();\n    startWinampRadio();\n}\n\nfunction initModMenu() {\n    initSliding();\n    initSendAlerts();\n\n    function initSliding() {\n        $('#modMenu .title').on('click', e => {\n            const m = $('#modMenu');\n            if (m.data('state') === 'open') {\n                m.data('state', 'close');\n                m.css('right', '');\n            } else {\n                m.data('state', 'open');\n                m.css('right', $('#modMenu .body').css('width'));\n            }\n        })\n    }\n\n    function initSendAlerts() {\n        $('#sendAlerts').on('click', () => {\n            const val = $('#sendAlertsText').val();\n            if (val.length == 0 || val.length > 2000) return;\n\n            $('#sendAlertsText').val('');\n            globals.socket.sendAlert('all', val);\n        })\n    }\n}","import _ from './assets';\r\n\r\nimport Socket from './Socket';\r\nimport globals from './globals';\r\nimport ChunkManager from './ChunkManager';\r\nimport Renderer from './Renderer';\r\nimport { FXRenderer } from './fxcanvas';\r\nimport player, { updateMe } from './player';\r\nimport ToolManager from './ToolManager';\r\nimport { calculateColumnSize, initHalfmap } from './utils/misc';\r\n\r\nimport * as config from './config';\r\nimport { init as initTranslate, translate } from './translate';\r\nimport camera from './camera';\r\nimport { Modal } from './Window';\r\nimport { getLS, setLS } from './utils/localStorage';\r\nimport * as indexedDb from './indexedDb';\r\nimport { initInputs, initOtherCoolFeatures } from './init';\r\nimport { toggleTopMenu } from './ui/toggles';\r\nimport { fixColorsWidth } from './ui/config';\r\nimport { fixChatPosition } from './Chat';\r\nimport { fxCanvas, mainCanvas } from './ui/elements';\r\n\r\n(async () => {    \r\n    indexedDb.init();\r\n    await config.download();\r\n\r\n    window.onresize = () => {\r\n        mainCanvas[0].width = window.innerWidth;\r\n        mainCanvas[0].height = window.innerHeight;\r\n\r\n        fxCanvas[0].width = window.innerWidth;\r\n        fxCanvas[0].height = window.innerHeight;\r\n\r\n        const fxCtx = fxCanvas[0].getContext('2d');\r\n\r\n        ctx.imageSmoothingEnabled = fxCtx.imageSmoothingEnabled = false;\r\n        ctx.webkitImageSmoothingEnabled = fxCtx.webkitImageSmoothingEnabled = false;\r\n        ctx.mozImageSmoothingEnabled = fxCtx.mozImageSmoothingEnabled = false;\r\n        ctx.msImageSmoothingEnabled = fxCtx.msImageSmoothingEnabled = false;\r\n        ctx.oImageSmoothingEnabled = fxCtx.oImageSmoothingEnabled = false;\r\n\r\n        renderer.needRender = true;\r\n        fxRenderer.needRender = true;\r\n\r\n        if (!globals.mobile) {\r\n            calculateColumnSize();\r\n        }\r\n\r\n        fixColorsWidth();\r\n        fixChatPosition();\r\n    }\r\n\r\n\r\n    window.oncontextmenu = function (e) {\r\n        if (e.target === mainCanvas[0] ||\r\n            e.target.classList[0] === 'paletteColor' ||\r\n            (e.path && e.path[1].classList[0] === 'paletteColor')) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    camera.init();\r\n    initHalfmap();\r\n\r\n    config.palette.forEach((color, id) => {\r\n        const el = document.createElement('div');\r\n        el.style.backgroundColor = `rgb(${color.join(',')})`;\r\n        // el.classList = ['paletteColor ' + (isDarkColor(...color) ? 'dark' : 'light')];\r\n        el.classList = ['paletteColor light'];\r\n        el.id = 'col' + id;\r\n\r\n        // detect long press\r\n        let downtime = 0;\r\n\r\n        var $el = $(el);\r\n\r\n        $el.on('pointerdown', () => {\r\n            downtime = Date.now();\r\n        })\r\n\r\n        $el.on('pointerleave', () => {\r\n            downtime = 0;\r\n        })\r\n\r\n        el.onclick = e => {\r\n            let isLong = false;\r\n            if (downtime != 0) {\r\n                if (Date.now() - downtime > 700) {\r\n                    isLong = true;\r\n                }\r\n                downtime = 0;\r\n            }\r\n\r\n            let f = isLong ? player.switchSecondColor : player.switchColor;\r\n            f.call(player, id);\r\n        }\r\n\r\n        // only for MMB events\r\n        el.onmouseup = e => {\r\n            if(e.button !== 1){\r\n                return;\r\n            }\r\n\r\n            globals.toolManager.tools['colorador'].mmb(id);\r\n        }\r\n\r\n        el.oncontextmenu = () => {\r\n            // right button click\r\n            player.switchSecondColor(id);\r\n        }\r\n\r\n        palette.append(el);\r\n    })\r\n\r\n    const ctx = mainCanvas[0].getContext('2d');\r\n    ctx.imageSmoothingEnabled = false;\r\n\r\n    const wsPort = location.protocol === 'https:' ? 443 : (location.port || 80);\r\n    const socket = new Socket(wsPort);\r\n    globals.socket = socket;\r\n\r\n    const chunkManager = new ChunkManager();\r\n    globals.chunkManager = chunkManager;\r\n\r\n    const renderer = window.renderer = new Renderer(ctx);\r\n    globals.renderer = renderer;\r\n\r\n    const fxRenderer = new FXRenderer();\r\n    globals.fxRenderer = fxRenderer;\r\n\r\n    globals.toolManager = new ToolManager(document.getElementById('board'));\r\n\r\n    globals.player = player;\r\n\r\n    const renderLoop = () => {\r\n        requestAnimationFrame(() => {\r\n            renderer.requestRender();\r\n            renderLoop();\r\n        })\r\n    }\r\n    renderLoop();\r\n\r\n    window.onresize();\r\n\r\n    socket.on('opened', () => { });\r\n    socket.on('online', count => {\r\n        $('.online').text(count);\r\n    });\r\n    socket.on('closed', () => {\r\n        $('.online').text('offline');\r\n    })\r\n\r\n    window.globals = globals;\r\n\r\n    // create nsfw modal\r\n    config.callOnLoad(() => {\r\n        if (config.canvasName !== 'nsfw') return;\r\n        if (getLS('modal18') == 'accepted') return;\r\n\r\n        const m = new Modal;\r\n        m.init();\r\n        const mBody = $(\r\n            `<div style=\"margin:0;padding:5px;text-align:center;\">\r\n                <h1>${translate('WARNING')}</h1>\r\n                <p>${translate('This canvas may contain illustrations, inappropriate for people under age of 18, including:')}\r\n                <br>${translate('Gore, furry, porn, hate, anime and all possible variations of these.')}</p>\r\n                <p><b>${translate('Are you 18 y.o. and fully understanding what are you doing?')}</b></p>\r\n                <button style=\"padding: 8px;\">${translate('I am 18 years old and I take responsibility for my psyche on myself')}</button>\r\n            </div>`)\r\n        m.contEl.appendChild(mBody[0]);\r\n\r\n        $('button', mBody).on('click', () => {\r\n            m.close();\r\n            setLS('modal18', 'accepted');\r\n        });\r\n    });\r\n\r\n    updateMe();\r\n    initTranslate();\r\n    initInputs();\r\n    initOtherCoolFeatures();\r\n    // now hides by default\r\n    if(globals.mobile)\r\n        toggleTopMenu();\r\n})();","import { ROLE } from './constants'\r\nimport { apiRequest } from './utils/api';\r\n\r\nlet loaded = false;\r\nlet cbs = [];\r\n\r\nexport default {\r\n    registered: false,\r\n    name: null,\r\n    id: null,\r\n    role: ROLE.GUEST,\r\n    update(newMe){\r\n        this.registered = newMe.registered;\r\n        if(newMe.registered){\r\n            this.name = newMe.name;\r\n            this.role = newMe.role;\r\n            this.id = newMe.id;\r\n        }\r\n\r\n        this.updateRoleRelatedHtml();\r\n    },\r\n\r\n    updateRoleRelatedHtml(){\r\n        $('.minrole-admin').hide();\r\n        $('.minrole-mod').hide();\r\n        $('.minrole-trusted').hide();\r\n        $('.minrole-user').hide();\r\n\r\n        switch(this.role){\r\n            case ROLE.ADMIN:\r\n                $('.minrole-admin').show();\r\n            case ROLE.MOD:\r\n                $('.minrole-mod').show();\r\n            case ROLE.TRUSTED:\r\n                $('.minrole-trusted').show();\r\n            case ROLE.USER:\r\n                $('.minrole-user').show();\r\n        }\r\n    },\r\n\r\n    checkCanGetUserInfo(){\r\n        return this.registered && this.role >= ROLE.TRUSTED\r\n    },\r\n\r\n    async load(){\r\n        const response = await apiRequest('/me');\r\n        const user = await response.json();\r\n\r\n        this.update(user);\r\n\r\n        loaded = true;\r\n        this.callStacked();\r\n    },\r\n\r\n    callOnLoaded(cb){\r\n        if(this.loaded)\r\n            return cb();\r\n        cbs.push(cb);\r\n    },\r\n    callStacked(){\r\n        cbs.forEach(cb => cb());\r\n        cbs = [];\r\n    }\r\n}","import Bucket from './Bucket';\r\nimport { cooldown } from './config';\r\nimport { chatInput } from './ui/elements';\r\nimport globals from './globals';\r\nimport me from './me';\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport { ROLE, ROLE_I } from './constants';\r\nimport { translate as t } from './translate';\r\n\r\nconst player = {\r\n    x: 0,\r\n    y: 0,\r\n    color: -1,\r\n    brushSize: 1,\r\n    secondCol: -1,\r\n    id: -1,\r\n    suspendedClrs: null,\r\n    init() {\r\n        this.loadColors();\r\n        this.switchColor(this.color, true);\r\n        this.switchSecondColor(this.secondCol, true);\r\n    },\r\n    loadColors() {\r\n        this.color = +getOrDefault('color1', -1, true);\r\n        this.secondCol = +getOrDefault('color2', -1, true);\r\n    },\r\n    switchColor(id, initial = false) {\r\n        if (this.secondCol === id && id !== -1) {\r\n            this.switchSecondColor(-1);\r\n        }\r\n\r\n        if (this.color === id && !initial)\r\n            id = this.color = -1;\r\n        else\r\n            this.color = id;\r\n        globals.fxRenderer.needRender = true;\r\n        globals.renderer.preRender();\r\n\r\n        $('.paletteColor.selected').removeClass('selected');\r\n        if (id !== -1) {\r\n            $('#col' + id).addClass('selected');\r\n        }\r\n\r\n        setLS('color1', id, true);\r\n    },\r\n    switchSecondColor(id, initial) {\r\n        if (this.color === id && id !== -1) {\r\n            this.switchColor(-1);\r\n        }\r\n        if (this.secondCol === id && !initial)\r\n            id = this.secondCol = -1;\r\n        else\r\n            this.secondCol = id;\r\n        globals.fxRenderer.needRender = true;\r\n        globals.renderer.preRender();\r\n\r\n        $('.paletteColor.selectedSecond').removeClass('selectedSecond');\r\n        if (id !== -1) {\r\n            $('#col' + id).addClass('selectedSecond');\r\n        }\r\n\r\n        setLS('color2', id, true);\r\n    },\r\n    swapColors() {\r\n        const temp = this.color;\r\n        this.switchColor(this.secondCol);\r\n        this.switchSecondColor(temp);\r\n    },\r\n    resetColors() {\r\n        this.switchColor(-1);\r\n        this.switchSecondColor(-1);\r\n    },\r\n\r\n    // suspend/restore is a workaround to\r\n    // temporarily disable drawing by mouse/tools\r\n    suspendColors() {\r\n        this.suspendedClrs = [this.color, this.secondCol];\r\n        this.resetColors();\r\n    },\r\n    restoreColors() {\r\n        if (!this.suspendedClrs) return;\r\n\r\n        this.switchColor(this.suspendedClrs[0]);\r\n        this.switchSecondColor(this.suspendedClrs[1]);\r\n\r\n        this.suspendedClrs = null;\r\n    },\r\n\r\n    bucket: null,\r\n    updateBucket([delay, max]) {\r\n        this.bucket = new Bucket(delay, max);\r\n    },\r\n    placed: [],\r\n    maxPlaced: isNaN(+localStorage['maxPlaced']) ? 5000 : +localStorage['maxPlaced'],\r\n    placedCount: +getLS('placedCount', true) || 0\r\n}\r\n\r\nexport async function updateMe() {\r\n    await me.load();\r\n\r\n    player.updateBucket(getMyCooldown());\r\n    if (me.registered) {\r\n        chatInput.removeAttr('disabled');\r\n        chatInput.val('');\r\n\r\n        $('#loginButtons,.authBtn').hide();\r\n        $('#chatNick,#chatChannels').show();\r\n        $('#chatNick').text(me.name);\r\n        $('#chatHeader').addClass('logged');\r\n    } else {\r\n        chatInput.attr('disabled');\r\n        chatInput.val(t('login to chat'));\r\n\r\n        // $('#chatNick').text('CHAT');\r\n        $('#chatNick,#chatChannels').hide();\r\n        $('#loginButtons,.authBtn').show();\r\n        $('#chatHeader').removeClass('logged');\r\n    }\r\n}\r\n\r\nfunction getMyCooldown() {\r\n    const cooldowns = cooldown;\r\n\r\n    if (ROLE_I[me.role] == 'ADMIN') return [0, 32]\r\n    return cooldowns[ROLE_I[me.role]] || cooldown.GUEST;\r\n}\r\n\r\nexport function placePixels(pixels, store = true, isCtrlZ = false) {\r\n    // does not check pixels, excluding for wand\r\n\r\n    // check to allow place only on selected color, if selected\r\n    if (!isCtrlZ && globals.wandSelectedColor !== null) {\r\n        const allowedCol = globals.wandSelectedColor;\r\n\r\n        let someValid = false;\r\n        for (let i = 0; i < pixels.length; i++) {\r\n            const boardCol = globals.chunkManager.getChunkPixel(...pixels[i]);\r\n            if (boardCol !== allowedCol) {\r\n                // making pixels invalid\r\n                pixels[i][2] = 127;\r\n            } else {\r\n                someValid = true;\r\n            }\r\n        }\r\n\r\n        if (!someValid) return;\r\n\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n\r\n    if (store) {\r\n        pixels.forEach(([x, y, c]) => {\r\n            if(c === 127) return;\r\n            player.placed.push([x, y, globals.chunkManager.getChunkPixel(x, y)]);\r\n        })\r\n    }\r\n    globals.socket.sendPixels(pixels, false);\r\n}\r\n\r\nexport function placePixel(x, y, col, store = true, isCtrlZ = false) {\r\n    const oldCol = globals.chunkManager.getChunkPixel(x, y),\r\n        isProtected = globals.chunkManager.getProtect(x, y);\r\n\r\n    const wandColor = globals.wandSelectedColor;\r\n    if (!isCtrlZ && wandColor !== null && oldCol !== wandColor) return;\r\n\r\n    if (oldCol !== col && (!isProtected || me.role >= ROLE.TRUSTED) && globals.socket.connected) {\r\n        if (store) {\r\n            player.placed.push([x, y, globals.chunkManager.getChunkPixel(x, y)]);\r\n\r\n            if (player.placed.length > player.maxPlaced * 2) {\r\n                player.placed = player.placed.slice(-player.maxPlaced);\r\n            }\r\n        }\r\n\r\n        globals.chunkManager.setChunkPixel(x, y, col);\r\n        globals.fxRenderer.needRender = true;\r\n\r\n        globals.socket.sendPixel(x, y, col);\r\n\r\n        globals.socket.pendingPixels[x + ',' + y] = setTimeout(() => {\r\n            globals.chunkManager.setChunkPixel(x, y, oldCol);\r\n            globals.renderer.needRender = true;\r\n        }, 3000)\r\n    } else {\r\n        if (isProtected && me.role < ROLE.TRUSTED) {\r\n            toastr.error(t('error.protected_pixel'), t('Error!'), {\r\n                preventDuplicates: true,\r\n                timeOut: 750\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nexport function updateBrush(size) {\r\n    player.brushSize = +size;\r\n    globals.fxRenderer.needRender = true;\r\n\r\n    globals.renderer.preRenderBrush();\r\n\r\n    $('#brushSizeCounter').text(size - 1);\r\n}\r\n\r\nexport function togglePlaced(state) {\r\n    state ? $('#placedPixels').show() : $('#placedPixels').hide();\r\n}\r\n\r\nexport function updatePlaced(count, handCount) {\r\n    // FIXME: move it to interval?\r\n    $('#placedPixels').text(count);\r\n    if (handCount)\r\n        $('#placedPixels').attr('title', handCount);\r\n}\r\n\r\nlet lastPlaced = player.placedCount;\r\nsetInterval(() => {\r\n    if (lastPlaced !== player.placedCount) {\r\n        setLS('placedCount', player.placedCount, true);\r\n        lastPlaced = player.placedCount;\r\n    }\r\n}, 3000);\r\n\r\nexport default player;","// change utils/recorder if changes\r\n\r\nexport const OPCODES = {\r\n    chunk:       0x0,\r\n    place:       0x1,\r\n    online:      0x2,\r\n    canvas:      0x3,\r\n    pixels:      0x4,\r\n    captcha:     0x5,\r\n    ping:        0x6,\r\n    placeBatch:  0x7,\r\n    updateRadio: 0x8\r\n}\r\n\r\nexport const STRING_OPCODES = {\r\n    error: 'e',\r\n    userJoin: 'u',\r\n    userLeave: 'l',\r\n    subscribeChat: 's',\r\n    chatMessage: 'c',\r\n    alert: 'a',\r\n    me: 'm',\r\n    reload: 'r',\r\n    reloadChunks: 'rc'\r\n}\r\n\r\n// max coords is up to 4096\r\nexport function packPixel(x, y, col) {\r\n    return (x << 12 | y) << 7 | col\r\n}\r\n\r\nexport function unpackPixel(num) {\r\n    return [\r\n        num >>> 19,\r\n        num >>> 7 & 0xFFF,\r\n        num & 0b1111111\r\n    ]\r\n}","import camera from './camera';\r\nimport {\r\n    halfMap,\r\n    loadImage\r\n} from './utils/misc'\r\n\r\nlet winWid = window.innerWidth / 2,\r\n    winHei = window.innerHeight / 2;\r\n\r\nwindow.addEventListener('resize', () => {\r\n    winWid = window.innerWidth / 2;\r\n    winHei = window.innerHeight / 2;\r\n})\r\n\r\nimport {\r\n    urlInput,\r\n    xInput,\r\n    yInput,\r\n    opacInput,\r\n    chatInput\r\n} from './ui/elements';\r\nimport { boardToScreenSpace, screenToBoardSpace } from './utils/conversions';\r\nimport globals from './globals';\r\nimport { addFX, FX } from './fxcanvas';\r\nimport { getOrDefault, setLS } from './utils/localStorage';\r\nimport me from './me';\r\nimport { apiRequest } from './utils/api';\r\nimport { templatesWindow } from './windows';\r\nimport player from './player';\r\n\r\nconst widthRegEx = /w(?:idth)?=(\\d+)$/;\r\n\r\nexport class TemplateFx {\r\n    constructor() {\r\n\r\n    }\r\n}\r\n\r\n// singletone atm\r\nclass Template {\r\n    constructor() {\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        this.templateImg;\r\n        this.templateResizeW = null;\r\n\r\n        this._lastUrl = null;\r\n\r\n        addFX(new FX(this.renderFx.bind(this)));\r\n    }\r\n\r\n    get url() {\r\n        return urlInput.val()\r\n    }\r\n\r\n    get opacity() {\r\n        return +opacInput.val()\r\n    }\r\n\r\n    set opacity(val) {\r\n        opacInput.val(val);\r\n    }\r\n\r\n    renderFx(ctx) {\r\n        if (!this.templateImg) return 1;\r\n\r\n        ctx.imageSmoothingEnabled = false;\r\n\r\n        const [posX, posY] = boardToScreenSpace(this.x, this.y);\r\n        const zoom = camera.zoom;\r\n\r\n        let canvasW, canvasH;\r\n        // patternized or not\r\n        if (this.templateResizeW) {\r\n            canvasW = this.templateResizeW;\r\n            // sometimes AR does not align template properly\r\n            // so we need to divide by the pattern size(7) manually\r\n            if (this.templateImg.width / this.templateResizeW === 7) {\r\n                canvasH = Math.floor(this.templateImg.height / 7);\r\n            } else {\r\n                const ar = this.templateImg.width / this.templateImg.height;\r\n                canvasH = Math.floor(this.templateResizeW / ar);\r\n            }\r\n        } else {\r\n            canvasW = this.templateImg.width;\r\n            canvasH = this.templateImg.height;\r\n        }\r\n\r\n        const oldOpac = ctx.globalAlpha;\r\n        ctx.globalAlpha = this.opacity;\r\n\r\n        ctx.drawImage(this.templateImg, posX, posY, canvasW * zoom | 0, canvasH * zoom | 0);\r\n\r\n        ctx.globalAlpha = oldOpac;\r\n        return 1;\r\n    }\r\n\r\n    update() {\r\n        this.updatePosition();\r\n        this.updateImage();\r\n    }\r\n\r\n    updatePosition() {\r\n        this.x = parseInt(xInput.val(), 10);\r\n        this.y = parseInt(yInput.val(), 10);\r\n\r\n        globals.fxRenderer.requestRender();\r\n    }\r\n\r\n    static parseImageUrl(url) {\r\n        let width = null;\r\n        let match;\r\n        if (match = url.match(widthRegEx)) {\r\n            width = +match[1];\r\n        }\r\n\r\n        if (url.startsWith('GRX')) {\r\n            const file = url.match(/f=(.+\\.png)/)[1];\r\n            url = `/api/template/img?t=orig&f=${file}`;\r\n        }\r\n\r\n        return {\r\n            url, width\r\n        }\r\n    }\r\n\r\n    async updateImage() {\r\n        if (this.url === this._lastUrl) {\r\n            return;\r\n        }\r\n\r\n        const {\r\n            url: parsedUrl, width: parsedWidth\r\n        } = Template.parseImageUrl(this.url);\r\n\r\n        this.templateImg = await loadImage(parsedUrl);\r\n        this._lastUrl = this.url;\r\n\r\n        this.templateResizeW = parsedWidth;\r\n\r\n        globals.fxRenderer.requestRender();\r\n    }\r\n\r\n    get isPatterns() {\r\n        return !isNaN(this.templateResizeW) &&\r\n            this.templateImg.width % 7 == 0 &&\r\n            this.templateImg.height % 7 == 0;\r\n    }\r\n}\r\nconst template = new Template();\r\n\r\nexport function loadValues() {\r\n    const urlVal = getOrDefault('template.url', 'https://i.imgur.com/4GQIMQ7.png', true);\r\n    urlInput.val(urlVal);\r\n\r\n    const xVal = getOrDefault('template.x', 0, true);\r\n    xInput.val(parseInt(xVal, 10));\r\n\r\n    const yVal = getOrDefault('template.y', 0, true);\r\n    yInput.val(parseInt(yVal, 10));\r\n\r\n    const opacVal = getOrDefault('template.opac', 0.5, true);\r\n    opacInput.val(parseFloat(opacVal));\r\n}\r\n\r\nfunction saveTemplate() {\r\n    setLS('template.x', template.x, true);\r\n    setLS('template.y', template.y, true);\r\n    setLS('template.url', template.url, true);\r\n    setLS('template.opac', template.opacity, true);\r\n}\r\n\r\nexport function updateTemplate() {\r\n    template.update();\r\n    saveTemplate();\r\n}\r\n\r\nexport function initHandlers() {\r\n    urlInput.on('input', updateTemplate);\r\n    xInput.on('input', updateTemplate);\r\n    yInput.on('input', updateTemplate);\r\n    opacInput.on('input', updateTemplate);\r\n\r\n    updateTemplate();\r\n}\r\n\r\nexport function initTemplateMoveByMouse() {\r\n    $(document).on('mousedown', e => {\r\n        if (!e.ctrlKey) return;\r\n\r\n        // preventing default movement\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n\r\n        let lastCord = screenToBoardSpace(e.clientX, e.clientY).map(x => x |= 0);\r\n\r\n        function mousemove(e) {\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n\r\n            const boardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n            boardPos[0] |= 0;\r\n            boardPos[1] |= 0;\r\n\r\n            let [lastX, lastY] = boardPos;\r\n\r\n            if (lastX === lastCord[0] && lastY === lastCord[1])\r\n                return;\r\n\r\n            // console.log(lastX, lastY, boardPos, lastCord)\r\n\r\n            xInput.val(template.x -= lastCord[0] - lastX);\r\n            yInput.val(template.y -= lastCord[1] - lastY);\r\n\r\n            template.updatePosition();\r\n\r\n            lastCord = boardPos;\r\n\r\n            saveTemplate();\r\n        }\r\n        $(document).on('mousemove', mousemove);\r\n        $(document).one('mouseup mouseleave', () => {\r\n            $(document).off('mousemove', mousemove);\r\n        })\r\n    })\r\n}\r\n\r\nexport function importTemplateFromUrl() {\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    const tUrl = urlParams.get('t_url');\r\n    const tX = urlParams.get('t_x');\r\n    const tY = urlParams.get('t_y');\r\n    if (!tUrl || !tX || !tY) return\r\n\r\n    urlInput.val(decodeURIComponent(tUrl));\r\n    xInput.val(+tX);\r\n    yInput.val(+tY);\r\n\r\n    updateTemplate();\r\n    removeAllSearchParams();\r\n}\r\n\r\nfunction removeAllSearchParams() {\r\n    const url = new URL(window.location);\r\n    url.search = '';\r\n    window.history.replaceState(null, '', url);\r\n}\r\n\r\nexport function shareTemplate() {\r\n    const imgUrl = urlInput.val();\r\n    const x = xInput.val();\r\n    const y = yInput.val();\r\n\r\n    const curUrl = location.origin + location.pathname;\r\n\r\n    const importUrl = `${curUrl}?t_url=${encodeURIComponent(imgUrl)}&t_x=${x}&t_y=${y}`;\r\n\r\n    chatInput.val(importUrl);\r\n    chatInput.trigger('focus');\r\n\r\n    // to trigger input events, such as white text color for links\r\n    const inputEvent = new Event('input', {\r\n        bubbles: true,\r\n        cancelable: true\r\n    });\r\n    chatInput[0].dispatchEvent(inputEvent);\r\n}\r\n\r\nexport async function showTemplates() {\r\n    if (!me.registered) {\r\n        return toastr.error('needs_login_to_use_templates');\r\n    }\r\n    const resp = await apiRequest('/template/list');\r\n\r\n    const respData = await resp.json();\r\n    if (respData.errors) return;\r\n\r\n    templatesWindow(respData);\r\n}\r\n\r\nexport function initTemplateMobileMove() {\r\n    const moveBtn = $('#manualMoveBtn');\r\n\r\n    let isMovingEnabled = false;\r\n\r\n    let lastPressCord;\r\n    // let pointerId;\r\n    function mousedown(e) {\r\n        if (!isMovingEnabled) return;\r\n\r\n        lastPressCord = screenToBoardSpace(e.clientX, e.clientY).map(x => x |= 0);\r\n\r\n        // sometimes mouseup's not emitted\r\n        mouseup();\r\n\r\n        globals.eventManager.on('mousemove', mousemove);\r\n    }\r\n\r\n    function mousemove(e) {\r\n        if (e.gesture) return;\r\n\r\n        const boardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n        boardPos[0] |= 0;\r\n        boardPos[1] |= 0;\r\n\r\n        let [lastX, lastY] = boardPos;\r\n\r\n        if (lastX === lastPressCord[0] && lastY === lastPressCord[1])\r\n            return;\r\n\r\n        console.log({ lastX, lastY, boardPos, lastPressCord })\r\n\r\n        xInput.val(template.x -= lastPressCord[0] - lastX);\r\n        yInput.val(template.y -= lastPressCord[1] - lastY);\r\n\r\n        template.updatePosition();\r\n\r\n        lastPressCord = boardPos;\r\n\r\n        saveTemplate();\r\n    }\r\n\r\n    function mouseup() {\r\n        globals.eventManager.off('mousemove', mousemove);\r\n    }\r\n\r\n    globals.eventManager.on('mousedown', mousedown);\r\n    globals.eventManager.on('mouseup', mouseup);\r\n\r\n    moveBtn.on('click', () => {\r\n        if (isMovingEnabled) {\r\n            moveBtn.removeClass('active');\r\n            // just to be sure\r\n            mouseup();\r\n\r\n            globals.toolManager.unblockToolChange();\r\n            restoreTool();\r\n        } else {\r\n            moveBtn.addClass('active');\r\n            saveAndResetTool();\r\n            globals.toolManager.blockToolChange();\r\n        }\r\n\r\n        isMovingEnabled = !isMovingEnabled;\r\n    });\r\n\r\n    // workaround, because to just cancel events \r\n    // (to prevent tools doing their job during the placement) \r\n    // we need to rewrite whole eventManager\r\n    let savedTool, savedColors;\r\n    function saveAndResetTool() {\r\n        savedTool = globals.toolManager.tool;\r\n        savedColors = [player.color, player.secondCol];\r\n\r\n        globals.toolManager.selectTool(globals.toolManager.tools['clicker']);\r\n        player.resetColors();\r\n    }\r\n\r\n    function restoreTool() {\r\n        globals.toolManager.selectTool(savedTool);\r\n        [player.color, player.secondCol] = savedColors;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nexport default template;","import { toggleChat } from './Chat';\r\nimport MiniWindow, { SelectMiniWindow } from './MiniWindow';\r\nimport Tool from './Tool';\r\nimport camera from './camera';\r\nimport { boardHeight, boardWidth, canvasId, chunkSize, hexPalette, palette, resolveWhenConfigDownloaded, showProtected } from './config';\r\nimport { ROLE } from './constants';\r\nimport { addFX, FX, FX_STATE, removeFX } from './fxcanvas';\r\nimport globals from './globals';\r\nimport me from './me';\r\nimport player, { placePixel, placePixels, updateBrush } from './player';\r\nimport template, { updateTemplate } from './template';\r\nimport { translate as t } from './translate';\r\nimport { changeSelector, chatInput, mainCanvas } from './ui/elements';\r\nimport { toggleEverything, toggleTopMenu } from './ui/toggles';\r\nimport { apiRequest } from './utils/api';\r\nimport { inBounds } from './utils/camera';\r\nimport { closestColor, getPaletteColorId, isDarkColor } from './utils/color';\r\nimport { boardToScreenSpace, screenToBoardSpace } from './utils/conversions';\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport { mapRange } from './utils/math';\r\nimport { htmlspecialchars, isClick, sleep, testPointInPolygon } from './utils/misc';\r\nimport shapes from './utils/shapes';\r\nimport { generateShader } from './utils/webGL';\r\n\r\nimport clickerIcon from '../img/toolIcons/clicker.png';\r\nimport disableIcon from '../img/toolIcons/disable.png';\r\nimport floodfillIcon from '../img/toolIcons/floodfill.png';\r\nimport lineIcon from '../img/toolIcons/line.png';\r\nimport moveIcon from '../img/toolIcons/move.png';\r\n// import pipetteIcon from '../img/toolIcons/pipette.png'\r\nimport protectIcon from '../img/toolIcons/protect.png';\r\nimport revertIcon from '../img/toolIcons/revert.png';\r\nimport wandIcon from '../img/toolIcons/wand-cur.png';\r\n\r\nimport disableCur from '../img/toolIcons/disable-cur.png';\r\nimport wandCursor from '../img/toolIcons/wand-cur.png';\r\n\r\nimport min5fontSheet from '../font/pixel/min5.png';\r\nimport min5fontInfo from '../font/pixel/min5.txt';\r\n\r\nimport disabledColorSvg from '../img/disabled-color.svg';\r\n\r\nconst mobile = globals.mobile;\r\n\r\nfunction getPixel(x, y) {\r\n    return globals.chunkManager.getChunkPixel(x, y)\r\n}\r\n\r\nfunction getProtect(x, y) {\r\n    return globals.chunkManager.getProtect(x, y)\r\n}\r\n\r\nfunction isOdd(x, y) {\r\n    return ((x + y) % 2) === 0\r\n}\r\n\r\nfunction getCurCol() {\r\n    if (player.secondCol === -1) {\r\n        return ~player.color ? player.color : -1;\r\n    }\r\n    if (player.color === -1) return player.secondCol;\r\n\r\n    return isOdd(player.x, player.y) ? player.color : player.secondCol\r\n}\r\n\r\nfunction getColByCord(x, y, first = player.color, second = player.secondCol) {\r\n    if (second === -1) return first;\r\n    if (first === -1) return second;\r\n\r\n    return isOdd(x, y) ? first : second\r\n}\r\n\r\nfunction checkBounds(x, y) {\r\n    return (x >= 0 && x < boardWidth && y >= 0 && y < boardHeight)\r\n}\r\n\r\nlet tmLoaded = false;\r\nlet onTMID = setInterval(() => {\r\n    if (globals.toolManager) {\r\n        clearInterval(onTMID);\r\n        _onTmLoaded();\r\n    }\r\n}, 5);\r\nlet tmCallbacks = [];\r\nfunction _onTmLoaded() {\r\n    tmLoaded = true;\r\n    tmCallbacks.forEach(cb => cb(globals.toolManager));\r\n    tmCallbacks = [];\r\n}\r\nfunction onToolManager(cb) {\r\n    if (tmLoaded) cb(globals.toolManager);\r\n    else tmCallbacks.push(cb)\r\n}\r\n\r\nfunction renderFX() {\r\n    globals.fxRenderer.needRender = true;\r\n}\r\n\r\nfunction protectPixels(pixels) {\r\n    globals.socket.sendPixels(pixels, true);\r\n}\r\n\r\nclass Clicker extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this._pendingPixels = {};\r\n        this.minZoom = 2;\r\n\r\n        this.on('down', this.down);\r\n        this.on('up', this.up);\r\n        this.on('move', this.move);\r\n        this.on('leave', this.up);\r\n        this.on('_gesture', this.ongesture);\r\n\r\n        onToolManager(() => {\r\n            // mobile is already subscribed to pointer events\r\n            // so this will duplicate them\r\n            if (!mobile) {\r\n                globals.eventManager.on('mousedown', this.mousedown.bind(this));\r\n                globals.toolManager.on('move', this.move.bind(this));\r\n                globals.eventManager.on('mouseup', this.mouseup.bind(this));\r\n            }\r\n        })\r\n\r\n        this.clrInterval = setInterval(() => {\r\n            if (this.clearPending())\r\n                renderFX();\r\n        }, 250);\r\n\r\n        // pending pixels debug visualizer\r\n        this.fx = new FX(this.render.bind(this));\r\n        //addFX(this.fx);\r\n    }\r\n\r\n    // mouse zone\r\n    mousedown(e) {\r\n        if (e.button !== 0) return;\r\n        this.screenPos = [e.clientX, e.clientY];\r\n    }\r\n    mouseup(e) {\r\n        if (globals.toolManager.tools['mover'].key !== 'LMB') return;\r\n\r\n        if (e.button !== 0 || !this.screenPos) return;\r\n        const dx = Math.abs(e.clientX - this.screenPos[0]);\r\n        const dy = Math.abs(e.clientY - this.screenPos[1]);\r\n        if (dx > 5 || dy > 5) return;\r\n\r\n        const [x, y] = [player.x, player.y];\r\n        const color = getColByCord(x, y);\r\n        if (this.checkPixel(x, y) && ~color)\r\n            placePixel(player.x, player.y, getColByCord(x, y));\r\n    }\r\n    // end of mouse zone\r\n\r\n    down(e) {\r\n        this.lastPos = [player.x, player.y];\r\n        this.screenPos = [e.clientX, e.clientY];\r\n\r\n        if (this.mouseIsDown || camera.zoom < this.minZoom) return;\r\n\r\n        this.mouseIsDown = true;\r\n\r\n        if (!mobile)\r\n            this.emit('move', {});\r\n        else {\r\n            this.pointerId = e.pointerId;\r\n        }\r\n    }\r\n    up(e) {\r\n        if (this.mouseIsDown) {\r\n            if (mobile)\r\n                this.emit('move', e, true);\r\n            this.mouseIsDown = false;\r\n        }\r\n    }\r\n\r\n    ongesture() {\r\n        this.mouseIsDown = false;\r\n        this.lastPos = null;\r\n    }\r\n\r\n    checkPixel(x, y) {\r\n        const key = `${x},${y}`;\r\n        const myColor = getColByCord(x, y);\r\n\r\n        const pixel = getPixel(x, y),\r\n            isProtected = getProtect(x, y);\r\n        if (pixel === myColor || pixel === -1 || (isProtected && me.role < ROLE.TRUSTED)) return;\r\n\r\n        if (this._pendingPixels[key] && this._pendingPixels[key][0] === myColor) return;\r\n        this._pendingPixels[key] = [myColor, Date.now()];\r\n\r\n        return true\r\n    }\r\n\r\n    /*\r\n    */\r\n    move(e, isUp = false) {\r\n        if (e.gesture) {\r\n            // if gesture is started, we reset mousedown state\r\n            this.ongesture();\r\n            return\r\n        }\r\n        if (!this.mouseIsDown ||\r\n            e.gesture ||\r\n            getCurCol() === -1) return;\r\n\r\n        // mobile and same pointerid as at down but also not initiated by 'up' event\r\n        if (mobile && this.pointerId !== e.pointerId)\r\n            return\r\n\r\n        const screenX = e.clientX,\r\n            screenY = e.clientY;\r\n\r\n        const dx = Math.abs(screenX - this.screenPos[0]);\r\n        const dy = Math.abs(screenY - this.screenPos[1]);\r\n\r\n        if (dx < 5 && dy < 5 && !isUp) {\r\n            return;\r\n        }\r\n\r\n        let [x, y] = [player.x, player.y];\r\n\r\n        let line = shapes.line(this.lastPos[0], this.lastPos[1], x, y);\r\n        this.lastPos = [x, y];\r\n\r\n        let circle = [[0, 0]];\r\n        if (player.brushSize !== 1) {\r\n            circle = globals.renderer.preRendered.brush.circle;\r\n        }\r\n\r\n        for (let [x, y] of line) {\r\n            let pixels = [];\r\n\r\n            if (!this.checkAllowance(circle.length)) return;\r\n            circle.forEach(([cx, cy]) => {\r\n                let _x = x + cx;\r\n                let _y = y + cy;\r\n                if (this.checkPixel(_x, _y)) {\r\n                    const myColor = getColByCord(_x, _y); // duplicate\r\n                    pixels.push([_x, _y, myColor]);\r\n                }\r\n            })\r\n\r\n            this.place(pixels);\r\n        }\r\n    }\r\n\r\n    checkAllowance(count) {\r\n        return player.bucket.allowance >= count;\r\n    }\r\n\r\n    place(pixels) {\r\n        if (pixels.length === 0) return;\r\n\r\n        player.bucket.spend(pixels.length)\r\n\r\n        if (pixels.length == 1) {\r\n            placePixel(...pixels[0])\r\n        } else\r\n            placePixels(pixels);\r\n    }\r\n\r\n    render(ctx) {\r\n        const zoom = camera.zoom;\r\n        ctx.lineWidth = zoom / 5;\r\n        ctx.globalAlpha = .5;\r\n\r\n        for (let key of Object.keys(this._pendingPixels)) {\r\n            let [x, y] = key.split(',').map(x => parseInt(x, 10));\r\n\r\n            const color = this._pendingPixels[key][0];\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.fillStyle = hexPalette[color];\r\n\r\n            const [scrX, scrY] = boardToScreenSpace(x, y);\r\n\r\n\r\n            ctx.strokeRect(scrX, scrY, zoom, zoom);\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n\r\n        return 1\r\n    }\r\n\r\n    clearPending() {\r\n        let deletedSome = false;\r\n        Object.keys(this._pendingPixels).forEach(key => {\r\n            let timestamp = this._pendingPixels[key][1];\r\n\r\n            if (Date.now() - timestamp > 500) {\r\n                delete this._pendingPixels[key];\r\n                deletedSome = true;\r\n            }\r\n        })\r\n\r\n        return deletedSome;\r\n    }\r\n}\r\nconst clicker = new Clicker('clicker', 'Space', clickerIcon);\r\n\r\nclass Protector extends Clicker {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.minZoom = 1;\r\n\r\n        // is this unprotector\r\n        this._alt = false;\r\n        // first touch determines whether protect or not (for full down-move-up):\r\n        // protected => unprotect; unprotected => protect,\r\n        // i.e. inverts pixel state\r\n        this._mobileIsProtect = null;\r\n    }\r\n\r\n    getProtectState() {\r\n        if (mobile)\r\n            return this._mobileIsProtect;\r\n        else\r\n            return this._alt ? false : true;\r\n\r\n    }\r\n\r\n    // override Clicker's mouse events\r\n    mousedown() { }\r\n    mouseup() { }\r\n\r\n    down(e) {\r\n        if (this.mouseIsDown) return;\r\n\r\n        super.down(e);\r\n\r\n        showProtected(); // force protect visibility\r\n        this._mobileIsProtect = !getProtect(...this.lastPos);\r\n    }\r\n\r\n    checkPixel(x, y) {\r\n        const key = `${x},${y}`;\r\n        const state = this.getProtectState();\r\n\r\n        const curState = getProtect(x, y);\r\n        if (curState === state) return;\r\n\r\n        if (this._pendingPixels[key] && this._pendingPixels[key][0] === state) return;\r\n        this._pendingPixels[key] = [state, Date.now()];\r\n\r\n        return true\r\n    }\r\n\r\n    checkAllowance() { return true }\r\n\r\n    place(pixels) {\r\n        // now we should replace colors from\r\n        // clicker's move func with protect state\r\n        const state = this.getProtectState();\r\n        pixels.forEach(p => p[2] = state);\r\n        if (!pixels.length) return;\r\n\r\n        protectPixels(pixels);\r\n    }\r\n\r\n    render() { }\r\n}\r\nconst protector = new Protector('protector', 'KeyV', protectIcon, ROLE.MOD);\r\n\r\nconst altProtector = new Protector('alt protector', 'ALT+KeyV', null, ROLE.MOD);\r\naltProtector._alt = true;\r\n\r\nclass Mover extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n\r\n        this.downPos = [0, 0];\r\n\r\n        // time when \"down\" was called\r\n        this.downTime = 0;\r\n\r\n        this.lastPos = [0, 0];\r\n        this.lastPlayerPos = [0, 0];\r\n\r\n        if (!mobile) {\r\n            this.fx = new FX(this.renderCursor);\r\n\r\n            addFX(this.fx);\r\n        }\r\n    }\r\n\r\n    handlers() {\r\n        // \r\n        onToolManager(() => {\r\n            this.on('down', this.down);\r\n            this.on('up', this.up);\r\n            // bind to toolManager for handling not only on canvas\r\n            globals.toolManager.on('move', this.move.bind(this));\r\n            this.on('leave', this.up);\r\n        })\r\n    }\r\n\r\n    renderCursor(ctx) {\r\n        const zoom = camera.zoom;\r\n\r\n        const color = getCurCol();\r\n\r\n        if (~color && zoom > 1) {\r\n            if (player.brushSize == 1) {\r\n                let [x, y] = boardToScreenSpace(player.x, player.y);\r\n                ctx.strokeStyle = hexPalette[color];\r\n                //ctx.fillStyle = hexPalette[player.color];\r\n                ctx.lineWidth = zoom / 5;\r\n\r\n                let w, h;\r\n                let halfLineWid = ctx.lineWidth / 2;\r\n\r\n                x += halfLineWid;\r\n                y += halfLineWid;\r\n\r\n                w = zoom - ctx.lineWidth;\r\n                h = w;\r\n\r\n                //ctx.fillRect(x, y, zoom, zoom);\r\n                ctx.strokeRect(x, y, w + 1, h + 1);\r\n\r\n                //renderFX();\r\n            } else {\r\n                const [x, y] = boardToScreenSpace(player.x - player.brushSize / 2, player.y - player.brushSize / 2);\r\n                ctx.drawImage(globals.renderer.preRendered.brush.canvas, x, y)\r\n            }\r\n        }\r\n\r\n        return 1\r\n    }\r\n\r\n    down(e) {\r\n        if (e.ctrlKey) return;\r\n\r\n        this.mousedown = true;\r\n\r\n        // little workaround to keep any ui text\r\n        // unselected while canvas moves\r\n        // guess it's uneffictive\r\n        changeSelector('#ui>div>*', { 'pointer-events': 'none' })\r\n\r\n        this.downPos = this.lastPos = [e.clientX, e.clientY];\r\n        this.downTime = Date.now();\r\n    }\r\n    up(e) {\r\n        if (e.ctrlKey) return;\r\n\r\n        this.mousedown = false;\r\n        changeSelector('#ui>div>*', { 'pointer-events': 'all' })\r\n\r\n        // long tap to get pixel info\r\n        if (mobile && this.moveThreshold() && !e.gesture) {\r\n            const ela = Date.now() - this.downTime;\r\n            if (ela < 1000) return;\r\n\r\n            pixelInfo.emit('up');\r\n        }\r\n    }\r\n\r\n    move(e) {\r\n        // for template mover\r\n        if (e.ctrlKey) return;\r\n\r\n        // idk what was purpose of this\r\n        // but i actually need to render fx on mobiles\r\n        // if (!mobile) {\r\n        if (this.lastPlayerPos[0] != player.x ||\r\n            this.lastPlayerPos[1] != player.y ||\r\n            this.mousedown) {\r\n            renderFX();\r\n        }\r\n\r\n        this.lastPlayerPos = [player.x, player.y];\r\n        // }\r\n\r\n        if (!this.mousedown) return;\r\n\r\n        this.lastPos = [e.clientX, e.clientY]\r\n        if (!mobile) {\r\n\r\n            if (this.moveThreshold())\r\n                return\r\n        }\r\n\r\n        // now works without pixel ratio, i'll keep it here if not\r\n        camera.moveTo(-e.movementX / camera.zoom /* / devicePixelRatio */, -e.movementY / camera.zoom /* / devicePixelRatio */);\r\n    }\r\n\r\n    moveThreshold() {\r\n        return (Math.abs(this.downPos[0] - this.lastPos[0]) < 5 &&\r\n            Math.abs(this.downPos[1] - this.lastPos[1]) < 5)\r\n    }\r\n}\r\nconst mover = new Mover('mover', 'LMB', moveIcon);\r\n\r\nclass FloodFill extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.on('up', this.up);\r\n        this.on('down', this.down);\r\n        this.on('leave', this.up);\r\n\r\n        this.on('tick', this.tick);\r\n\r\n        this.previewing = false;\r\n        this.fx = null;\r\n        this.prevStack = [];\r\n    }\r\n\r\n    up(e, isCancel) {\r\n        if (this.active) { // stop and return\r\n            this.active = false;\r\n            return\r\n        }\r\n\r\n        if (this.previewing) {\r\n            this.fx.remove();\r\n            renderFX();\r\n            this.previewing = false;\r\n        } else return; // means that key wasn't pressed\r\n\r\n\r\n        if (isCancel)\r\n            return;\r\n\r\n        const cord = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (getColByCord(...cord) === -1 || !inBounds(...cord) || e.type === 'mouseleave') {\r\n            return\r\n        }\r\n\r\n        this.active = true;\r\n\r\n        this.stack = [\r\n            [player.x, player.y]\r\n        ];\r\n\r\n        this.playerCol = player.color;\r\n        this.secondPlayerCol = player.secondCol;\r\n        this.fillingCol = getPixel(player.x, player.y);\r\n    }\r\n\r\n    down(e) {\r\n        // preview floodfill\r\n        if (e.repeat || this.previewing || this.active) {\r\n            return\r\n        }\r\n\r\n        const cord = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (getColByCord(...cord) === -1 || !inBounds(...cord)) {\r\n            return\r\n        }\r\n        let _lastX, _lastY;\r\n\r\n        restart.apply(this);\r\n\r\n        this.showedPixels = [];\r\n        this.fillingCol = getPixel(player.x, player.y);\r\n\r\n        let fx = new FX(tick.bind(this));\r\n        addFX(fx, 0);\r\n\r\n        this.fx = fx;\r\n\r\n        //globals.renderer.needRender = true;\r\n\r\n        this.previewing = true;\r\n\r\n        function restart() {\r\n            this.prevStack = [\r\n                [player.x, player.y]\r\n            ];\r\n            this.showedPixels = [];\r\n\r\n            _lastX = player.x;\r\n            _lastY = player.y;\r\n\r\n            this.playerCol = player.color;\r\n            this.secondPlayerCol = player.secondCol;\r\n            this.fillingCol = getPixel(player.x, player.y);\r\n        }\r\n\r\n        function paint() {\r\n            if (!this.prevStack.length) return 1;\r\n\r\n            let [x, y] = this.prevStack.pop();\r\n\r\n            let color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n            let tileCol = getPixel(x, y);\r\n            let painted = this.showedPixels.indexOf(x + ',' + y) !== -1;\r\n\r\n            if (painted || tileCol === color || tileCol !== this.fillingCol || !inBounds(x, y)) {\r\n                return 0\r\n            }\r\n\r\n            this.showedPixels.push(x + ',' + y);\r\n\r\n            let top = this.checkP(x, y - 1);\r\n            let bottom = this.checkP(x, y + 1);\r\n            let left = this.checkP(x - 1, y);\r\n            let right = this.checkP(x + 1, y);\r\n            if (top && left) {\r\n                this.checkP(x - 1, y - 1);\r\n            }\r\n            if (top && right) {\r\n                this.checkP(x + 1, y - 1);\r\n            }\r\n            if (bottom && left) {\r\n                this.checkP(x - 1, y + 1);\r\n            }\r\n            if (bottom && right) {\r\n                this.checkP(x + 1, y + 1);\r\n            }\r\n\r\n            return 0\r\n        }\r\n\r\n        function tick(ctx) {\r\n            if (globals.mobile && globals.toolManager.tool !== this) {\r\n                this.up({}, true);\r\n                return 1;\r\n            }\r\n            if (player.x != _lastX || player.y != _lastY) {\r\n                restart.call(this);\r\n            }\r\n            if (getCurCol() === -1) return 1;\r\n\r\n            let res = 0;\r\n            for (let i = 0; i < 700 && res == 0; i++)\r\n                res = paint.call(this);\r\n\r\n\r\n            ctx.strokeWidth = camera.zoom;\r\n\r\n            this.showedPixels.forEach((p, i) => {\r\n                let [x, y] = p.split(',').map(x => parseInt(x, 10));\r\n\r\n                let alpha = 1;\r\n                let len = this.showedPixels.length\r\n                if (len >= 100 && i < len / 2) {\r\n                    alpha = 1 - (((len / 2) - i) / (len / 2))\r\n                    if (alpha <= 0) return;\r\n                }\r\n                ctx.globalAlpha = alpha;\r\n\r\n                const color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n                ctx.strokeStyle = hexPalette[color];\r\n\r\n                let [absX, absY] = boardToScreenSpace(x, y);\r\n                ctx.strokeRect(absX, absY, camera.zoom, camera.zoom);\r\n            });\r\n\r\n            return res\r\n        }\r\n    }\r\n\r\n    checkP(x, y) {\r\n        if (getPixel(x, y) !== this.fillingCol) return false;\r\n        this.prevStack.unshift([x, y]);\r\n        return true\r\n    }\r\n\r\n    tick() {\r\n        if (!this.active) return;\r\n\r\n        for (let i = 0; i < 15 && this.stack.length; i++) {\r\n            let nextX = this.stack[this.stack.length - 1][0];\r\n\r\n            if (!player.bucket.spend(1)) break;\r\n\r\n            let [x, y] = this.stack.pop();\r\n\r\n            let color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n            let tileCol = getPixel(x, y);\r\n\r\n            if (tileCol === color || tileCol !== this.fillingCol || !inBounds(x, y)) {\r\n                continue\r\n            }\r\n\r\n            //this.stack.push([x, y]);\r\n\r\n            let top = this.check(x, y - 1);\r\n            let bottom = this.check(x, y + 1);\r\n            let left = this.check(x - 1, y);\r\n            let right = this.check(x + 1, y);\r\n            if (top && left) {\r\n                this.check(x - 1, y - 1);\r\n            }\r\n            if (top && right) {\r\n                this.check(x + 1, y - 1);\r\n            }\r\n            if (bottom && left) {\r\n                this.check(x - 1, y + 1);\r\n            }\r\n            if (bottom && right) {\r\n                this.check(x + 1, y + 1);\r\n            }\r\n\r\n            placePixel(x, y, color);\r\n        }\r\n\r\n        if (!this.stack.length) return this.active = false;\r\n    }\r\n\r\n    check(x, y) {\r\n        if (getPixel(x, y) !== this.fillingCol) return false;\r\n        this.stack.unshift([x, y]);\r\n        return true\r\n    }\r\n}\r\nconst\r\n    floodfill = new FloodFill('floodfill', 'KeyF', floodfillIcon);\r\n\r\nclass Pipette extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        if (mobile) {\r\n            return\r\n            this.on('down', this.mobileDown.bind(this));\r\n            this.on('up', this.mobileUp.bind(this));\r\n        } else\r\n            this.on('down', this.down);\r\n    }\r\n\r\n    down(e) {\r\n        const color = getPixel(player.x, player.y);\r\n\r\n        if (color === -1) return;\r\n\r\n        if (e.__alt)\r\n            player.switchSecondColor(color);\r\n        else\r\n            player.switchColor(color);\r\n\r\n        renderFX();\r\n    }\r\n\r\n    // separate handlers for handling both\r\n    // primary and seconary colors on mobiles\r\n\r\n    // DISABLED FOR THE MOMENT\r\n    // is pipette really need in game\r\n    // with restricted palette .. ?\r\n    mobileDown() {\r\n        this.downCord = [player.x, player.y];\r\n        this.downTime = Date.now();\r\n    }\r\n\r\n    mobileUp() {\r\n        let lastCord = [player.x, player.y];\r\n        let lastTime = Date.now();\r\n\r\n        this.downCord = null;\r\n        this.downTime = null;\r\n    }\r\n}\r\nconst pipette = new Pipette('pipette', 'KeyC', /*pipetteIcon*/);\r\n\r\nconst altPipette = new Pipette('alt pipette', 'ALT+KeyC');\r\naltPipette.off('down', altPipette.down);\r\naltPipette.on('down', (e) => {\r\n    e.__alt = true;\r\n    altPipette.down.call(altPipette, e)\r\n});\r\n\r\nclass Line extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.drawLength = JSON.parse(getOrDefault('drawLineLen', false));;\r\n\r\n        onToolManager(() => {\r\n            this.handlers();\r\n        })\r\n    }\r\n\r\n    handlers() {\r\n        let startCoords, endCoords, lastCoords = [],\r\n            fx, isDown = false,\r\n            line,\r\n            startColor1, startColor2, startCircleSize;\r\n\r\n        function down() {\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            startCoords = [player.x, player.y];\r\n\r\n            [startColor1, startColor2] = [player.color, player.secondCol];\r\n\r\n            startCircleSize = 1;\r\n            if (player.brushSize !== 1) {\r\n                startCircleSize = globals.renderer.preRendered.brush.circle.length;\r\n            }\r\n\r\n            //this.emit('move');\r\n        }\r\n\r\n        function move(e) {\r\n            if (!isDown || !startCoords) return;\r\n            if (e.gesture) {\r\n                isDown = false;\r\n                return startCoords = null;\r\n            };\r\n\r\n            endCoords = [player.x, player.y];\r\n\r\n            if (player.color === -1 && player.secondCol === -1) {\r\n                fx && removeFX(fx);\r\n                return;\r\n            }\r\n            if (endCoords[0] != lastCoords[0] || endCoords[1] != lastCoords[1]) {\r\n                lastCoords = endCoords;\r\n\r\n                const line = buildLine(...startCoords, ...endCoords)\r\n\r\n                fx && removeFX(fx);\r\n                fx = new FX((ctx) => {\r\n                    ctx.globalAlpha = .5;\r\n\r\n                    // draw line pixel by pixel\r\n                    line.forEach(([x, y]) => {\r\n                        const color = getColByCord(x, y);\r\n                        ctx.fillStyle = hexPalette[color];\r\n\r\n                        let [screenX, screenY] = boardToScreenSpace(x, y);\r\n                        ctx.fillRect(screenX, screenY, camera.zoom, camera.zoom);\r\n                    });\r\n\r\n                    // draw (non pixelated) black line over the line\r\n                    ctx.strokeStyle = '#000000';\r\n                    ctx.lineWidth = camera.zoom / 5;\r\n\r\n                    const startScreen = boardToScreenSpace(...line[0]);\r\n                    const endScreen = boardToScreenSpace(...line[line.length - 1]);\r\n\r\n                    ctx.beginPath();\r\n                    ctx.lineCap = 'round'\r\n                    ctx.moveTo(...startScreen.map(z => z += camera.zoom / 2));\r\n                    ctx.lineTo(...endScreen.map(z => z += camera.zoom / 2));\r\n\r\n                    // draw line length text\r\n\r\n                    function angle(cx, cy, ex, ey) {\r\n                        var dy = ey - cy;\r\n                        var dx = ex - cx;\r\n                        var theta = Math.atan2(dy, dx); // range (-PI, PI]\r\n                        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]\r\n                        //if (theta < 0) theta = 360 + theta; // range [0, 360)\r\n                        return theta;\r\n                    }\r\n\r\n                    function toRadians(angle) {\r\n                        return angle * (Math.PI / 180);\r\n                    }\r\n\r\n                    if (this.drawLength && line.length > 1) {\r\n                        let [startPosX, startPosY] = startScreen;\r\n                        let [endPosX, endPosY] = endScreen;\r\n\r\n                        let minX = Math.min(startPosX, endPosX);\r\n                        let minY = Math.min(startPosY, endPosY);\r\n                        let maxX = Math.max(startPosX, endPosX);\r\n                        let maxY = Math.max(startPosY, endPosY);\r\n\r\n                        let [midPosX, midPosY] = [maxX - Math.abs(maxX - minX) / 2, maxY - Math.abs(maxY - minY) / 2];\r\n\r\n                        // append half-pixel offset to center text in the middle\r\n                        midPosX += camera.zoom * 0.5;\r\n                        midPosY += camera.zoom * 0.5;\r\n\r\n                        let lineAngle = angle(startPosX, startPosY, endPosX, endPosY);\r\n                        if (lineAngle > 90) {\r\n                            lineAngle -= 180;\r\n                        } else if (lineAngle < -90) {\r\n                            lineAngle += 180;\r\n                        }\r\n\r\n                        let lineRads = toRadians(lineAngle);\r\n                        let offsetX = 40 * Math.sin(lineRads);\r\n                        let offsetY = 40 * Math.cos(lineRads);\r\n\r\n                        midPosX += offsetX;\r\n                        midPosY -= offsetY;\r\n\r\n\r\n\r\n                        ctx.save();\r\n                        ctx.globalAlpha = .7;\r\n\r\n                        const fontHei = 20//camera.zoom / 1.5;\r\n                        ctx.font = fontHei + 'px sans-serif';\r\n                        ctx.fillStyle = 'black'\r\n                        ctx.strokeStyle = 'white';\r\n\r\n                        ctx.textAlign = 'center';\r\n                        ctx.textBaseline = 'middle';\r\n                        ctx.lineWidth = fontHei / 6;\r\n\r\n                        const text = line.length;\r\n                        const [x, y] = [midPosX, midPosY];\r\n\r\n                        ctx.strokeText(text, x, y);\r\n                        ctx.fillText(text, x, y);\r\n\r\n                        ctx.restore();\r\n                    }\r\n\r\n                    ctx.stroke();\r\n\r\n                    ctx.globalAlpha = 1;\r\n\r\n                    return 1\r\n                })\r\n                addFX(fx)\r\n            }\r\n        }\r\n\r\n        function buildLine(x1, y1, x2, y2) {\r\n            let circle = [[0, 0]];\r\n            if (player.brushSize !== 1) {\r\n                circle = globals.renderer.preRendered.brush.circle;\r\n            }\r\n\r\n            const w = boardWidth;\r\n\r\n            // to not repeat already added pixels\r\n            const placed = new Set();\r\n\r\n            const bruhLinePixels = [];\r\n            const linePixels = shapes.line(x1, y1, x2, y2);\r\n\r\n            // starting from the end and then\r\n            // reversing brushed array will\r\n            // make pixels rendering looking more brush-like\r\n            for (let i = linePixels.length - 1; i >= 0; i--) {\r\n                const [x, y] = linePixels[i]\r\n                circle.forEach(([offX, offY]) => {\r\n                    const absX = x + offX;\r\n                    const absY = y + offY;\r\n\r\n                    const encoded = absX + absY * w;\r\n\r\n                    if (placed.has(encoded)) return;\r\n                    placed.add((encoded));\r\n\r\n                    bruhLinePixels.push([absX, absY]);\r\n                })\r\n            }\r\n\r\n            return bruhLinePixels.reverse();\r\n        }\r\n\r\n        function up() {\r\n            this.off('tick', tick);\r\n\r\n            if (!isDown || !startCoords) return;\r\n            isDown = false;\r\n\r\n            fx && fx.remove();\r\n\r\n            if (!endCoords) endCoords = [player.x, player.y];\r\n\r\n            line = buildLine(...startCoords, ...endCoords);\r\n            startCoords = null;\r\n            endCoords = null;\r\n\r\n            renderFX();\r\n            this.on('tick', tick);\r\n        }\r\n\r\n        function tick() {\r\n            if (player.color === -1 && player.secondCol === -1) {\r\n                // assume player cancelled line\r\n                line = null;\r\n            }\r\n\r\n            let placed = 0;\r\n            while (true) {\r\n                if (!line || !line.length) {\r\n                    this.off('tick', tick);\r\n                    return;\r\n                }\r\n\r\n                const [x, y] = line.pop();\r\n                const col = getColByCord(x, y, startColor1, startColor2);\r\n\r\n                if (col === undefined || col === -1) return this.off('tick', tick);\r\n                if (!checkBounds(x, y) || getPixel(x, y) === col) continue;\r\n\r\n                if (!player.bucket.spend(1)) return line.push([x, y]);\r\n\r\n                placePixel(x, y, col);\r\n                placed++;\r\n                if (placed >= startCircleSize / 2) {\r\n                    return\r\n                }\r\n            }\r\n        }\r\n\r\n        down = down.bind(this);\r\n        move = move.bind(this);\r\n        up = up.bind(this);\r\n\r\n        tick = tick.bind(this);\r\n\r\n        this.on('down', down);\r\n        // TODO maybe it's too many listeners\r\n        // so it'd be good to make some sort of local signal\r\n        // that there was gesture (this listener is only for e.gesture to reset start coords)\r\n        globals.toolManager.on('move', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst line = new Line('line', 'ShiftLeft', lineIcon);\r\n\r\nconst cordAdd = new Tool('coords to chat', 'KeyU');\r\ncordAdd.on('up', function () {\r\n    const cords = $('#coords').text();\r\n    if (!cords.length) return;\r\n    chatInput[0].value += cords + ' ';\r\n    chatInput.trigger('focus');\r\n});\r\n\r\nconst colorSwap = new Tool('swap colors', 'KeyX');\r\ncolorSwap.on('up', player.swapColors.bind(player));\r\n\r\nconst colorDec = new Tool('left color', 'KeyA');\r\ncolorDec.on('down', function () {\r\n    let color = player.color;\r\n    if (--color < 0) color = hexPalette.length - 1;\r\n\r\n    player.switchColor(color);\r\n});\r\n\r\nconst colorInc = new Tool('right color', 'KeyS');\r\ncolorInc.on('down', function () {\r\n    let color = player.color;\r\n    if (++color >= hexPalette.length) color = 0;\r\n\r\n    player.switchColor(color);\r\n});\r\n\r\nconst chatOpac = new Tool('toggle chat', 'KeyK');\r\nchatOpac.on('down', function () {\r\n    toggleChat();\r\n});\r\n\r\nconst menuOpac = new Tool('toggle menu', 'KeyL');\r\nmenuOpac.on('down', function () {\r\n    toggleTopMenu();\r\n});\r\n\r\nconst allOpac = new Tool('toggle everything', 'Semicolon' /* ; */);\r\nallOpac.on('down', function () {\r\n    toggleEverything();\r\n});\r\n\r\nclass CtrlZ extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n    }\r\n\r\n    handlers() {\r\n        let isDown = false;\r\n\r\n        function reset() {\r\n            isDown = false;\r\n\r\n            this.off('tick', tick);\r\n            tickTime = tickMax;\r\n            lastTick = 0;\r\n        }\r\n        reset = reset.bind(this);\r\n\r\n        const down = function (e) {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (e.gesture) {\r\n                return reset();\r\n            }\r\n\r\n            // i know about e.repeat\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            tick();\r\n            this.on('tick', tick);\r\n        }.bind(this);\r\n\r\n        const move = function (e) {\r\n            if (e.gesture) {\r\n                reset();\r\n            }\r\n        }.bind(this);\r\n\r\n        const up = function () {\r\n            reset();\r\n        }.bind(this);\r\n\r\n        const tickMax = 500;\r\n        const tickMin = 50;\r\n\r\n        const nocdMinTick = 2;\r\n        // ticknow = ticknow - (ts / nocdStepFactor)\r\n        // i.e ms passed since last tick divided by this factor\r\n        const nocdStepFactor = 100;\r\n\r\n        const step = 1.5;\r\n        let tickTime = tickMax;\r\n\r\n        let lastTick = 0;\r\n        const tick = function () {\r\n            const ts = Date.now() - lastTick;\r\n            if (ts < tickTime) return;\r\n            let multiTicks = ts / tickTime | 0;\r\n            // when lastTick is 0 (tool is just activated)\r\n            if (multiTicks < 0) multiTicks = 1;\r\n\r\n            lastTick = Date.now();\r\n\r\n            do {\r\n                // if (tickTime <= tickMin) {\r\n                //     if(player.bucket.delay < tickMin){\r\n                //         tickTime = Math.max(nocdMinTick, tickTime-(ts/nocdStepFactor))\r\n                //     }\r\n                // }else{\r\n                //     tickTime /= step;\r\n                // }\r\n\r\n                // instead of speeding up we'll do it only if alt pressed\r\n                const altFactor = globals.toolManager.altDown ? 0.2 : 1;\r\n                tickTime = Math.max(tickTime / step, tickMin * altFactor);\r\n\r\n                if (player.placed.length > player.maxPlaced) {\r\n                    player.placed = player.placed.slice(-player.maxPlaced);\r\n                }\r\n                if (!player.placed.length) return;\r\n                if (!player.bucket.spend(1)) return;\r\n\r\n                const [x, y, c] = player.placed.pop();\r\n\r\n                placePixel(x, y, c, false, true);\r\n            }\r\n            while (--multiTicks)\r\n        }.bind(this);\r\n\r\n        this.on('down', down);\r\n        globals.eventManager.on('mousemove', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst ctrlZ = new CtrlZ('ctrlZ', 'KeyZ', revertIcon);\r\n\r\nclass Grid extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.state = 0;\r\n        this.fx = null;\r\n\r\n        this.pattern = null;\r\n\r\n        camera.on('zoom', () => {\r\n            if (this.state == 1) {\r\n                this.tryRender();\r\n            }\r\n        });\r\n\r\n        this.on('down', this.pressed.bind(this));\r\n        if (JSON.parse(getOrDefault('enableGrid', false))) {\r\n            this.show();\r\n        }\r\n    }\r\n\r\n    pressed(e) {\r\n        if (e.repeat) return;\r\n        this.toggle();\r\n    }\r\n\r\n    /**@param {CanvasRenderingContext2D} ctx*/\r\n    drawGrid(ctx) {\r\n        let [x, y] = screenToBoardSpace(0, 0),\r\n            [clientX, clientY] = boardToScreenSpace(x, y);\r\n\r\n        let { width, height } = ctx.canvas;\r\n        const zoom = camera.zoom;\r\n\r\n\r\n        ctx.fillStyle = 'rgb(127,127,127)';\r\n\r\n        // make grid fade out from zoom 16 to 5 (lower than 5 is invisible)\r\n        const calculatedAlpha = zoom > 16 ? 0.5 : mapRange(zoom, 24, 5, 0.5, 0);\r\n        ctx.globalAlpha = calculatedAlpha;\r\n\r\n        let thickInterval;\r\n        if (chunkSize % 16 == 0) thickInterval = 16;\r\n        else if (chunkSize % 10 == 0) thickInterval = 10;\r\n        else thickInterval = null;\r\n\r\n        // finally, i decided to disable this feature\r\n        thickInterval = null;\r\n\r\n        let wid = 1;\r\n\r\n        // kostyl\r\n        x--; y--;\r\n\r\n        // pixels lines\r\n        for (; clientX < width; clientX += zoom) {\r\n            x++\r\n            if (x % thickInterval == 0) wid = 1;\r\n            else wid = 1;\r\n\r\n            if (x % chunkSize == 0) wid = 1;\r\n\r\n            ctx.fillRect(clientX | 0, 0, wid, height);\r\n        }\r\n\r\n        for (; clientY < height; clientY += zoom) {\r\n            y++\r\n            if (y % thickInterval == 0) wid = 1;\r\n            else wid = 1;\r\n\r\n            if (y % chunkSize == 0) wid = 1;\r\n\r\n            ctx.fillRect(0, clientY | 0, width, wid);\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n    }\r\n\r\n    tryRender() {\r\n        if (!this.fx || this.fx.removed) {\r\n            this.fx = new FX(this.render.bind(this));\r\n            addFX(this.fx, 2);\r\n        }\r\n    }\r\n\r\n    toggle() {\r\n        if (this.state == 0) this.show();\r\n        else this.hide();\r\n        setLS('enableGrid', (!!this.state).toString())\r\n    }\r\n\r\n    show() {\r\n        this.state = 1;\r\n        this.tryRender();\r\n    }\r\n\r\n    hide() {\r\n        this.state = 0;\r\n        this.fx && removeFX(this.fx);\r\n    }\r\n\r\n    render(ctx) {\r\n        if (camera.zoom <= 5) return 1;\r\n\r\n        this.drawGrid(ctx);\r\n    }\r\n}\r\nconst grid = new Grid('grid', 'KeyG');\r\n\r\n// WARNING: it's not supposed to be a bot\r\n// so it won't check for connection or re-check image\r\n// write your own bots please \r\nclass Paste extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        // 0 - idle\r\n        // 1 - choosing\r\n        // 2 - placing\r\n        // 3 - drawing\r\n        this.state = 0;\r\n\r\n        this.moveFX = null;\r\n        this.drawInterval = null;\r\n\r\n        this.lastClipboardEvent = {\r\n            ev: null,\r\n            date: null\r\n        }\r\n\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    async down() {\r\n        if (this.state === 0 || this.state === 1) {\r\n            this.state = 1;\r\n\r\n            // in case 'Paste' event launched later\r\n            await sleep(100);\r\n\r\n            try {\r\n                let whichOne = 'file';\r\n                if (this.isImagePasted()) {\r\n                    whichOne = await this.promptClipboardOrFile();\r\n                }\r\n\r\n                let canvas;\r\n                if (whichOne === 'clip') {\r\n                    canvas = await this.getClipboardImage(this.lastClipboardEvent.ev);\r\n                } else if (whichOne === 'file') {\r\n                    canvas = await this.askFileImage();\r\n                }\r\n                if (canvas)\r\n                    this.startPlace(canvas);\r\n\r\n                this.lastClipboardEvent.ev = null;\r\n                this.lastClipboardEvent.date = null;\r\n            } finally {\r\n                this.state = 0;\r\n            }\r\n        } else if (this.state == 2) {\r\n            // this.state = 0\r\n            // this.stopPlace();\r\n        } else if (this.state == 3) {\r\n            this.state = 0;\r\n            this.stopDraw();\r\n        }\r\n    }\r\n\r\n    async promptClipboardOrFile() {\r\n        return new Promise((res, rej) => {\r\n            try {\r\n                const btns = [{\r\n                    text: t('from_clipboard'),\r\n                    id: 'clip'\r\n                },\r\n                {\r\n                    text: t('from_file'),\r\n                    id: 'file'\r\n                }];\r\n\r\n                const win = new SelectMiniWindow(btns, res, t('paste.choose_from'));\r\n                document.body.appendChild(win.element[0]);\r\n\r\n                win.center();\r\n            } catch (error) {\r\n                rej(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    isImagePasted() {\r\n        const lastEv = this.lastClipboardEvent;\r\n        if (!lastEv.images || Date.now() - lastEv.date > 1000) return false;\r\n        return true;\r\n    }\r\n\r\n    async getClipboardImage() {\r\n        const { images } = this.lastClipboardEvent;\r\n        if (!images?.length) return null;\r\n        return await this.readCanvasFromFile(images[0]);\r\n    }\r\n\r\n    async askFileImage() {\r\n        // get file from system\r\n        const input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.accept = 'image/png';\r\n\r\n        input.click();\r\n\r\n        return new Promise((res, rej) => {\r\n            input.onchange = () => {\r\n                input.onchange = null;\r\n\r\n                if (!input.files.length || input.files[0] == \"\") {\r\n                    return rej();\r\n                }\r\n\r\n                // read first file with filereader\r\n                this.readCanvasFromFile(input.files[0])\r\n                    .then(res)\r\n                    .catch(rej);\r\n            }\r\n        })\r\n    }\r\n\r\n    readCanvasFromFile(file) {\r\n        return new Promise((res, rej) => {\r\n            const reader = new FileReader();\r\n            reader.readAsDataURL(file);\r\n\r\n            reader.onload = () => {\r\n                const img = new Image();\r\n                img.src = reader.result;\r\n                img.onload = () => {\r\n                    // draw image on canvas to get its data\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = img.width;\r\n                    canvas.height = img.height;\r\n\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n\r\n                    res(canvas);\r\n                }\r\n                img.onerror = rej;\r\n            }\r\n            reader.onerror = rej;\r\n        })\r\n    }\r\n\r\n    startPlace(canvas, protectMask = null) {\r\n        if (protectMask && protectMask.length !== canvas.width * canvas.height) {\r\n            throw new Error('protect mask length mismatch');\r\n        }\r\n\r\n        player.suspendColors();\r\n        this.state = 2;\r\n\r\n        let xPos = player.x,\r\n            yPos = player.y;\r\n\r\n        function render(ctx) {\r\n            const [x, y] = boardToScreenSpace(xPos, yPos);\r\n            const z = camera.zoom;\r\n\r\n            const opacity = mapRange(Math.sin(Date.now() / 400), -1, 1, 0.5, 1);\r\n            ctx.globalAlpha = opacity;\r\n\r\n            ctx.save();\r\n            ctx.scale(z, z);\r\n            ctx.drawImage(canvas, x / z, y / z);\r\n            ctx.restore();\r\n\r\n            ctx.globalAlpha = 1;\r\n            return 0\r\n        }\r\n\r\n        const fx = this.moveFX = new FX(render);\r\n        addFX(fx);\r\n\r\n        function move() {\r\n            let newX = player.x,\r\n                newY = player.y;\r\n            if (newX == xPos && newY == yPos)\r\n                return;\r\n\r\n            xPos = newX;\r\n            yPos = newY;\r\n        }\r\n\r\n        let lastX, lastY;\r\n        let down = function (e) {\r\n            lastX = e.clientX;\r\n            lastY = e.clientY;\r\n        }\r\n\r\n        let up = function (e) {\r\n            if (e.button == 2) {\r\n                this.state = 0;\r\n                this.stopPlace(); off();\r\n                return;\r\n            };\r\n\r\n            let [x, y] = [e.clientX, e.clientY];\r\n            if (Math.abs(x - lastX) > 5 || Math.abs(y - lastY) > 5) return;\r\n\r\n            off();\r\n            player.restoreColors();\r\n\r\n            this.stopPlace();\r\n            this.startDraw(canvas, xPos, yPos, protectMask);\r\n        }\r\n        up = up.bind(this);\r\n\r\n        function off() {\r\n            globals.eventManager.off('mousedown', down);\r\n            globals.eventManager.off('mouseup', up);\r\n            globals.toolManager.off('move', move);\r\n        }\r\n\r\n        globals.eventManager.on('mousedown', down);\r\n        globals.eventManager.on('mouseup', up);\r\n        globals.toolManager.on('move', move);\r\n    }\r\n\r\n    stopPlace() {\r\n        removeFX(this.moveFX);\r\n        this.removeAllListeners('move');\r\n    }\r\n\r\n    startDraw(canvas, startX, startY, protectMask = null) {\r\n        this.state = 3;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        const { width: w } = canvas;\r\n\r\n        let imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\r\n        let offset = -4;\r\n\r\n        const isMod = me.role >= ROLE.MOD;\r\n\r\n        function draw() {\r\n            let allowance = Math.floor(player.bucket.allowance);\r\n            if (allowance == 0) return;\r\n\r\n            let pixels = [], protectPixels = [];\r\n\r\n            let max = 13106;\r\n            if (getLS('ya', false) === 'polkovnik') {\r\n                max = 52441;\r\n            }\r\n            while (allowance > 0 && offset < imgdata.length - 4 && pixels.length < max && protectPixels.length < max) {\r\n                offset += 4;\r\n\r\n                let rgba = [\r\n                    imgdata[offset],\r\n                    imgdata[offset + 1],\r\n                    imgdata[offset + 2],\r\n                    imgdata[offset + 3],\r\n                ]\r\n\r\n                if (rgba[3] < 127) continue;\r\n\r\n                let off = offset / 4;\r\n                const offX = off % w,\r\n                    offY = off / w | 0;\r\n\r\n                const boardX = startX + offX,\r\n                    boardY = startY + offY;\r\n                if (boardX < 0 || boardX >= boardWidth ||\r\n                    boardY < 0 || boardY >= boardHeight)\r\n                    continue\r\n\r\n                if (isMod && protectMask) {\r\n                    const protectedState = protectMask[offX + offY * w];\r\n                    protectPixels.push([boardX, boardY, protectedState]);\r\n                }\r\n\r\n\r\n                const color = closestColor(rgba, palette);\r\n                const oldCol = globals.chunkManager.getChunkPixel(boardX, boardY);\r\n                if (oldCol == color) continue;\r\n\r\n                allowance--;\r\n\r\n                pixels.push([boardX, boardY, color]);\r\n            }\r\n\r\n            if (pixels.length) {\r\n                player.bucket.spend(pixels.length);\r\n                globals.socket.sendPixels(pixels);\r\n                if (protectPixels.length) {\r\n                    globals.socket.sendPixels(protectPixels, true);\r\n                }\r\n            }\r\n\r\n            if (offset >= imgdata.length - 4) {\r\n                this.state = 0;\r\n                this.stopDraw();\r\n            }\r\n        }\r\n\r\n        this.drawInterval = setInterval(draw.bind(this), 50);\r\n    }\r\n\r\n    stopDraw() {\r\n        clearInterval(this.drawInterval);\r\n    }\r\n}\r\nconst paste = new Paste('paste', 'CTRL+KeyV', null, ROLE.MOD);\r\ndocument.addEventListener('paste', (ev) => {\r\n    // paste event does not work for other than ctrl+v\r\n    // so skip in case some another tool assigned for this key\r\n    // (check your sanity if you do :D)\r\n    if (paste.key !== 'CTRL+KeyV') return;\r\n\r\n    const images = [];\r\n    for (const item of ev.clipboardData.items) {\r\n        if (item.type.startsWith('image/')) {\r\n            images.push(item.getAsFile());\r\n        }\r\n    }\r\n\r\n    if (images.length) {\r\n        paste.lastClipboardEvent = {\r\n            images,\r\n            date: Date.now()\r\n        };\r\n    }\r\n})\r\n\r\n// TODO move it to config or globals\r\nlet tempOpacity = parseFloat(getOrDefault('template.opacity', 0.5, true));\r\nconst templateOp1 = new Tool('template 0/N opaq', 'KeyO');\r\ntemplateOp1.on('down', () => {\r\n    if (template.opacity == 0) {\r\n        template.opacity = tempOpacity;\r\n    } else {\r\n        tempOpacity = template.opacity\r\n        template.opacity = 0;\r\n    }\r\n    updateTemplate();\r\n});\r\n\r\nconst templateOp2 = new Tool('template 1/N opaq', 'KeyP');\r\ntemplateOp2.on('down', () => {\r\n    if (template.opacity == 1) {\r\n        template.opacity = tempOpacity;\r\n    } else {\r\n        tempOpacity = template.opacity\r\n        template.opacity = 1;\r\n    }\r\n    updateTemplate();\r\n});\r\n\r\nclass Square extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n    }\r\n\r\n    handlers() {\r\n        let startCoords, endCoords, lastCoords = [],\r\n            fx, isDown = false,\r\n            square,\r\n            color, color2;\r\n\r\n        function down() {\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            startCoords = [player.x, player.y];\r\n\r\n            [color, color2] = [player.color, player.secondCol];\r\n\r\n            this.emit('move');\r\n        }\r\n\r\n        function move() {\r\n            if (!isDown || !startCoords) return;\r\n\r\n            endCoords = [player.x, player.y];\r\n\r\n            if (endCoords[0] != lastCoords[0] || endCoords[1] != lastCoords[1]) {\r\n                lastCoords = endCoords;\r\n\r\n                const pixels = shapes.square(...startCoords, ...endCoords)\r\n\r\n                fx && removeFX(fx);\r\n                fx = new FX((ctx) => {\r\n                    ctx.globalAlpha = .5;\r\n\r\n                    for (let [x, y] of pixels) {\r\n                        const [sx, sy] = boardToScreenSpace(x, y);\r\n                        const color = getColByCord(x, y);\r\n                        ctx.fillStyle = hexPalette[color];\r\n                        ctx.fillRect(sx, sy, camera.zoom, camera.zoom);\r\n                    }\r\n\r\n                    ctx.globalAlpha = 1;\r\n\r\n                    return 1\r\n                })\r\n                addFX(fx)\r\n            }\r\n        }\r\n\r\n        function up() {\r\n            this.off('tick', tick);\r\n            isDown = false;\r\n\r\n            if (!startCoords) return;\r\n\r\n            fx && fx.remove();\r\n\r\n            if (!endCoords) endCoords = [player.x, player.y];\r\n\r\n            square = shapes.square(...startCoords, ...endCoords);\r\n\r\n            renderFX();\r\n\r\n            if (square.length <= 1) return;\r\n            this.on('tick', tick);\r\n        }\r\n\r\n        function tick() {\r\n            let infCd = (player.bucket.allowance === Infinity);\r\n\r\n            if (!this.lastTick) this.lastTick = Date.now();\r\n\r\n            if (infCd && Date.now() - this.lastTick < 50) return;\r\n            this.lastTick = Date.now();\r\n\r\n            //   0\r\n            let counter = 0;\r\n            let toSend = [];\r\n            while (counter < 1000) {\r\n                if (!square || !square.length) {\r\n                    this.off('tick', tick);\r\n                    break;\r\n                }\r\n\r\n                const [x, y] = square.pop();\r\n                const col = getColByCord(x, y, color, color2);\r\n\r\n                if (col === undefined || col === -1) return this.off('tick', tick);\r\n                if (!checkBounds(x, y)) continue;\r\n                if (getPixel(x, y) === col) continue;\r\n                if (!player.bucket.spend(1)) return square.push([x, y]);\r\n\r\n                counter++;\r\n\r\n                if (infCd) {\r\n                    toSend.push([x, y, col]);\r\n                } else {\r\n                    placePixel(x, y, col);\r\n                }\r\n            }\r\n\r\n            if (toSend.length) {\r\n                placePixels(toSend, true);\r\n            }\r\n        }\r\n\r\n        down = down.bind(this);\r\n        move = move.bind(this);\r\n        up = up.bind(this);\r\n\r\n        tick = tick.bind(this);\r\n\r\n        this.on('down', down);\r\n        this.on('move', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst square = new Square('square', 'KeyJ');\r\n\r\nconst incBrush = new Tool('+brush size', 'BracketRight'); // [\r\nincBrush.on('down', () => {\r\n    if (player.brushSize >= 100) return;\r\n    if (player.brushSize == 1) return updateBrush(4);\r\n    updateBrush(player.brushSize + 2);\r\n});\r\n\r\nconst decBrush = new Tool('-brush size', 'BracketLeft'); // ]\r\ndecBrush.on('down', () => {\r\n    if (player.brushSize <= 4) return updateBrush(1);\r\n    updateBrush(player.brushSize - 2);\r\n})\r\n\r\nclass Copy extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        // 0 - idle\r\n        // 1 - started selection\r\n        this.state = 0;\r\n\r\n        this.selectFX = null;\r\n\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    down(e) {\r\n        if (this.state > 0 || paste.state > 0)\r\n            return\r\n\r\n        // since default key is ctrl+c\r\n        const isTextSelected = (window.getSelection().type === 'Range');\r\n        if (isTextSelected) return;\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        camera.disableMove();\r\n        player.suspendColors();\r\n        mainCanvas.css('cursor', 'crosshair');\r\n\r\n        this.state = 1;\r\n\r\n        let fx;\r\n        let startX, startY, endX, endY;\r\n\r\n        let altPressed = false,\r\n            lassoMode = false,\r\n            lassoPoints = [];\r\n        function keydown(e) {\r\n            if (e.key === 'Alt')\r\n                altPressed = true;\r\n        }\r\n        // function keyup(e) {\r\n        //     // tf is this ... ???\r\n        //     if (e.key === 'Alt')\r\n        //         altPressed = false;\r\n        // }\r\n\r\n        function mousedown() {\r\n            if (altPressed) {\r\n                lassoMode = true;\r\n                lassoPoints = [[player.x, player.y]];\r\n            } else {\r\n                startX = player.x;\r\n                startY = player.y;\r\n            }\r\n        }\r\n        function mousemove() {\r\n            if (lassoMode) {\r\n                let x = player.x,\r\n                    y = player.y;\r\n\r\n                lassoPoints.push([x, y]);\r\n            } else {\r\n                endX = player.x + 1;\r\n                endY = player.y + 1;\r\n            }\r\n        }\r\n        function mouseup() {\r\n            // area is selected and we can tell Paste tool to draw it\r\n            mainCanvas.css('cursor', '');\r\n\r\n            removeFX(fx);\r\n\r\n            globals.eventManager.off('keydown', keydown);\r\n            // globals.eventManager.off('keyup', keyup);\r\n            globals.eventManager.off('mousedown', mousedown);\r\n            globals.eventManager.off('mousemove', mousemove);\r\n            globals.eventManager.off('mouseup', mouseup);\r\n\r\n            this.state = 0;\r\n\r\n            camera.enableMove();\r\n            player.restoreColors();\r\n\r\n            onSelected();\r\n        }\r\n\r\n        function render(ctx) {\r\n            ctx.save();\r\n\r\n            ctx.strokeStyle = 'gray';\r\n            ctx.lineWidth = 2;\r\n            ctx.setLineDash([3, 3]);\r\n            ctx.globalAlpha = 1;\r\n\r\n            if (lassoMode) {\r\n                ctx.beginPath();\r\n                const firstCord = boardToScreenSpace(lassoPoints[0][0], lassoPoints[0][1]);\r\n                ctx.moveTo(...firstCord);\r\n                for (let i = 1; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    ctx.lineTo(...boardToScreenSpace(...point))\r\n                }\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n            } else {\r\n                const [x1, y1] = boardToScreenSpace(startX, startY);\r\n                const [x2, y2] = boardToScreenSpace(endX, endY);\r\n                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);\r\n            }\r\n\r\n            ctx.restore();\r\n            return 1\r\n        }\r\n        fx = new FX(render);\r\n        addFX(fx);\r\n\r\n        keydown = keydown.bind(this);\r\n        // keyup = keyup.bind(this);\r\n        mousedown = mousedown.bind(this);\r\n        mousemove = mousemove.bind(this);\r\n        mouseup = mouseup.bind(this);\r\n\r\n        globals.eventManager.on('keydown', keydown);\r\n        // globals.eventManager.on('keyup', keyup);\r\n        globals.eventManager.on('mousedown', mousedown);\r\n        globals.eventManager.on('mousemove', mousemove);\r\n        globals.eventManager.on('mouseup', mouseup);\r\n\r\n\r\n        function onSelected() {\r\n            let minX, maxX, minY, maxY;\r\n            if (lassoMode) {\r\n                minX = maxX = lassoPoints[0][0];\r\n                minY = maxY = lassoPoints[0][1];\r\n                for (let i = 0; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    if (point[0] < minX)\r\n                        minX = point[0];\r\n                    if (point[0] > maxX)\r\n                        maxX = point[0];\r\n                    if (point[1] < minY)\r\n                        minY = point[1];\r\n                    if (point[1] > maxY)\r\n                        maxY = point[1];\r\n                }\r\n            } else {\r\n                if ([startX, startY, endX, endY].some(x => x === undefined))\r\n                    return;\r\n\r\n                minX = Math.min(startX, endX);\r\n                maxX = Math.max(startX, endX) + 1;\r\n                minY = Math.min(startY, endY);\r\n                maxY = Math.max(startY, endY) + 1;\r\n            }\r\n\r\n            // normalize coordinates\r\n            minX = Math.max(minX, 0);\r\n            maxX = Math.min(maxX, boardWidth);\r\n            minY = Math.max(minY, 0);\r\n            maxY = Math.min(maxY, boardHeight);\r\n\r\n            const w = maxX - minX;\r\n            const h = maxY - minY;\r\n\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n\r\n            const ctx = canvas.getContext('2d');\r\n            const data = ctx.createImageData(w, h);\r\n            const protectMask = new Uint8Array(w * h);\r\n\r\n            // poly x coordinates and y coordinates arrays\r\n            let vertx, verty;\r\n            if (lassoMode) {\r\n                vertx = new Array(lassoPoints.length);\r\n                verty = new Array(lassoPoints.length);\r\n\r\n                for (let i = 0; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    vertx[i] = point[0];\r\n                    verty[i] = point[1];\r\n                }\r\n            }\r\n\r\n            // local canvas coordinates\r\n            for (let x = 0; x < w; x++) {\r\n                for (let y = 0; y < h; y++) {\r\n                    const i = (x + y * w) * 4;\r\n\r\n                    // absolute board coordinates\r\n                    const absX = minX + x;\r\n                    const absY = minY + y;\r\n\r\n                    if (lassoMode && !testPointInPolygon(lassoPoints.length, vertx, verty, absX, absY)) {\r\n                        continue\r\n                    }\r\n\r\n\r\n                    const isProtected = globals.chunkManager.getProtect(absX, absY);\r\n                    protectMask[i / 4] = isProtected;\r\n\r\n                    const colId = globals.chunkManager.getChunkPixel(absX, absY);\r\n                    const col = palette[colId];\r\n\r\n                    data.data[i] = col[0];\r\n                    data.data[i + 1] = col[1];\r\n                    data.data[i + 2] = col[2];\r\n                    data.data[i + 3] = 255;\r\n                }\r\n            }\r\n\r\n            ctx.putImageData(data, 0, 0);\r\n\r\n            // let the Paste tool do other stuff\r\n            paste.startPlace(canvas, protectMask);\r\n        }\r\n    }\r\n}\r\nconst copy = new Copy('copy', 'CTRL+KeyC', null, ROLE.MOD);\r\n\r\nconst pixelInfo = new Tool('pixel info', 'KeyI');\r\n\r\nlet last = null, pinfoFx = null\r\nfunction removeLast() {\r\n    if (last) {\r\n        last.remove();\r\n        last = null;\r\n    }\r\n    if (pinfoFx) {\r\n        pinfoFx.remove();\r\n        pinfoFx = null;\r\n    }\r\n}\r\nglobals.eventManager.on('mouseup', removeLast);\r\n\r\npixelInfo.on('up', async () => {\r\n    removeLast()\r\n\r\n    const [x, y] = [player.x, player.y];\r\n\r\n    const resp = await apiRequest(`/pixelInfo?canvas=${canvasId}&x=${x}&y=${y}`);\r\n    const data = await resp.json();\r\n    if (!data || !data.type) return;\r\n\r\n    const el = $('<div class=\"infoBubble\"><span style=\"user-select:text\"></span></div>');\r\n    last = el;\r\n\r\n    const coordsLegend = $('<div>');\r\n    coordsLegend[0].style.cssText =\r\n        `position: absolute;\r\n    top: -7px;\r\n    left: 0;\r\n    width: 100%;\r\n    font-size: 14px;\r\n    font-weight: bold;\r\n    text-shadow: rgb(255 255 255) -1px 1px 0px, rgb(255 255 255) 1px 1px 0px, rgb(255 255 255) 1px -1px 0px, rgb(255 255 255) -1px -1px 0px;\r\n    text-align: center;`\r\n    coordsLegend.text(`(${x}, ${y})`)\r\n\r\n    el.append(coordsLegend);\r\n\r\n    let text = '';\r\n\r\n    if (data.type === 'UID') {\r\n        const sanitizedName = htmlspecialchars(data.placer.nick);\r\n\r\n        text += '<b>UID</b>&nbsp;' + data.placer.id + '<br>',\r\n            text += '<b>name</b>&nbsp;' + sanitizedName;\r\n    } else {\r\n        text += `<b>${data.type}</b>`;\r\n        if (data.placer) {\r\n            text += '&nbsp;' + data.placer\r\n        }\r\n    }\r\n\r\n    $('span', el).html(text);\r\n\r\n    $('body').append(el);\r\n\r\n    const w = el[0].clientWidth;\r\n    const h = el[0].clientHeight;\r\n\r\n    function fixPos() {\r\n        const [clientX, clientY] = boardToScreenSpace(x, y);\r\n        const posX = clientX + (camera.zoom / 2) - (w / 2)\r\n        const posY = clientY - h - 11;\r\n\r\n        el.css('top', posY).css('left', posX);\r\n\r\n        return 1;\r\n    }\r\n    fixPos();\r\n\r\n\r\n    pinfoFx = new FX(() => {\r\n        fixPos();\r\n    })\r\n    addFX(pinfoFx, 2);\r\n});\r\n\r\nexport class PixelFont {\r\n    static defaultVSpacing = 1;\r\n\r\n    constructor(imagePath, infoPath) {\r\n        this.imagePath = imagePath;\r\n        this.infoPath = infoPath;\r\n\r\n        this.defaultWidth = null;\r\n        this.defaultHeight = null;\r\n        this.letters = {};\r\n\r\n        this.loaded = false;\r\n        this._isLoading = false;\r\n    }\r\n\r\n    async load() {\r\n        if (this._isLoading) return;\r\n        this._isLoading = true;\r\n\r\n        try {\r\n            const fontCanvas = await new Promise((res, rej) => {\r\n                const img = new Image();\r\n\r\n                img.onload = () => {\r\n                    const canvas = document.createElement('canvas');\r\n\r\n                    canvas.width = img.width;\r\n                    canvas.height = img.height;\r\n\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n\r\n                    res(canvas);\r\n                }\r\n\r\n                img.onerror = rej;\r\n\r\n                img.src = this.imagePath;\r\n            })\r\n\r\n            const fontInfoResp = await fetch(this.infoPath);\r\n            const fontInfo = await fontInfoResp.json();\r\n\r\n            const defaultWidth = fontInfo.defaultWidth;\r\n            this.defaultWidth = defaultWidth;\r\n            const height = fontInfo.fixedHeight;\r\n            this.defaultHeight = height;\r\n\r\n            const fontCanvasCtx = fontCanvas.getContext('2d');\r\n            this.letters = {};\r\n\r\n            let offsetX = 0;\r\n            for (let letter of fontInfo.letters) {\r\n                const {\r\n                    letter: letterSymbol,\r\n                    width = defaultWidth\r\n                } = letter;\r\n\r\n                const slice = fontCanvasCtx.getImageData(offsetX, 0, width, height);\r\n                this.letters[letterSymbol] = slice;\r\n\r\n                // extra 1 because it's one white pixel before each next letter\r\n                offsetX += width + 1;\r\n            }\r\n        } catch (error) {\r\n            this._isLoading = false;\r\n            throw error\r\n        }\r\n\r\n        this._isLoading = false;\r\n        this.loaded = true;\r\n    }\r\n\r\n    drawText(text, color = 'black') {\r\n        if (!this.loaded) throw new Error('font not loaded');\r\n\r\n        text = text.toUpperCase();\r\n\r\n        const {\r\n            width: textWidth,\r\n            height: textHeight\r\n        } = this.measureText(text);\r\n\r\n        if (textWidth == 0 || textHeight == 0) {\r\n            return null;\r\n        }\r\n\r\n        const colorCanvas = document.createElement('canvas');\r\n        const textCanvas = document.createElement('canvas');\r\n\r\n        colorCanvas.width = textCanvas.width = textWidth;\r\n        colorCanvas.height = textCanvas.height = textHeight;\r\n\r\n        const colorCanvasCtx = colorCanvas.getContext('2d');\r\n        const textCanvasCtx = textCanvas.getContext('2d');\r\n\r\n        const textLetters = text.split('');\r\n        let cursorX = 0, cursorY = 0;\r\n        for (let letter of textLetters) {\r\n            if (letter == '\\n') {\r\n                cursorY += this.defaultHeight + PixelFont.defaultVSpacing;\r\n                cursorX = 0;\r\n                continue\r\n            }\r\n\r\n            if (letter == ' ') {\r\n                cursorX += this.defaultWidth;\r\n                continue\r\n            }\r\n\r\n            let letterImData = this.letters[letter];\r\n            if (!letterImData) {\r\n                cursorX += this.defaultWidth;\r\n                continue\r\n            }\r\n\r\n            textCanvasCtx.putImageData(letterImData, cursorX, cursorY);\r\n            cursorX += letterImData.width + 1; // 1 is the constant spacing\r\n        }\r\n\r\n        // first, we draw text canvas shaped, colored rect \r\n        // then we will put the text on top of it, using\r\n        // globalComposite property.\r\n        // this will keep only those pixels of colored rect, in which\r\n        // letters are. this will \"color\" the letters in the color of the rect\r\n        colorCanvasCtx.fillStyle = color;\r\n        colorCanvasCtx.fillRect(0, 0, textWidth, textHeight);\r\n\r\n        colorCanvasCtx.globalCompositeOperation = 'destination-atop';\r\n        colorCanvasCtx.drawImage(textCanvas, 0, 0);\r\n\r\n        return colorCanvas;\r\n    }\r\n\r\n    measureText(text) {\r\n        if (!this.loaded) throw new Error('font not loaded');\r\n\r\n        text = text.toUpperCase();\r\n\r\n        const textLetters = text.split('');\r\n        let curWidth = 0, maxWidth = 0, height = this.defaultHeight;\r\n\r\n        for (let letter of textLetters) {\r\n            if (letter == '\\n') {\r\n                height += this.defaultHeight + PixelFont.defaultVSpacing;\r\n                maxWidth = Math.max(curWidth, maxWidth);\r\n                curWidth = 0;\r\n                continue\r\n            }\r\n\r\n            if (letter == ' ') {\r\n                curWidth += this.defaultWidth;\r\n                continue\r\n            }\r\n\r\n            if (this.letters[letter]) {\r\n                curWidth += (this.letters[letter].width || this.defaultWidth) + 1;\r\n            }\r\n        }\r\n\r\n        return {\r\n            width: Math.max(curWidth, maxWidth), height\r\n        }\r\n    }\r\n}\r\n\r\nclass Text extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.fonts = [\r\n            new PixelFont(min5fontSheet, min5fontInfo)\r\n        ];\r\n        this.fonts.forEach(f => f.load());\r\n\r\n        this.miniWindow = null;\r\n\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    down(e) {\r\n        if (this.miniWindow && !this.miniWindow.closed) return;\r\n\r\n        globals.lockInputs = true;\r\n\r\n        this.miniWindow = new MiniWindow('Draw text', 2);\r\n        const winEl = this.miniWindow.element;\r\n        if (mobile) {\r\n            winEl.css('left', 0).css('top', 0);\r\n        } else {\r\n            winEl.css('left', window.screen.width / 3).css('top', window.screen.height / 3);\r\n        }\r\n\r\n        const innerHtml = $(`\r\n            <textarea style=\"width: 100%;\"></textarea>\r\n            <div style=\"display:flex; margin: 2px 0\">\r\n                <div style=\"display: flex\">\r\n                    <div>x:</div> <input type=\"number\" class=\"textXCord\" style=\"width: 100%\">\r\n                </div>\r\n                <div style=\"display: flex; margin-left: 2px\">\r\n                    <div>y:</div> <input type=\"number\" class=\"textYCord\" style=\"width: 100%\">\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        this.miniWindow.bodyElement.css('max-width', 200).css('display', 'flex').css('flex-direction', 'column');\r\n        this.miniWindow.bodyElement.append(innerHtml);\r\n        document.body.appendChild(winEl[0]);\r\n\r\n        const textInput = $('textarea', this.miniWindow.bodyElement);\r\n        const xCordInput = $('.textXCord', this.miniWindow.bodyElement);\r\n        const yCordInput = $('.textYCord', this.miniWindow.bodyElement);\r\n\r\n        const lastCord = [player.x, player.y];\r\n        xCordInput.val(lastCord[0]);\r\n        yCordInput.val(lastCord[1]);\r\n\r\n        const font = this.fonts[0];\r\n\r\n        let lastText = null, lastColor = player.color, lastTextCanvas = null\r\n        const previewFx = new FX((ctx) => {\r\n            const text = textInput.val();\r\n            if (!text) return 0;\r\n\r\n            if (!font.loaded) {\r\n                return 0;\r\n            }\r\n\r\n            // remap the sine value based on the time\r\n            // to the min-max opacity borders\r\n            ctx.globalAlpha = mapRange(Math.sin(Date.now() / 400), -1, 1, 0.2, 0.9);\r\n\r\n            const x = xCordInput.val();\r\n            const y = yCordInput.val();\r\n\r\n            if (lastText !== text || lastColor !== player.color) {\r\n                lastText = text;\r\n                lastColor = player.color;\r\n                lastTextCanvas = font.drawText(lastText, hexPalette[lastColor]);\r\n            }\r\n\r\n            const [screenX, screenY] = boardToScreenSpace(x, y);\r\n\r\n\r\n            ctx.save();\r\n            ctx.scale(camera.zoom, camera.zoom);\r\n\r\n            ctx.imageSmoothingEnabled = false;\r\n\r\n            const deZoomedX = screenX / camera.zoom;\r\n            const deZoomedY = screenY / camera.zoom;\r\n\r\n            if (~player.secondCol) {\r\n                ctx.fillStyle = hexPalette[player.secondCol];\r\n                ctx.fillRect(deZoomedX, deZoomedY, lastTextCanvas.width, lastTextCanvas.height);\r\n            }\r\n            ctx.drawImage(lastTextCanvas, deZoomedX, deZoomedY);\r\n\r\n            ctx.restore();\r\n\r\n            return 0\r\n        })\r\n        addFX(previewFx);\r\n\r\n        this.miniWindow.on('okClicked', () => {\r\n            globals.lockInputs = false;\r\n\r\n            removeFX(previewFx);\r\n\r\n            const text = textInput.val();\r\n            if (!text || !lastTextCanvas) return;\r\n\r\n            // add background if second color is selected\r\n            if (~player.secondCol) {\r\n                const ctx = lastTextCanvas.getContext('2d');\r\n                // draw only on opaque pixels\r\n                ctx.globalCompositeOperation = 'destination-over';\r\n                ctx.fillStyle = hexPalette[player.secondCol];\r\n                ctx.fillRect(0, 0, lastTextCanvas.width, lastTextCanvas.height);\r\n            }\r\n\r\n            const x = +xCordInput.val();\r\n            const y = +yCordInput.val();\r\n\r\n            paste.startDraw(lastTextCanvas, x, y);\r\n        });\r\n\r\n        this.miniWindow.on('cancelClicked', () => {\r\n            globals.lockInputs = false;\r\n\r\n            removeFX(previewFx);\r\n        });\r\n    }\r\n}\r\nconst text = new Text('text', 'KeyT', null, ROLE.USER);\r\n\r\nconst resetColors = new Tool('reset colors', 'RMB');\r\nresetColors.on('up', () => {\r\n    player.resetColors();\r\n});\r\n\r\nconst WAND_STATE = {\r\n    DISABLED: 0,\r\n    SELECTING: 1,\r\n    RENDERING: 2\r\n}\r\nclass MagicWand extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.state = WAND_STATE.DISABLED;\r\n\r\n        this.mouseListeners = {\r\n            down: this.mousedown.bind(this),\r\n            up: this.mouseup.bind(this)\r\n        };\r\n\r\n        this.downPos = null;\r\n\r\n        this.fx = null;\r\n\r\n        this.selectedColor = null;\r\n\r\n        this.maskCanvas = null;\r\n        this.maskImData = null;\r\n        this.maskBuffer = null;\r\n\r\n        this.glData = {\r\n            selColorLoc: null,\r\n            screenSizeLoc: null,\r\n            sdfRadiusLoc: null,\r\n            isDarkLoc: null\r\n        }\r\n\r\n        this.on('up', this.up.bind(this));\r\n        this.on('selected', this.selected.bind(this));\r\n        this.on('deselected', this.deselected.bind(this));\r\n    }\r\n\r\n    // mobile events\r\n    selected() {\r\n        if (this.state === WAND_STATE.RENDERING) {\r\n            this.stopRendering();\r\n        }\r\n        this.startSelecting();\r\n    }\r\n    deselected() {\r\n        if (this.state === WAND_STATE.SELECTING) {\r\n            this.stopSelecting();\r\n        }\r\n    }\r\n\r\n    up() {\r\n        switch (this.state) {\r\n            case WAND_STATE.DISABLED: {\r\n                this.startSelecting();\r\n                break;\r\n            }\r\n            case WAND_STATE.SELECTING: {\r\n                this.stopSelecting();\r\n                break;\r\n            }\r\n            case WAND_STATE.RENDERING: {\r\n                this.stopRendering();\r\n                if (mobile) {\r\n                    this.startSelecting();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    mousedown(e) {\r\n        this.downPos = [e.clientX, e.clientY];\r\n    }\r\n\r\n    mouseup(e) {\r\n        if (!this.downPos) return;\r\n\r\n        const upPos = [e.clientX, e.clientY];\r\n        if (!isClick(this.downPos, upPos)) {\r\n            return;\r\n        }\r\n\r\n        this.stopSelecting();\r\n\r\n        const boardPos = screenToBoardSpace(...upPos);\r\n        const boardColId = globals.chunkManager.getChunkPixel(...boardPos);\r\n        const rgbCol = palette[boardColId];\r\n\r\n        this.selectedColor = rgbCol;\r\n        globals.wandSelectedColor = boardColId;\r\n\r\n        this.startRendering();\r\n    }\r\n\r\n    startSelecting() {\r\n        this.state = WAND_STATE.SELECTING;\r\n\r\n        this.changeCursor(1);\r\n        player.suspendColors();\r\n\r\n        globals.eventManager.on('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.on('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    stopSelecting() {\r\n        this.state = WAND_STATE.DISABLED;\r\n\r\n        this.changeCursor(0);\r\n        player.restoreColors();\r\n\r\n        globals.eventManager.off('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.off('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    changeCursor(cursorState) {\r\n        if (cursorState === 1) {\r\n            document.body.style.cursor = `url('${wandCursor}') 2 2, auto`;\r\n        } else {\r\n            document.body.style.cursor = '';\r\n        }\r\n    }\r\n\r\n    glRenderMask() {\r\n        const gl = this.glData.gl;\r\n\r\n        gl.viewport(0, 0, this.maskCanvas.width, this.maskCanvas.height);\r\n\r\n        const mainCanvas = globals.mainCtx.canvas;\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, this.glData.texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\r\n            gl.UNSIGNED_BYTE, mainCanvas);\r\n\r\n        const [r, g, b] = this.selectedColor;\r\n\r\n        gl.uniform4f(this.glData.selColorLoc, r / 255, g / 255, b / 255, 1);\r\n        gl.uniform2f(this.glData.screenSizeLoc, mainCanvas.width, mainCanvas.height);\r\n        gl.uniform1f(this.glData.sdfRadiusLoc, 5);\r\n        gl.uniform1f(this.glData.isDarkLoc, isDarkColor(...this.selectedColor) ? 1 : 0);\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n    startRendering() {\r\n        this.state = WAND_STATE.RENDERING;\r\n\r\n        // first time we need to (re)generate it\r\n        // to prevent the old mask from showing off\r\n        this.generateMaskCanvas();\r\n\r\n        this.fx = new FX(ctx => {\r\n            if (this.state !== WAND_STATE.RENDERING) {\r\n                return FX_STATE.REMOVED;\r\n            }\r\n            const w = ctx.canvas.width;\r\n            const h = ctx.canvas.height;\r\n\r\n            // handling window resize\r\n            if (w !== this.maskCanvas.width ||\r\n                h !== this.maskCanvas.height) {\r\n                this.generateMaskCanvas();\r\n            }\r\n\r\n            this.glRenderMask();\r\n\r\n            ctx.globalAlpha = 0.8;\r\n            ctx.drawImage(this.maskCanvas, 0, 0);\r\n            ctx.globalAlpha = 1;\r\n\r\n            return FX_STATE.FINISHED;\r\n        });\r\n        addFX(this.fx);\r\n    }\r\n\r\n    stopRendering() {\r\n        this.state = WAND_STATE.DISABLED;\r\n\r\n        // cleaning up\r\n        this.maskCanvas = null;\r\n        this.maskImData = null;\r\n        this.maskBuffer = null;\r\n\r\n        this.fx = null;\r\n\r\n        this.selectedColor = null;\r\n        globals.wandSelectedColor = null;\r\n\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n\r\n    generateMaskCanvas() {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = globals.mainCtx.canvas.width;\r\n        canvas.height = globals.mainCtx.canvas.height;\r\n\r\n\r\n        this.maskCanvas = canvas;\r\n\r\n        this.generateShader();\r\n    }\r\n    generateShader() {\r\n        const maskCanvas = this.maskCanvas;\r\n\r\n        const fragmentShader = `\r\n        precision mediump float;\r\n        uniform sampler2D u_image;\r\n        uniform vec4 u_selectedColor;\r\n        uniform vec2 u_screenSize;\r\n        uniform float u_sdfRadius;\r\n        uniform float u_isDark;\r\n        varying vec2 v_texCoord;\r\n\r\n        void main() {\r\n            vec3 outColor = vec3(0.0);\r\n\r\n            vec4 color = texture2D(u_image, v_texCoord);\r\n            float match = all(equal(color, u_selectedColor)) ? 0.0 : 1.0;\r\n\r\n            float dx = 1.0 / u_screenSize.x;\r\n            float dy = 1.0 / u_screenSize.y;\r\n\r\n            \r\n            // process only surrounding pixels\r\n            if(match == 1.0 && u_isDark == 1.0){\r\n                float maxLength = length(vec2(u_sdfRadius, u_sdfRadius));\r\n                float mindist = 10000.0;\r\n                const float maxRadius = 5.0;\r\n                for(float x = -maxRadius; x < maxRadius; x++){\r\n                    if(abs(x) > u_sdfRadius) continue;\r\n                    for(float y = -maxRadius; y < maxRadius; y++){\r\n                        if(abs(y) > u_sdfRadius) continue;\r\n\r\n                        vec2 newCoord = vec2(dx*x + v_texCoord.x, dy*y + v_texCoord.y);\r\n                        vec4 color = texture2D(u_image, newCoord);\r\n                        bool match = all(equal(color, u_selectedColor));\r\n\r\n                        if(match){\r\n                            mindist = min(mindist, length(vec2(x, y)));\r\n                        }\r\n                    }\r\n                }\r\n                if(mindist != 10000.0){\r\n                    float norm = 1.0 - mindist / maxLength;\r\n\r\n                    outColor = vec3(norm);\r\n                }\r\n            }\r\n\r\n            gl_FragColor = vec4(outColor, match);\r\n        }\r\n        `;\r\n\r\n        const { gl, program, texture } = generateShader(maskCanvas, fragmentShader);\r\n\r\n        this.glData.selColorLoc = gl.getUniformLocation(program, \"u_selectedColor\");\r\n        this.glData.screenSizeLoc = gl.getUniformLocation(program, \"u_screenSize\");\r\n        this.glData.sdfRadiusLoc = gl.getUniformLocation(program, \"u_sdfRadius\");\r\n        this.glData.isDarkLoc = gl.getUniformLocation(program, \"u_isDark\");\r\n\r\n        this.glData.gl = gl;\r\n        this.glData.texture = texture;\r\n    }\r\n}\r\nconst wand = new MagicWand('wand', 'KeyW', wandIcon);\r\n\r\nconst COLORADOR_STATE = {\r\n    DISABLED: 0,\r\n    SELECTING: 1\r\n}\r\nclass TemplateColorador extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.colorsWhitelist = [];\r\n        resolveWhenConfigDownloaded().then(() => {\r\n            this.colorsWhitelist = JSON.parse(getOrDefault('coloradorColors', '[]', true));\r\n            if (this.colorsWhitelist.length) {\r\n                addFX(new FX(() => {\r\n                    if (!template.templateImg?.width) return FX_STATE.IN_PROCESS;\r\n\r\n                    try {\r\n                        this.update();                        \r\n                    } catch (error) {}\r\n\r\n                    return FX_STATE.REMOVED;\r\n                }));\r\n            }\r\n        });\r\n\r\n        this.state = COLORADOR_STATE.DISABLED;\r\n\r\n        this.on('up', this.up.bind(this));\r\n        this.on('selected', this.selected.bind(this));\r\n        this.on('deselected', this.deselected.bind(this));\r\n\r\n        this.mouseListeners = {\r\n            down: this.mousedown.bind(this),\r\n            up: this.mouseup.bind(this)\r\n        };\r\n\r\n        // needed for the reference\r\n        this.origTemplateCanvas = null;\r\n        this.origTemplateCtx = null;\r\n        // the one that is monkeypatched into the Template\r\n        this.templateCanvas = null;\r\n        this.templateUpdated = false;\r\n\r\n        this.glData = {\r\n            imageLoc: null,\r\n            colorsWhitelistLoc: null,\r\n            screenSizeLoc: null,\r\n            disabledOpacityLoc: null,\r\n            texture: null,\r\n        }\r\n    }\r\n\r\n    selected() {\r\n        this.startSelecting();\r\n    }\r\n    deselected() {\r\n        this.stopSelecting();\r\n    }\r\n\r\n    up() {\r\n        switch (this.state) {\r\n            case COLORADOR_STATE.DISABLED: {\r\n                this.startSelecting();\r\n                break;\r\n            }\r\n            case COLORADOR_STATE.SELECTING: {\r\n                this.stopSelecting();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    mmb(colorId) {\r\n        this.toggleWhitelistColor(palette[colorId]);\r\n    }\r\n\r\n    mousedown(e) {\r\n        this.downPos = [e.clientX, e.clientY];\r\n    }\r\n\r\n    mouseup(e) {\r\n        try {\r\n            if (!this.downPos) return;\r\n\r\n            const upPos = [e.clientX, e.clientY];\r\n            if (!isClick(this.downPos, upPos)) {\r\n                return;\r\n            }\r\n\r\n            this.regenerateTemplateIfNeeded();\r\n\r\n            const boardPos = screenToBoardSpace(...upPos);\r\n\r\n            if (this.isOutsideTemplate(...boardPos)) {\r\n                this.colorsWhitelist.length = 0;\r\n                this.update();\r\n                return;\r\n            }\r\n\r\n            const templateCol = this.getTemplateColor(...boardPos);\r\n            if (!templateCol) return;\r\n\r\n            const templateColId = getPaletteColorId(templateCol);\r\n            if (templateColId === -1) {\r\n                toastr.warning(t('color_not_in_palette'));\r\n                return\r\n            }\r\n\r\n            this.toggleWhitelistColor(templateCol);\r\n        } finally {\r\n            if (mobile) {\r\n                this.startSelecting();\r\n            }\r\n        }\r\n    }\r\n    isOutsideTemplate(boardX, boardY) {\r\n        const div = template.isPatterns ? 7 : 1\r\n        const templateW = template.templateImg.width / div;\r\n        const templateH = template.templateImg.height / div;\r\n\r\n        return boardX < template.x || boardY < template.y ||\r\n            boardX >= template.x + templateW ||\r\n            boardY >= template.y + templateH;\r\n    }\r\n\r\n\r\n    getTemplateColor(boardX, boardY) {\r\n        const temCtx = this.origTemplateCtx;\r\n\r\n        const temX = boardX - template.x;\r\n        const temY = boardY - template.y;\r\n\r\n        let color = null;\r\n        if (!template.isPatterns) {\r\n            const temColor = temCtx.getImageData(temX, temY, 1, 1).data;\r\n            // no color if it is opaque\r\n            if (temColor[3] === 0) {\r\n                return null;\r\n            }\r\n            color = temColor.slice(0, 3);\r\n        } else {\r\n            const multedTemX = temX * 7;\r\n            const multedTemY = temY * 7;\r\n\r\n            // finding the color in the 7x7 pattern cell\r\n            toBreak: for (let x = 0; x < 7; x++) {\r\n                for (let y = 0; y < 7; y++) {\r\n                    const curX = multedTemX + x;\r\n                    const curY = multedTemY + y;\r\n\r\n                    const curColor = temCtx.getImageData(curX, curY, 1, 1).data;\r\n                    // alpha\r\n                    if (curColor[3] !== 0) {\r\n                        color = curColor.slice(0, 3);\r\n                        break toBreak;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return color;\r\n\r\n    }\r\n\r\n    toggleWhitelistColor(targetCol) {\r\n        const whitelistColId = this.colorsWhitelist.findIndex(rgb => rgb[0] === targetCol[0] && rgb[1] === targetCol[1] && rgb[2] === targetCol[2]);\r\n        if (whitelistColId !== -1) {\r\n            this.removeWhitelistColor(whitelistColId);\r\n        } else {\r\n            this.addWhitelistColor(targetCol);\r\n        }\r\n    }\r\n    addWhitelistColor(rgb) {\r\n        this.colorsWhitelist.push([...rgb]);\r\n        this.update();\r\n    }\r\n    removeWhitelistColor(idx) {\r\n        this.colorsWhitelist.splice(idx, 1);\r\n        this.update();\r\n    }\r\n\r\n    updateUIPalette() {\r\n        $('.paletteColor>img.disabledClr').remove();\r\n\r\n        if (!this.colorsWhitelist.length) return;\r\n\r\n        $(`.paletteColor`).append(`<img src=\"${disabledColorSvg}\" class=\"disabledClr\">`);\r\n\r\n        for (const rgb of this.colorsWhitelist) {\r\n            const id = getPaletteColorId(rgb);\r\n            if (id === -1) {\r\n                console.warn('color', rgb, 'not found in the palette');\r\n                continue;\r\n            }\r\n\r\n            $(`#col${id}>img.disabledClr`).remove();\r\n        }\r\n    }\r\n\r\n    update() {\r\n        setLS('coloradorColors', JSON.stringify(this.colorsWhitelist), true);\r\n\r\n        this.regenerateTemplateIfNeeded();\r\n\r\n        if (this.colorsWhitelist.length > 0) {\r\n            this.generateShader();\r\n            this.renderShader(false);\r\n            this.patchTemplate();\r\n        } else {\r\n            this.unpatchTemplate();\r\n        }\r\n\r\n        this.updateUIPalette();\r\n    }\r\n\r\n    regenerateTemplateIfNeeded() {\r\n        if (!this.origTemplateCanvas || !this.templateCanvas || this.templateCanvas !== template.templateImg) {\r\n            this.templateUpdated = true;\r\n            this.glData.gl = null;\r\n\r\n            const templateImg = template.templateImg;\r\n\r\n            const origCanv = this.origTemplateCanvas = document.createElement('canvas');\r\n            const templCanv = this.templateCanvas = document.createElement('canvas');\r\n\r\n            origCanv.width = templCanv.width = templateImg.width;\r\n            origCanv.height = templCanv.height = templateImg.height;\r\n\r\n            this.origTemplateCtx = origCanv.getContext('2d');\r\n            this.origTemplateCtx.drawImage(templateImg, 0, 0);\r\n        }\r\n    }\r\n\r\n    startSelecting() {\r\n        this.state = COLORADOR_STATE.SELECTING;\r\n\r\n        this.changeCursor(1);\r\n        player.suspendColors();\r\n\r\n        this.clearListeners();\r\n\r\n        globals.eventManager.on('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.on('mouseup', this.mouseListeners.up);\r\n\r\n        this.renderShader(true);\r\n    }\r\n\r\n    stopSelecting() {\r\n        this.state = COLORADOR_STATE.DISABLED;\r\n\r\n        this.changeCursor(0);\r\n        player.restoreColors();\r\n\r\n        this.clearListeners();\r\n        \r\n        this.renderShader(false);\r\n    }\r\n    \r\n    clearListeners(){\r\n        globals.eventManager.off('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.off('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    createWhitelistTexture(gl, colors) {\r\n        const data = new Uint8Array(colors.flat());\r\n        const tex = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, colors.length, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, data);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        return tex;\r\n    }\r\n\r\n    renderShader(drawDisabled) {\r\n        if (!this.glData.gl) {\r\n            this.regenerateTemplateIfNeeded();\r\n            this.generateShader();\r\n        }\r\n\r\n        if (!this.colorsWhitelist.length) return;\r\n\r\n        const gl = this.glData.gl;\r\n\r\n\r\n\r\n        gl.viewport(0, 0, this.templateCanvas.width, this.templateCanvas.height);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.glData.texture);\r\n        if (this.templateUpdated) {\r\n            this.templateUpdated = false;\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\r\n                gl.UNSIGNED_BYTE, this.origTemplateCanvas);\r\n        }\r\n        gl.uniform1i(this.glData.imageLoc, 0);\r\n\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        const whitelistTexture = this.createWhitelistTexture(gl, this.colorsWhitelist);\r\n        gl.bindTexture(gl.TEXTURE_2D, whitelistTexture);\r\n        gl.uniform1i(this.glData.colorsWhitelistLoc, 1);\r\n\r\n        gl.uniform2f(this.glData.screenSizeLoc, mainCanvas.width, mainCanvas.height);\r\n\r\n        const disabledOpacity = drawDisabled ? 0.1 : 0;\r\n        gl.uniform1f(this.glData.disabledOpacityLoc, disabledOpacity);\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n    generateShader() {\r\n        if (!this.colorsWhitelist.length) return;\r\n\r\n        const fragmentShader = `\r\n        #define COLORS_SIZE ${this.colorsWhitelist.length}\r\n        precision mediump float;\r\n        uniform sampler2D u_image;\r\n        uniform sampler2D u_colorsWhitelist;\r\n        uniform vec2 u_screenSize;\r\n        uniform float u_disabledOpacity;\r\n        varying vec2 v_texCoord;\r\n\r\n        bool colorMatch(vec3 a, vec3 b) {\r\n            return distance(a, b) < 0.01;\r\n        }\r\n\r\n        void main() {\r\n            vec4 color = texture2D(u_image, v_texCoord);\r\n            \r\n            if(color.a < 0.001){\r\n                gl_FragColor = color;\r\n                return;\r\n            }\r\n\r\n            for(int i = 0; i < COLORS_SIZE; i++){\r\n                vec3 wl = texture2D(u_colorsWhitelist, vec2((float(i) + 0.5) / float(COLORS_SIZE), 0.5)).rgb;\r\n                if(colorMatch(wl, color.rgb)){\r\n                    gl_FragColor = color;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            \r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, u_disabledOpacity);\r\n        }\r\n        `;\r\n\r\n        let existingGl = this.glData.gl;\r\n        const { gl, program, texture } = generateShader(existingGl ?? this.templateCanvas, fragmentShader, existingGl ? false : true);\r\n\r\n        this.glData.imageLoc = gl.getUniformLocation(program, \"u_image\");\r\n        this.glData.colorsWhitelistLoc = gl.getUniformLocation(program, \"u_colorsWhitelist\");\r\n        this.glData.screenSizeLoc = gl.getUniformLocation(program, \"u_screenSize\");\r\n        this.glData.disabledOpacityLoc = gl.getUniformLocation(program, \"u_disabledOpacity\");\r\n\r\n        this.glData.gl = gl;\r\n        if (texture) {\r\n            this.glData.texture = texture;\r\n        }\r\n    }\r\n\r\n    patchTemplate() {\r\n        template.templateImg = this.templateCanvas;\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n    unpatchTemplate() {\r\n        template.templateImg = this.origTemplateCanvas;\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n\r\n    changeCursor(cursorState) {\r\n        if (cursorState === 1) {\r\n            document.body.style.cursor = `url('${disableCur}') 0 0, auto`;\r\n        } else {\r\n            document.body.style.cursor = '';\r\n        }\r\n    }\r\n}\r\nconst colorador = new TemplateColorador('colorador', 'KeyD', disableIcon);\r\n\r\nexport default {\r\n    clicker,\r\n    mover,\r\n    floodfill,\r\n    pipette, altPipette,\r\n    line,\r\n    colorInc, colorDec,\r\n    colorSwap,\r\n    chatOpac, menuOpac, allOpac,\r\n    ctrlZ,\r\n    protector, altProtector,\r\n    grid,\r\n    copy,\r\n    paste,\r\n    cordAdd,\r\n    templateOp1, templateOp2,\r\n    square,\r\n    incBrush, decBrush,\r\n    pixelInfo,\r\n    text,\r\n    resetColors,\r\n    wand,\r\n    colorador\r\n}\r\n","import { fixChatPosition, toggleEmojis, updateEmojis } from \"../Chat\";\r\nimport { hexPalette, palette } from \"../config\";\r\nimport { patterns } from \"../convert/patterns\";\r\nimport globals from \"../globals\";\r\nimport { togglePlaced, updatePlaced } from \"../player\";\r\nimport { isDarkColor } from \"../utils/color\";\r\nimport { getLS, getOrDefault } from \"../utils/localStorage\";\r\nimport { getRecommendedColorSize } from \"../utils/misc\";\r\nimport { chatInput, coords } from \"./elements\";\r\n\r\nexport function initUISettings() {\r\n    fixColorsWidth();\r\n    toggleEmojis(getLS('hideEmojis') != 1);\r\n    updateEmojis(getOrDefault('emojis', '        ').split(' '));\r\n    togglePlaced(!+getOrDefault('hidePlaced', 1))\r\n    updatePlaced(getLS('placedCount', true));\r\n    if (getLS('showPalettePatterns') == 1) {\r\n        showPatternsOnPalette();\r\n        globals.showPatterns = true;\r\n    }\r\n    if (getLS('swapToolsPos') == 1) {\r\n        swapToolsPos(getLS('swapToolsPos'));\r\n    }\r\n}\r\n\r\nexport function initCoordsClick() {\r\n    coords.on('click', function () {\r\n        chatInput[0].value += this.innerText;\r\n        chatInput.trigger('focus');\r\n    })\r\n}\r\n\r\nexport function fixColorsWidth() {\r\n    const savedWidth = getLS('colorSize', true);\r\n    const calculated = getRecommendedColorSize();\r\n\r\n    const colSize = +savedWidth || calculated\r\n    setPaletteColorsSize(colSize);\r\n    fixChatPosition();\r\n}\r\n\r\n// an old analog for setPaletteColorsSize\r\nexport function setPaletteRows(rows) {\r\n    let width = (window.innerWidth / 100) * rows;\r\n\r\n    $('#palette').css('max-width', width);\r\n}\r\n\r\n\r\nexport function setPaletteColorsSize(size) {\r\n    if (size === undefined) {\r\n        size = getRecommendedColorSize();\r\n    }\r\n    $('.paletteColor').css('width', size).css('height', size);\r\n}\r\n\r\n// beta and probably temprorary\r\n// purposely not optimised\r\nexport function showPatternsOnPalette() {\r\n    unloadPalettePatterns();\r\n\r\n    palette.forEach(([r, g, b], i) => {\r\n\r\n        const pat = patterns[i % patterns.length];\r\n\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvas.height = 14;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.fillStyle = hexPalette[i];\r\n\r\n        for (let i = 0; i < 7 * 7; i++) {\r\n            if (!pat[i]) continue;\r\n            const x = i % 7;\r\n            const y = i / 7 | 0;\r\n\r\n            ctx.fillRect(x * 2, y * 2, 2, 2);\r\n        }\r\n\r\n        function toI(x, y) {\r\n            return (x + y * 14) * 4;\r\n        }\r\n\r\n        // draw contour\r\n        let imd = ctx.getImageData(0, 0, 14, 14).data;\r\n        if (isDarkColor(r, g, b)) {\r\n            ctx.fillStyle = 'white';\r\n            let coords = [];\r\n            for (let x = 0; x < 14; x++) {\r\n                for (let y = 0; y < 14; y++) {\r\n                    if (imd[toI(x, y) + 3]) continue\r\n\r\n                    const top = imd[toI(x, y - 1) + 3];\r\n                    const bottom = imd[toI(x, y + 1) + 3];\r\n                    const left = imd[toI(x - 1, y) + 3];\r\n                    const right = imd[toI(x + 1, y) + 3];\r\n\r\n                    const leftTop = imd[toI(x - 1, y - 1) + 3];\r\n                    const rightTop = imd[toI(x + 1, y - 1) + 3];\r\n                    const leftBottom = imd[toI(x - 1, y + 1) + 3];\r\n                    const rightBottom = imd[toI(x + 1, y + 1) + 3];\r\n\r\n                    if (top || bottom || left || right ||\r\n                        leftTop || rightTop || leftBottom || rightBottom) {\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        imd = ctx.getImageData(0, 0, 14, 14).data;\r\n        ctx.fillStyle = 'black';\r\n        for (let i = 0; i < 14 * 14; i++) {\r\n            if (!imd[i * 4 + 3])\r\n                ctx.fillRect(i % 14, i / 14 | 0, 1, 1)\r\n        }\r\n\r\n\r\n        const dataurl = canvas.toDataURL();\r\n        const img = document.createElement('img');\r\n        img.src = dataurl;\r\n        $(`#col${i}`).append(img);\r\n    });\r\n    $('.paletteColor').addClass('patternColor');\r\n}\r\nexport function swapToolsPos(state){\r\n    const qs = $('#tools,.showMenu,.showChat')\r\n    if(state == 1){\r\n        qs.addClass('right');\r\n    }else{\r\n        qs.removeClass('right');\r\n    }\r\n}\r\n\r\nexport function unloadPalettePatterns() {\r\n    $('.paletteColor>img').remove();\r\n    $('.paletteColor').removeClass('patternColor');\r\n}","import { fixChatPosition } from \"../Chat\";\r\nimport { getLS } from \"../utils/localStorage\";\r\nimport { topMenu } from \"./elements\";\r\n\r\nexport function toggleTopMenu() {\r\n    if (topMenu.css('display') === 'none') {\r\n        topMenu.show();\r\n        topMenu.css('margin-top', '');\r\n    } else {\r\n        topMenu.css('margin-top', -topMenu.height() - 30);\r\n        setTimeout(() => topMenu.hide(), 500);\r\n    }\r\n}\r\n\r\nexport function toggleEverything() {\r\n    // $('#ui>div>div').each((_, el) => {\r\n    //     if(el.style.getPropertyPriority('display') == 'important')\r\n    //         return;\r\n\r\n    //     if (el.style.display === 'none') {\r\n    //         $(el).css('display', '')\r\n    //     } else {\r\n    //         $(el).css('display', 'none')\r\n    //     }\r\n    // })\r\n    $('#ui').fadeToggle(100);\r\n    fixChatPosition();\r\n}\r\n\r\nexport function initMobileMenuToggler() {\r\n    $('.showMenu,.hideMenu').on('click', toggleTopMenu)\r\n}\r\n\r\nexport function initMenuResizer() {\r\n    const resizer = $('#menuResizer');\r\n    const resizerStripes = $('#resizingStripes');\r\n\r\n    let curHeight = +getLS('columnHeight');\r\n    if (isNaN(curHeight) || curHeight == 0) {\r\n        curHeight = 123;\r\n    } else if (curHeight < 0) {\r\n        curHeight = 0;\r\n    } else if (curHeight >= (window.screen.height - 250)) {\r\n        curHeight = window.screen.height - 250;\r\n    }\r\n    $('.columnContent').css('height', curHeight);\r\n\r\n    let resizeTimeout;\r\n    let resizeLock = false;\r\n\r\n    function unfade() {\r\n        resizer.css('height', '7px');\r\n        resizer.css('background-color', '#4c4c4c');\r\n        resizerStripes.css('opacity', '1');\r\n    }\r\n\r\n    function fade() {\r\n        clearTimeout(resizeTimeout);\r\n        resizer.css('height', '');\r\n        resizer.css('background-color', '');\r\n        resizerStripes.css('opacity', '');\r\n    }\r\n\r\n    resizer.on('mouseover', () => {\r\n        clearTimeout(resizeTimeout);\r\n        resizeTimeout = setTimeout(() => {\r\n            unfade();\r\n        }, 500)\r\n    })\r\n\r\n    resizer.on('mouseout', () => {\r\n        if (resizeLock) return;\r\n\r\n        fade();\r\n    })\r\n\r\n    function onmousedown() {\r\n        resizeLock = true;\r\n        unfade();\r\n\r\n        function onmousemove(e) {\r\n            curHeight += e.originalEvent.movementY;\r\n            $('.columnContent').css('height', curHeight);\r\n            setLS('columnHeight', curHeight);\r\n        }\r\n        function oncemouseup() {\r\n            $(document).off('mousemove', onmousemove);\r\n            resizeLock = false;\r\n            fade();\r\n        }\r\n\r\n        $(document).on('mousemove', onmousemove)\r\n        $(document).one('mouseup', oncemouseup)\r\n    }\r\n    resizer.on('mousedown', onmousedown);\r\n}","import querystring from 'querystring'\n\nimport {\n    hexPalette,\n} from './config';\nimport camera from './camera';\nimport { generateTable } from './windows';\nimport Window from './Window';\nimport globals from './globals';\nimport me from './me';\n\n// import userImg from '../img/user2.png';\nimport userImg from '../img/user.svg';\nimport { ROLE, ROLE_I } from './constants';\nimport { translate as t } from './translate';\n\nimport modBadge from '../img/mod-badge.svg';\nimport adminBadge from '../img/admin-badge.svg';\nimport { htmlspecialchars } from './utils/misc';\nimport { apiRequest } from './utils/api';\nimport MiniWindow from './MiniWindow';\nimport { chatInput } from './ui/elements';\n\n// WARNING: this will work only if file names are not changed by webpack\nconst requireBadge = require.context('../img/badges', false, /\\.png$/);\nconst badgeLinks = {};\nrequireBadge.keys().map(requireBadge).forEach(path => {\n    const filename = path.default.match(/([\\w\\d_]+)\\.png$/);\n    badgeLinks[filename[1]] = path.default;\n});\n\n\nconst usersContainer = $('#usersTable');\n\nexport default class User {\n    // create user window from given object\n    // tempId is a temporary id for connection\n    static async CreateWindow(info, tempId) {\n        const win = new Window({\n            center: true,\n            title: `${info.name || t('PLAYER') + ' ' + (tempId || info.id)}`\n        });\n\n        // show everything by default\n        const htmlInfo = new Map();\n\n        if (info.registered) {\n            htmlInfo.set('name', htmlspecialchars(info.name));\n            htmlInfo.set('mail', htmlspecialchars(info.email));\n\n        }\n\n        htmlInfo.set('id', info.id || tempId);\n\n        if (info.ip) {\n            if (info.cc && info.cc !== 'XX') {\n                // adds a flag near the ip address\n\n                const cc = info.cc;\n                htmlInfo.set('ip', info.ip + ` [${cc}]`);\n                htmlInfo.set('ip', htmlInfo.get('ip') + `<img src=\"${location.protocol}//flagcdn.com/h20/${cc.toLowerCase()}.png\" style=\"margin-left:1px;height:13px;\">`);\n            } else {\n                htmlInfo.set('ip', info.ip);\n            }\n        }\n\n        htmlInfo.set('role', info.role);\n\n        // allowing role/badge change \n        if (info.role !== undefined && me.role === ROLE.ADMIN) {\n            if (me.id !== info.id) {\n                const role = info.role;\n                let str = '';\n                Object.keys(ROLE).forEach(text => {\n                    // now bans are through the special menu\n                    if (text === 'BANNED') return;\n\n                    str += `<option ${(text === role) ? 'selected' : ''}>${text}</option>`;\n                })\n                info.role = role ? ROLE[role] : null;\n\n                htmlInfo.set('role', `<select type=\"role\">${str}</select>`);\n            }\n\n            const badges = info.badges || [];\n            requestAnimationFrame(() => {\n                badges.forEach(badge => addBadge(badge.name));\n            });\n\n            let badgesCont = $(`<div class=\"badgesList\"></div><button class=\"addBadgeBtn\" title=\"Add Badge\">+</button>`);\n            htmlInfo.set('badges', badgesCont.map(function () {\n                return this.outerHTML;\n            }).get().join(''));\n        }\n\n        let infoArr = [...htmlInfo.keys(htmlInfo)].map(key => [key, htmlInfo.get(key)]), misc = [];\n        infoArr = infoArr.filter(([k, v]) => !!v);\n\n        if (me.role >= ROLE.MOD) {\n            misc = [\n                [`<input class=\"alertInput\">`, `<button class=\"sendAlert\">${t('btn.sendAlert')}</button>`],\n                [`<input class=\"modalInput\">`, `<button class=\"sendModal\">${t('btn.sendModal')}</button>`]\n            ];\n            if (info.bannedUntil) {\n                misc.push([t('label.bannedUntil'), info.bannedUntil]);\n            }\n            if (me.id !== info.id) {\n                if (info.role) {\n                    misc.push([`<button class=\"openBanMenu\">${t('ban_menu')}</button>`]);\n                } else {\n                    // ip ban is only for guests\n                    misc.push([`<button class=\"banByIp\">${t('Ban by ip')}</button>`]);\n                }\n            }\n        }\n\n        let together = infoArr.concat(misc);\n\n        $(win.body).append(generateTable(together));\n\n        $('select[type=role]', win.body).on('change', async e => {\n            const role = e.target.value,\n                userId = info.id;\n            const resp = await fetch('/api/admin/changerole', {\n                method: 'POST',\n                body: JSON.stringify({\n                    id: userId,\n                    role\n                }),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            const body = await resp.json();\n            if (body.errors) {\n                body.errors.forEach(error => {\n                    toastr.error(error, t('ERROR'));\n                })\n            } else {\n                toastr.success(t('Changed role to') + ' ' + role);\n            }\n        })\n\n\n        $('.sendAlert', win.body).on('click', () => {\n            const val = $('.alertInput', win.body).val();\n\n            if (val.length == 0) return;\n\n            $('.alertInput', win.body).val('');\n            globals.socket.sendAlert(tempId, val);\n        });\n\n        $('.sendModal', win.body).on('click', () => {\n            const val = $('.modalInput', win.body).val();\n\n            if (val.length == 0) return;\n\n            $('.modalInput', win.body).val('');\n            globals.socket.sendAlert(tempId, val, true);\n        });\n\n        $('.banByIp', win.body).on('click', async () => {\n            const ip = info.ip;\n            if (!ip) return toastr.error(t('No ip!'));\n\n            const miniWindow = new MiniWindow(``, 2);\n            const banMenuContents = $(\n                '<div>'+\n                `0= <input type=\"number\" class=\"bannedUntilNum\" value=\"0\" min=\"0\">` +\n                `<select class=\"bannedUntilMult\">\n                    <option value=\"${1000 * 60}\">${t('time.minute')}</option>\n                    <option value=\"${1000 * 60 * 60}\">${t('time.hour')}</option>\n                    <option value=\"${1000 * 60 * 60 * 24}\">${t('time.day')}</option>\n                </select>`+\n                '<div>'\n            );\n\n            const untilNum = $('.bannedUntilNum', banMenuContents);\n            const untilMulti = $('.bannedUntilMult', banMenuContents);\n\n            miniWindow.on('okClicked', () => {\n                const untilNumValue = untilNum.val();\n                const untilMultiValue = new Number(untilMulti.val());\n\n                const untilDate = new Date(Date.now() + untilNumValue * untilMultiValue);\n\n                const ipBanParams = { ip };\n                if (untilNumValue > 0) {\n                    ipBanParams['until'] = untilDate.toISOString();\n                }\n                apiRequest(`/admin/ban/byIp?${querystring.stringify(ipBanParams)}`);\n            });\n\n            miniWindow.bodyElement.append(banMenuContents);\n            $(document.body).append(miniWindow.element);\n\n            setTimeout(() => miniWindow.center());\n        });\n\n        $('.openBanMenu', win.body).on('click', async () => {\n            const miniWindow = new MiniWindow(`${t('ban_menu_for')} ${htmlspecialchars(info.name)}`, 2);\n            const banMenuContents = $(\n                `<input type=\"checkbox\" id=\"${info.id}-shadow-cb\" class=\"shadowCheckbox\" ${info.shadowBanned ? 'checked' : ''}>` +\n                `<label for=\"${info.id}-shadow-cb\">${t('label.shadowBanned')}</label><br>` +\n\n                `<input type=\"checkbox\" id=\"${info.id}-banned-cb\" class=\"bannedCheckbox\" ${info.role === 'BANNED' ? 'checked' : ''}>` +\n                `<label for=\"${info.id}-banned-cb\">${t('label.banned')}</label><br>` +\n\n                `0= <input type=\"number\" id=\"${info.id}-until-number\" class=\"bannedUntilNum\" value=\"0\" min=\"0\">` +\n                `<select id=\"${info.id}-until-multiplier\" class=\"bannedUntilMult\">\n                    <option value=\"${1000 * 60}\">${t('time.minute')}</option>\n                    <option value=\"${1000 * 60 * 60}\">${t('time.hour')}</option>\n                    <option value=\"${1000 * 60 * 60 * 24}\">${t('time.day')}</option>\n                </select>`\n            );\n            miniWindow.bodyElement.append(banMenuContents);\n            $(document.body).append(miniWindow.element);\n\n\n            const chadowCb = $('.shadowCheckbox', miniWindow.element);\n            const banCb = $('.bannedCheckbox', miniWindow.element);\n            const untilNum = $('.bannedUntilNum', miniWindow.element);\n            const untilMulti = $('.bannedUntilMult', miniWindow.element);\n\n            miniWindow.on('okClicked', () => {\n                const shadowChecked = chadowCb.is(':checked');\n                const banChecked = banCb.is(':checked');\n                const untilNumValue = untilNum.val();\n                const untilMultiValue = new Number(untilMulti.val());\n\n                const untilDate = new Date(Date.now() + untilNumValue * untilMultiValue);\n\n                const vastBanParams = {\n                    uid: info.id,\n                    banned: banChecked\n                };\n                if (untilNumValue > 0) {\n                    vastBanParams['until'] = untilDate.toISOString();\n                }\n                apiRequest(`/admin/ban?${querystring.stringify(vastBanParams)}`);\n\n                const shadowBanParams = {\n                    uid: info.id,\n                    banned: shadowChecked\n                };\n                if (untilNumValue > 0) {\n                    shadowBanParams['until'] = untilDate.toISOString();\n                }\n                apiRequest(`/admin/ban/shadow?${querystring.stringify(shadowBanParams)}`);\n            });\n\n\n            setTimeout(() => miniWindow.center());\n\n        });\n\n        $('.addBadgeBtn', win.body).on('click', async () => {\n            const subwindow = new Window({\n                title: 'Badges for ' + info.id,\n                x: win.x + win.width + 5,\n                y: win.y\n            });\n            if (!subwindow.created) return;\n\n            subwindow.body.style.display = 'flex';\n            subwindow.body.style.gap = '2px';\n\n            for (const [badgeName, badgeLink] of Object.entries(badgeLinks)) {\n                const badgeImg = $(`<div style=\"padding: 3px; background: gray; border-radius: 4px; max-width: fit-content;\">\n                <img src=\"${badgeLink}\">\n                </div>`);\n                badgeImg.on('click', () => {\n                    apiRequest(`/badges/add?userId=${info.id}&badge=${badgeName}`, { method: 'POST' }).then(async resp => {\n                        if (!(await resp.json()).ok) return;\n\n                        addBadge(badgeName);\n                    });\n                });\n                $(subwindow.body).append(badgeImg);\n            }\n        });\n\n        function addBadge(badgeName) {\n            const badgeHtml = $(`<div class=\"badge\" title=\"${badgeName}\">\n                            <img src=\"${badgeLinks[badgeName]}\" alt=\"${badgeName}\">\n                        </div>`);\n            $('.badgesList', win.body).append(badgeHtml);\n\n            badgeHtml.on('click', () => {\n                apiRequest(`/badges/del?userId=${info.id}&badge=${badgeName}`, { method: 'POST' }).then(async resp => {\n                    if (!(await resp.json()).ok) return;\n\n                    badgeHtml.remove();\n                });\n            });\n        }\n    }\n\n\n    constructor(name, id, userId, registered, role, badges = null) {\n        if (!name) name = 'ID ' + id;\n\n        this.name = name;\n        this.id = id;\n        this.userId = userId;\n\n        this.registered = registered;\n\n        this.role = role;\n\n        this.conns = [id];\n\n        this.badges = badges;\n\n\n        const safeName = htmlspecialchars(this.name);\n        let displayName = globals.chat.parseColors(safeName).replace(/<[^>]*>/g, '');\n\n        const roleBadgeProps = this.getRoleBadgeAndTitle();\n\n        this.element = $(\n            `<tr class=\"tableRow\">\n                <td title=\"id ${id}\" class=\"user\">\n                    ${roleBadgeProps ? `<img src=\"${roleBadgeProps.icon}\" title=\"${roleBadgeProps.tooltip}\" class=\"roleBadge\">` : ''}\n                    <button class=\"userInfoBtn minrole-trusted\"><img style=\"height: 20px\" src=\"${userImg}\"></button>\n                    <span class=\"name\">${displayName}</span>\n                    <span class=\"badges\"></span>\n                    <span class=\"xConns\"></span>\n                </td>\n                <td></td>\n            </tr>`);\n\n        this.nameEl = $('.name', this.element);\n        this.coordsEl = $(this.element.children()[1]);\n\n        this.nameEl.on('click', function () {\n            const visibleNick = this.innerText;\n            chatInput[0].value += visibleNick + ', ';\n            chatInput.trigger('focus');\n        })\n\n\n        $('.userInfoBtn', this.element).on('click', async () => {\n            const isReg = this.registered;\n            const id = isReg ? this.userId : this.id;\n\n            const req = await fetch(`/api/userInfo?id=${id}${isReg ? '' : '&unreg=1'}`);\n            const info = await req.json();\n            await User.CreateWindow(info, this.id);\n        });\n\n        this.coordsEl.on('click', () => {\n            const [x, y] = this.coordsEl.text()\n                .slice(1, -1)\n                .split(', ')\n                .map(x => parseInt(x, 10));\n\n            if (Number.isInteger(x) && Number.isInteger(y))\n                camera.centerOn(x, y);\n        })\n\n        usersContainer[0].appendChild(this.element[0]);\n\n        me.updateRoleRelatedHtml();\n    }\n\n    async loadBadges() {\n        if (this.userId === null) return;\n\n        const resp = await apiRequest(`/userInfo/badges?id=${this.userId}`);\n        const badges = await resp.json();\n        this.badges = badges;\n    }\n\n    updateBadges() {\n        $('.badges', this.element).append(this.getAchieveBadgesHtml());\n    }\n\n    getAchieveBadgesHtml() {\n        if (!this.badges) return '';\n\n        let html = '';\n        for (let badge of this.badges) {\n            const {\n                name, width, height\n            } = badge;\n\n            const customWidth = width ? `width: ${width}px;` : '';\n            const customHeight = height ? `height: ${height}px;` : '';\n\n            html += `<img src=\"${badgeLinks[name]}\" style=\"${customWidth}${customHeight}\">`;\n        }\n        return html\n    }\n\n    getRoleBadgeAndTitle() {\n        if (!this.role) return null;\n\n        let tooltip, icon;\n\n        switch (this.role) {\n            case 'MOD':\n                tooltip = 'mod';\n                icon = modBadge;\n                break\n            case 'ADMIN':\n                tooltip = 'admin';\n                icon = adminBadge;\n                break\n            default:\n                return null\n        }\n\n        // if (this.userId == 1) {\n        //     tooltip = 'creator';\n        //     icon = creatorBadge;\n        // }\n\n        return {\n            tooltip,\n            icon\n        }\n    }\n\n    updateCoords(color, x, y) {\n        this.coordsEl.css('color', hexPalette[color]);\n        this.coordsEl.text(`(${x}, ${y})`);\n    }\n\n    close(clientId) {\n        this.conns.splice(this.conns.indexOf(clientId), 1);\n        if (this.conns.length === 0)\n            this.destroy();\n        else\n            this.updateX();\n\n        delete globals.users[clientId]\n    }\n\n    destroy() {\n        this.element.remove();\n    }\n\n    newConnection(clientId) {\n        this.conns.push(clientId);\n        this.updateX();\n    }\n\n    updateX() {\n        const text = (this.conns.length > 1) ? `[x${this.conns.length}]` : '';\n        $('.xConns', this.element).text(text);\n    }\n}","import camera from '../camera';\r\nimport { halfMap } from './misc';\r\nimport { boardToScreenSpace, screenToBoardSpace } from './conversions';\r\nimport {\r\n    chunkSize,\r\n    boardChunkWid,\r\n    boardChunkHei,\r\n    boardWidth,\r\n    boardHeight\r\n} from '../config';\r\n\r\nexport function isAreaVisible(x, y, w, h) {\r\n    const [x1, y1] = boardToScreenSpace(x, y);\r\n    const [x2, y2] = boardToScreenSpace(x + w, y + h);\r\n\r\n    return x1 < window.innerWidth && x2 >= 0 && y1 < window.innerHeight && y2 >= 0;\r\n}\r\n\r\nexport function isChunkVisible(cx, cy) {\r\n    return isAreaVisible(cx * chunkSize, cy * chunkSize, chunkSize, chunkSize);\r\n}\r\n\r\nexport function getVisibleChunks() {\r\n    // todo rework it\r\n    // rn it checks left top chunk and right bottom chunk\r\n\r\n    let [sx, sy] = screenToBoardSpace(0, 0);\r\n    let [ex, ey] = screenToBoardSpace(window.innerWidth, window.innerHeight);\r\n\r\n\r\n    let startX = sx / chunkSize | 0, // math floor\r\n        endX = ex / chunkSize + 1 | 0; // math ceil\r\n\r\n    let startY = sy / chunkSize | 0,\r\n        endY = ey / chunkSize + 1 | 0;\r\n\r\n    let arr = []\r\n    for (let x = Math.max(startX, 0); x < Math.min(endX, boardChunkWid); x++) {\r\n        for (let y = Math.max(startY, 0); y < Math.min(endY, boardChunkHei); y++) {\r\n            arr.push([x, y]);\r\n        }\r\n    }\r\n\r\n    return arr\r\n}\r\n\r\nexport function inBounds(x, y) {\r\n    if (x < 0 || x >= boardWidth || y < 0 || y >= boardHeight) return false;\r\n    return true;\r\n}","import camera from '../camera';\r\nimport globals from '../globals';\r\nimport {\r\n    halfMap\r\n} from './misc';\r\nimport {\r\n    chunkSize\r\n} from '../config';\r\n\r\nexport function screenToBoardSpace(clientX, clientY) {\r\n    let screenOffsetX = (clientX - (globals.renderer.canvas.width >> 1)) / camera.zoom;\r\n    let screenOffsetY = (clientY - (globals.renderer.canvas.height >> 1)) / camera.zoom;\r\n\r\n    let boardOffsetX = camera.x + halfMap[0];\r\n    let boardOffsetY = camera.y + halfMap[1];\r\n\r\n    let x = boardOffsetX + screenOffsetX,\r\n        y = screenOffsetY + boardOffsetY;\r\n\r\n    return [x | 0, y | 0]\r\n}\r\n\r\nexport function boardToScreenSpace(x, y) {\r\n    x -= camera.x + halfMap[0];\r\n    y -= camera.y + halfMap[1];\r\n\r\n    x *= camera.zoom;\r\n    y *= camera.zoom;\r\n\r\n    x += globals.renderer.canvas.width >> 1; // x >> 1 = x / 2\r\n    y += globals.renderer.canvas.height >> 1;\r\n\r\n    return [Math.floor(x), Math.floor(y)]\r\n}\r\n\r\nexport function boardToChunk(x, y) {\r\n    let cx = x / chunkSize | 0;\r\n    let cy = y / chunkSize | 0;\r\n\r\n    let offx = x % chunkSize;\r\n    let offy = y % chunkSize;\r\n\r\n    return [\r\n        cx,\r\n        cy,\r\n        offx,\r\n        offy\r\n    ]\r\n}\r\n\r\nexport function chunkToBoard(cx, cy, offx, offy) {\r\n    return [cx * chunkSize + offx, cy * chunkSize + offy]\r\n}","export default {\r\n    \"ALICEBLUE\": \"#F0F8FF\",\r\n    \"ANTIQUEWHITE\": \"#FAEBD7\",\r\n    \"AQUA\": \"#00FFFF\",\r\n    \"AQUAMARINE\": \"#7FFFD4\",\r\n    \"AZURE\": \"#F0FFFF\",\r\n    \"BEIGE\": \"#F5F5DC\",\r\n    \"BISQUE\": \"#FFE4C4\",\r\n    \"BLACK\": \"#000000\",\r\n    \"BLANCHEDALMOND\": \"#FFEBCD\",\r\n    \"BLUE\": \"#0000FF\",\r\n    \"BLUEVIOLET\": \"#8A2BE2\",\r\n    \"BROWN\": \"#A52A2A\",\r\n    \"BURLYWOOD\": \"#DEB887\",\r\n    \"CADETBLUE\": \"#5F9EA0\",\r\n    \"CHARTREUSE\": \"#7FFF00\",\r\n    \"CHOCOLATE\": \"#D2691E\",\r\n    \"CORAL\": \"#FF7F50\",\r\n    \"CORNFLOWERBLUE\": \"#6495ED\",\r\n    \"CORNSILK\": \"#FFF8DC\",\r\n    \"CRIMSON\": \"#DC143C\",\r\n    \"CYAN\": \"#00FFFF\",\r\n    \"DARKBLUE\": \"#00008B\",\r\n    \"DARKCYAN\": \"#008B8B\",\r\n    \"DARKGOLDENROD\": \"#B8860B\",\r\n    \"DARKGRAY\": \"#A9A9A9\",\r\n    \"DARKGREY\": \"#A9A9A9\",\r\n    \"DARKGREEN\": \"#006400\",\r\n    \"DARKKHAKI\": \"#BDB76B\",\r\n    \"DARKMAGENTA\": \"#8B008B\",\r\n    \"DARKOLIVEGREEN\": \"#556B2F\",\r\n    \"DARKORANGE\": \"#FF8C00\",\r\n    \"DARKORCHID\": \"#9932CC\",\r\n    \"DARKRED\": \"#8B0000\",\r\n    \"DARKSALMON\": \"#E9967A\",\r\n    \"DARKSEAGREEN\": \"#8FBC8F\",\r\n    \"DARKSLATEBLUE\": \"#483D8B\",\r\n    \"DARKSLATEGRAY\": \"#2F4F4F\",\r\n    \"DARKSLATEGREY\": \"#2F4F4F\",\r\n    \"DARKTURQUOISE\": \"#00CED1\",\r\n    \"DARKVIOLET\": \"#9400D3\",\r\n    \"DEEPPINK\": \"#FF1493\",\r\n    \"DEEPSKYBLUE\": \"#00BFFF\",\r\n    \"DIMGRAY\": \"#696969\",\r\n    \"DIMGREY\": \"#696969\",\r\n    \"DODGERBLUE\": \"#1E90FF\",\r\n    \"FIREBRICK\": \"#B22222\",\r\n    \"FLORALWHITE\": \"#FFFAF0\",\r\n    \"FORESTGREEN\": \"#228B22\",\r\n    \"FUCHSIA\": \"#FF00FF\",\r\n    \"GAINSBORO\": \"#DCDCDC\",\r\n    \"GHOSTWHITE\": \"#F8F8FF\",\r\n    \"GOLD\": \"#FFD700\",\r\n    \"GOLDENROD\": \"#DAA520\",\r\n    \"GRAY\": \"#808080\",\r\n    \"GREY\": \"#808080\",\r\n    \"GREEN\": \"#008000\",\r\n    \"GREENYELLOW\": \"#ADFF2F\",\r\n    \"HONEYDEW\": \"#F0FFF0\",\r\n    \"HOTPINK\": \"#FF69B4\",\r\n    \"INDIANRED\": \"#CD5C5C\",\r\n    \"INDIGO\": \"#4B0082\",\r\n    \"IVORY\": \"#FFFFF0\",\r\n    \"KHAKI\": \"#F0E68C\",\r\n    \"LAVENDER\": \"#E6E6FA\",\r\n    \"LAVENDERBLUSH\": \"#FFF0F5\",\r\n    \"LAWNGREEN\": \"#7CFC00\",\r\n    \"LEMONCHIFFON\": \"#FFFACD\",\r\n    \"LIGHTBLUE\": \"#ADD8E6\",\r\n    \"LIGHTCORAL\": \"#F08080\",\r\n    \"LIGHTCYAN\": \"#E0FFFF\",\r\n    \"LIGHTGOLDENRODYELLOW\": \"#FAFAD2\",\r\n    \"LIGHTGRAY\": \"#D3D3D3\",\r\n    \"LIGHTGREY\": \"#D3D3D3\",\r\n    \"LIGHTGREEN\": \"#90EE90\",\r\n    \"LIGHTPINK\": \"#FFB6C1\",\r\n    \"LIGHTSALMON\": \"#FFA07A\",\r\n    \"LIGHTSEAGREEN\": \"#20B2AA\",\r\n    \"LIGHTSKYBLUE\": \"#87CEFA\",\r\n    \"LIGHTSLATEGRAY\": \"#778899\",\r\n    \"LIGHTSLATEGREY\": \"#778899\",\r\n    \"LIGHTSTEELBLUE\": \"#B0C4DE\",\r\n    \"LIGHTYELLOW\": \"#FFFFE0\",\r\n    \"LIME\": \"#00FF00\",\r\n    \"LIMEGREEN\": \"#32CD32\",\r\n    \"LINEN\": \"#FAF0E6\",\r\n    \"MAGENTA\": \"#FF00FF\",\r\n    \"MAROON\": \"#800000\",\r\n    \"MEDIUMAQUAMARINE\": \"#66CDAA\",\r\n    \"MEDIUMBLUE\": \"#0000CD\",\r\n    \"MEDIUMORCHID\": \"#BA55D3\",\r\n    \"MEDIUMPURPLE\": \"#9370DB\",\r\n    \"MEDIUMSEAGREEN\": \"#3CB371\",\r\n    \"MEDIUMSLATEBLUE\": \"#7B68EE\",\r\n    \"MEDIUMSPRINGGREEN\": \"#00FA9A\",\r\n    \"MEDIUMTURQUOISE\": \"#48D1CC\",\r\n    \"MEDIUMVIOLETRED\": \"#C71585\",\r\n    \"MIDNIGHTBLUE\": \"#191970\",\r\n    \"MINTCREAM\": \"#F5FFFA\",\r\n    \"MISTYROSE\": \"#FFE4E1\",\r\n    \"MOCCASIN\": \"#FFE4B5\",\r\n    \"NAVAJOWHITE\": \"#FFDEAD\",\r\n    \"NAVY\": \"#000080\",\r\n    \"OLDLACE\": \"#FDF5E6\",\r\n    \"OLIVE\": \"#808000\",\r\n    \"OLIVEDRAB\": \"#6B8E23\",\r\n    \"ORANGE\": \"#FFA500\",\r\n    \"ORANGERED\": \"#FF4500\",\r\n    \"ORCHID\": \"#DA70D6\",\r\n    \"PALEGOLDENROD\": \"#EEE8AA\",\r\n    \"PALEGREEN\": \"#98FB98\",\r\n    \"PALETURQUOISE\": \"#AFEEEE\",\r\n    \"PALEVIOLETRED\": \"#DB7093\",\r\n    \"PAPAYAWHIP\": \"#FFEFD5\",\r\n    \"PEACHPUFF\": \"#FFDAB9\",\r\n    \"PERU\": \"#CD853F\",\r\n    \"PINK\": \"#FFC0CB\",\r\n    \"PLUM\": \"#DDA0DD\",\r\n    \"POWDERBLUE\": \"#B0E0E6\",\r\n    \"PURPLE\": \"#800080\",\r\n    \"REBECCAPURPLE\": \"#663399\",\r\n    \"RED\": \"#FF0000\",\r\n    \"ROSYBROWN\": \"#BC8F8F\",\r\n    \"ROYALBLUE\": \"#4169E1\",\r\n    \"SADDLEBROWN\": \"#8B4513\",\r\n    \"SALMON\": \"#FA8072\",\r\n    \"SANDYBROWN\": \"#F4A460\",\r\n    \"SEAGREEN\": \"#2E8B57\",\r\n    \"SEASHELL\": \"#FFF5EE\",\r\n    \"SIENNA\": \"#A0522D\",\r\n    \"SILVER\": \"#C0C0C0\",\r\n    \"SKYBLUE\": \"#87CEEB\",\r\n    \"SLATEBLUE\": \"#6A5ACD\",\r\n    \"SLATEGRAY\": \"#708090\",\r\n    \"SLATEGREY\": \"#708090\",\r\n    \"SNOW\": \"#FFFAFA\",\r\n    \"SPRINGGREEN\": \"#00FF7F\",\r\n    \"STEELBLUE\": \"#4682B4\",\r\n    \"TAN\": \"#D2B48C\",\r\n    \"TEAL\": \"#008080\",\r\n    \"THISTLE\": \"#D8BFD8\",\r\n    \"TOMATO\": \"#FF6347\",\r\n    \"TURQUOISE\": \"#40E0D0\",\r\n    \"VIOLET\": \"#EE82EE\",\r\n    \"WHEAT\": \"#F5DEB3\",\r\n    \"WHITE\": \"#FFFFFF\",\r\n    \"WHITESMOKE\": \"#F5F5F5\",\r\n    \"YELLOW\": \"#FFFF00\",\r\n    \"YELLOWGREEN\": \"#9ACD32\"\r\n}","export function mod(n, m) {\r\n    return ((n % m) + m) % m;\r\n}\r\n\r\nexport function dist(x1, y1, x2, y2) {\r\n    return Math.hypot(x2 - x1, y2 - y1)\r\n}\r\n\r\nexport function avrg(...values) {\r\n    return values.reduce((a, b) => a + b) / values.length\r\n}\r\n\r\nexport function mapRange(value, inputMin, inputMax, outputMin, outputMax) {\r\n    return (value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin) + outputMin;\r\n}\r\n\r\nexport function clamp(value, min, max){\r\n    return Math.max(Math.min(value, max), min)\r\n}","export default {\r\n    line: function (x, y, x2, y2) {\r\n        let pointArr = [];\r\n\r\n        let steep = Math.abs(y2 - y) > Math.abs(x2 - x);\r\n        if (steep) {\r\n            [x, y] = [y, x];\r\n            [x2, y2] = [y2, x2];\r\n        }\r\n        let reverseFlag = false;\r\n        if (x > x2) {\r\n            [y, y2] = [y2, y];\r\n            [x, x2] = [x2, x];\r\n            reverseFlag = true;\r\n        }\r\n        let dist = {\r\n            x: x2 - x,\r\n            y: Math.abs(y2 - y)\r\n        }\r\n        let err = dist.x / 2;\r\n        let stepY = (y < y2) ? 1 : -1;\r\n        for (; x <= x2; x++) {\r\n            pointArr.push([steep ? y : x, steep ? x : y]);\r\n            err -= dist.y;\r\n            if (err < 0) {\r\n                y += stepY;\r\n                err += dist.x;\r\n            }\r\n        }\r\n        if (reverseFlag) pointArr.reverse();\r\n\r\n        pointArr.reverse();\r\n\r\n        return pointArr;\r\n    },\r\n\r\n    filledCircle: function (centerX, centerY, r) {\r\n        let pixels = [];\r\n\r\n        const squareR = r * r;\r\n\r\n        for (let _x = -r + centerX; _x < r + centerX; _x++) {\r\n            for (let _y = -r + centerY; _y < r + centerY; _y++) {\r\n                if (isIn(_x, _y)) {\r\n                    pixels.push([_x, _y])\r\n                }\r\n            }\r\n        }\r\n\r\n        function isIn(_x, _y) {\r\n            let dx = _x - centerX,\r\n                dy = _y - centerY;\r\n\r\n            if (dx * dx + dy * dy <= squareR * 0.8)\r\n                return true\r\n            return false\r\n        }\r\n\r\n        return pixels\r\n    },\r\n\r\n    square(x1, y1, x2, y2) {\r\n        const minX = Math.min(x1, x2),\r\n            minY = Math.min(y1, y2),\r\n            maxX = Math.max(x1, x2),\r\n            maxY = Math.max(y1, y2);\r\n\r\n        let pixels = [];\r\n        for (let y = minY; y < maxY+1; y++) {\r\n            for (let x = minX; x < maxX+1; x++) {\r\n                pixels.push([x, y]);\r\n            }\r\n        }\r\n\r\n        return pixels\r\n    }\r\n}","export function capitalize(str) {\r\n    return str.replace(\r\n      /[-\\w]+/g,\r\n      function(txt) {\r\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\r\n      }\r\n    );\r\n  }","export function createWebGLProgram(canvas, vertexSrc, fragmentSrc) {\r\n    let gl;\r\n    if(canvas instanceof WebGLRenderingContext){\r\n        gl = canvas;\r\n    }else{\r\n        gl = canvas.getContext('webgl');\r\n        if (!gl) throw new Error(\"WebGL is not supported\");\r\n    }\r\n\r\n    function compileShader(type, src) {\r\n        const shader = gl.createShader(type);\r\n        gl.shaderSource(shader, src);\r\n        gl.compileShader(shader);\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            console.error(gl.getShaderInfoLog(shader));\r\n            throw new Error(\"Shader compilation error\");\r\n        }\r\n        return shader;\r\n    }\r\n\r\n    const vs = compileShader(gl.VERTEX_SHADER, vertexSrc);\r\n    const fs = compileShader(gl.FRAGMENT_SHADER, fragmentSrc);\r\n\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, vs);\r\n    gl.attachShader(program, fs);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        console.error(gl.getProgramInfoLog(program));\r\n        throw new Error(\"GL linking error\");\r\n    }\r\n\r\n    const buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        -1, -1, 1, -1, -1, 1,\r\n        -1, 1, 1, -1, 1, 1\r\n    ]), gl.STATIC_DRAW);\r\n\r\n    const posLoc = gl.getAttribLocation(program, \"a_position\");\r\n    gl.enableVertexAttribArray(posLoc);\r\n    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\r\n\r\n    return { gl, program };\r\n}\r\n\r\nexport function createTexture(gl, sourceCanvas) {\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\r\n                  gl.UNSIGNED_BYTE, sourceCanvas);\r\n\r\n    return texture;\r\n}\r\nconst defaultVertexShader = `\r\n        attribute vec2 a_position;\r\n        varying vec2 v_texCoord;\r\n        void main() {\r\n            v_texCoord = (a_position + 1.0) * 0.5;\r\n            // for some reason Y is inverted by default\r\n            v_texCoord.y = 1.0 - v_texCoord.y;\r\n            gl_Position = vec4(a_position, 0.0, 1.0);\r\n        }\r\n        `\r\nexport function generateShader(canvas, fragmentShader, needCreateTexture=true) {\r\n    const { gl, program } = createWebGLProgram(canvas, defaultVertexShader, fragmentShader);\r\n\r\n    let texture;\r\n    if(needCreateTexture){\r\n        texture = createTexture(gl, canvas);\r\n    }\r\n\r\n    gl.useProgram(program);\r\n\r\n    return { gl, program, texture };\r\n}","import { getLS, setLS } from '../utils/localStorage';\r\nimport { loadImage } from '../utils/misc';\r\nimport globals from '../globals';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\nimport { FX } from '../fxcanvas';\r\nimport { clamp, mapRange } from '../utils/math';\r\nimport camera from '../camera';\r\nimport player from '../player';\r\n\r\nimport winampFontPng from '../../font/pixel/winamp.png';\r\nimport winampFontDesc from '../../font/pixel/winamp.txt';\r\nimport { PixelFont } from '../tools';\r\n\r\nimport startBtnImg from '../../img/winamp/enableRadioBtn.png';\r\nimport { apiRequest } from '../utils/api';\r\n\r\n\r\nasync function importMaterials() {\r\n    require.context('../../img/winamp', false, /\\.png$/)\r\n    const images = {\r\n        bg: await import('../../img/winamp/bg2.png'),\r\n        hrSlider: await import('../../img/winamp/hr-slider-btn-small.png'),\r\n        hrSliderBig: await import('../../img/winamp/slider-btn.png'),\r\n        digits: await import('../../img/winamp/digits.png'),\r\n    }\r\n\r\n    const wFont = new PixelFont(winampFontPng, winampFontDesc);\r\n    await wFont.load();\r\n\r\n    return {\r\n        images,\r\n        fonts: {\r\n            winamp: wFont\r\n        }\r\n    }\r\n}\r\n\r\nclass UIRect {\r\n    constructor(x, y, w, h) {\r\n        Object.assign(this, {\r\n            x, y, w, h\r\n        });\r\n    }\r\n}\r\n\r\nlet tempColors;\r\nfunction preserveColors() {\r\n    tempColors = [player.color, player.secondCol];\r\n\r\n    player.switchColor(-1);\r\n    player.switchSecondColor(-1);\r\n}\r\nfunction restoreColors() {\r\n    player.switchColor(tempColors[0]);\r\n    player.switchSecondColor(tempColors[1]);\r\n}\r\n\r\nexport function initRadio() {\r\n    const player = new WinampPlayer();\r\n    player.init();\r\n    window.wPlayer = player;\r\n}\r\n\r\nlet documentClicked = false, onDocumentClickCallbacks = [];\r\ndocument.addEventListener('click', () => {\r\n    documentClicked = true;\r\n\r\n    onDocumentClickCallbacks.forEach(cb => cb());\r\n    onDocumentClickCallbacks.length = 0;\r\n})\r\n\r\nexport async function createRadioStarterBtn() {\r\n    const btnImg = await loadImage(startBtnImg);\r\n    const bW = btnImg.width;\r\n    const bH = btnImg.height;\r\n\r\n    const bX = -btnImg.width - 5;\r\n    const bY = 0;\r\n\r\n    function renderBtn(ctx) {\r\n        const z = camera.zoom;\r\n        const [canvasX, canvasY] = boardToScreenSpace(bX, bY);\r\n\r\n        if (this.needRender)\r\n            this.redraw();\r\n\r\n        ctx.save();\r\n        ctx.scale(z, z);\r\n        ctx.drawImage(btnImg, canvasX / z, canvasY / z);\r\n        ctx.restore();\r\n\r\n        return 1;\r\n    }\r\n\r\n    let btnFx = new FX(renderBtn);\r\n    globals.fxRenderer.add(btnFx, 2);\r\n\r\n    let mousedownAt = 0, listeners = [];\r\n    function onMousedown(e) {\r\n        const boardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (checkIsButtonPos(...boardPos)) {\r\n            mousedownAt = Date.now();\r\n        }\r\n    }\r\n\r\n    async function onMouseup(e) {\r\n        const boardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (checkIsButtonPos(...boardPos)) {\r\n            if (Date.now() - mousedownAt < 500) {\r\n                await onBtnClick();\r\n            }\r\n        }\r\n    }\r\n\r\n    globals.eventManager.on('mousedown', onMousedown);\r\n    globals.eventManager.on('mouseup', onMouseup);\r\n\r\n    listeners.push(['mousedown', onMousedown]);\r\n    listeners.push(['mouseup', onMouseup]);\r\n\r\n    function removeBtn() {\r\n        if (btnFx) {\r\n            globals.fxRenderer.remove(btnFx);\r\n            btnFx = null;\r\n        }\r\n        for (const [ev, fn] of listeners) {\r\n            globals.eventManager.off(ev, fn);\r\n        }\r\n        listeners = [];\r\n    }\r\n\r\n    async function onBtnClick() {\r\n        removeBtn();\r\n\r\n        initRadio();\r\n    }\r\n\r\n    function checkIsButtonPos(x, y) {\r\n        return x >= bX && x < bX + bW && y >= bY && y < bY + bH;\r\n    }\r\n}\r\n\r\nclass WinampPlayer {\r\n    constructor() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        this.playerPosition = JSON.parse(getLS('winamp.position', true) || '[-275,0]');\r\n        this.sndBalance = 0; // -1; 1\r\n        this.volumeLvl = +(getLS('winamp.volume', true) || '0.5'); // 0; 1\r\n\r\n        this.queue = null;\r\n        this.currentTrack = null;\r\n\r\n        this.images = null;\r\n        this.needRender = true;\r\n\r\n        this.startPolling();\r\n\r\n        this.config = {\r\n            width: 275,\r\n            height: 348,\r\n            headerRect: new UIRect(2, 2, 262, 12),\r\n            closeBtnRect: new UIRect(265, 4, 7, 7),\r\n            volumeBoundsRect: new UIRect(108, 61, 63, 4),\r\n            soundBalanceBoundsRect: new UIRect(178, 61, 35, 4),\r\n            volumeSliderRect: new UIRect(-1, -1, -1, -1),\r\n            balanceSliderRect: new UIRect(-1, -1, -1, -1),\r\n            titleRect: new UIRect(111, 24, 155, 12),\r\n            kbpsRect: new UIRect(111, 41, 16, 10),\r\n            khzRect: new UIRect(156, 41, 11, 10),\r\n            mm1Rect: new UIRect(48, 26, 9, 13),\r\n            mm2Rect: new UIRect(60, 26, 9, 13),\r\n            ss1Rect: new UIRect(78, 26, 9, 13),\r\n            ss2Rect: new UIRect(90, 26, 9, 13),\r\n            progressSliderBndRect: new UIRect(16, 72, 249, 10),\r\n            queueBoxRect: new UIRect(18, 257, 238, 48)\r\n        }\r\n\r\n        this._cache = {};\r\n        this._holdingButton = null;\r\n        this._lastHoldPos = null;\r\n        this._destroyed = false;\r\n        this.noFeed = false;\r\n        this.title = null;\r\n        this.visibleTitle = null;\r\n\r\n        this._boundHandlers = {};\r\n        this._socketHandlers = {};\r\n    }\r\n\r\n    addAudioStoppedListeners() {\r\n        this.audio.addEventListener(\"pause\", () => {\r\n            // controls are disabled, but you can still\r\n            // press \"pause/play\" button and it will stop\r\n            // the player. this is not good because the \r\n            // whole radio will be screwed\r\n            if (!this.audio._destroyed) {\r\n                this.audio.play().catch(err => {\r\n                    console.warn(\"Resume blocked until user interaction:\", err);\r\n                });\r\n            }\r\n        });\r\n\r\n        this.audio.addEventListener(\"stalled\", () => {\r\n            console.warn(\"Stream stalled\");\r\n            this.restartStream();\r\n        });\r\n\r\n        this.audio.addEventListener(\"error\", (e) => {\r\n            console.error(\"Audio error\", e);\r\n            this.restartStream();\r\n        });\r\n\r\n        this.audio.addEventListener(\"ended\", () => {\r\n            console.warn(\"Stream ended\");\r\n            this.restartStream();\r\n        });\r\n    }\r\n\r\n    async init() {\r\n        setLS('radioLover', '1');\r\n\r\n        await this.loadMaterials();\r\n        this.recalculateButtons();\r\n        this.initTouchControls();\r\n        this.setTitle('Goroxels Radio 1.0 alpha');\r\n\r\n        this.canvas.width = this.config.width;\r\n        this.canvas.height = this.config.height;\r\n\r\n        this._fx = new FX(this.render.bind(this));\r\n        globals.fxRenderer.add(this._fx, 2);\r\n\r\n        await this.updateSong();\r\n        this.startPolling();\r\n\r\n        // socket handlers\r\n        this._socketHandlers.radio = (type) => {\r\n            switch (type) {\r\n                case 0: this.updateSong(); break;\r\n                case 1: this.updateQueue(); break;\r\n            }\r\n        };\r\n        this._socketHandlers.opened = () => {\r\n            this.updateSong();\r\n        };\r\n\r\n        globals.socket.on('radio', this._socketHandlers.radio);\r\n        globals.socket.on('opened', this._socketHandlers.opened);\r\n\r\n        this.ackRender();\r\n        this.initAutoRender();\r\n    }\r\n\r\n    volume(val) {\r\n        this.volumeLvl = val;\r\n        this.gainNode.gain.value = val;\r\n        setLS('winamp.volume', val.toString(), true);\r\n    }\r\n\r\n    balance(val) {\r\n        this.sndBalance = val;\r\n        this.pannerNode.pan.value = val;\r\n    }\r\n\r\n\r\n    initAutoRender() {\r\n        setInterval(() => this.ackRender(), 1000);\r\n    }\r\n\r\n    initTouchControls() {\r\n        const self = this;\r\n\r\n        function mousedown(e) {\r\n            if (self._holdingButton) mouseup(e);\r\n            let obj = self.getObjectAtPosition(e.clientX, e.clientY);\r\n            if (obj) {\r\n                preserveColors();\r\n                camera.disableMove();\r\n                self.onObjMousedown.call(self, obj, e);\r\n                self._lastHoldPos = screenToBoardSpace(e.clientX, e.clientY);\r\n            }\r\n        }\r\n        function mouseup(e) {\r\n            self._lastHoldPos = null;\r\n            camera.enableMove();\r\n            if (self._holdingButton) {\r\n                self.onObjMouseup.call(self, self._holdingButton, e);\r\n                self._holdingButton = false;\r\n                setTimeout(restoreColors);\r\n            }\r\n        }\r\n        function mousemove(e) {\r\n            if (self._holdingButton) {\r\n                self.onObjMousemove.call(self, self._holdingButton, e);\r\n                self._lastHoldPos = screenToBoardSpace(e.clientX, e.clientY);\r\n            }\r\n        }\r\n\r\n        this._boundHandlers.mousedown = (e) => {\r\n            if (this._destroyed) return;\r\n            if (e.gesture) return mouseup(e);\r\n            mousedown(e);\r\n        };\r\n        this._boundHandlers.mouseup = (e) => {\r\n            if (this._destroyed) return;\r\n            mouseup(e);\r\n        };\r\n        this._boundHandlers.mousemove = (e) => {\r\n            if (this._destroyed) return;\r\n            if (e.gesture) return;\r\n            mousemove(e);\r\n        };\r\n\r\n        globals.eventManager.on('mousedown', this._boundHandlers.mousedown);\r\n        globals.eventManager.on('mouseup', this._boundHandlers.mouseup);\r\n        globals.eventManager.on('mousemove', this._boundHandlers.mousemove);\r\n    }\r\n\r\n    close() {\r\n        setLS('radioLover', '0');\r\n\r\n        if (this.audio) {\r\n            this.audio._destroyed = true;\r\n            this.audio.pause();\r\n            this.audio.src = \"\";\r\n            this.audio.remove();\r\n        }\r\n\r\n        if (this.audioCtx) {\r\n            this.audioCtx.close();\r\n        }\r\n\r\n        clearTimeout(this.__pollTimeout);\r\n        clearInterval(this._titleRollerInterval);\r\n        globals.fxRenderer.remove(this._fx);\r\n\r\n        // remove eventManager handlers\r\n        if (this._boundHandlers) {\r\n            globals.eventManager.off('mousedown', this._boundHandlers.mousedown);\r\n            globals.eventManager.off('mouseup', this._boundHandlers.mouseup);\r\n            globals.eventManager.off('mousemove', this._boundHandlers.mousemove);\r\n            this._boundHandlers = {};\r\n        }\r\n\r\n        // remove socket handlers\r\n        if (this._socketHandlers) {\r\n            globals.socket.off('radio', this._socketHandlers.radio);\r\n            globals.socket.off('opened', this._socketHandlers.opened);\r\n            this._socketHandlers = {};\r\n        }\r\n\r\n        this._destroyed = true;\r\n\r\n\r\n        createRadioStarterBtn();\r\n    }\r\n\r\n    getObjectAtPosition(screenX, screenY) {\r\n        const objsToCheck = [\r\n            this.config.headerRect,\r\n            this.config.closeBtnRect,\r\n            this.config.volumeSliderRect,\r\n            this.config.balanceSliderRect,\r\n        ];\r\n\r\n        const [boardX, boardY] = screenToBoardSpace(screenX, screenY);\r\n        const [playerX, playerY] = this.getRelPos(boardX, boardY);\r\n\r\n        for (let obj of objsToCheck) {\r\n            if (playerX >= obj.x && playerX < obj.x + obj.w &&\r\n                playerY >= obj.y && playerY < obj.y + obj.h) {\r\n                return obj;\r\n            }\r\n        }\r\n    }\r\n\r\n    onObjMousedown(obj) {\r\n        this._holdingButton = obj;\r\n    }\r\n    onObjMouseup(obj, e) {\r\n        switch (obj) {\r\n            case this.config.closeBtnRect: {\r\n                if (this.getObjectAtPosition(e.clientX, e.clientY) === this.config.closeBtnRect) {\r\n                    this.close();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    onObjMousemove(obj, e) {\r\n        const [movX, movY] = this.calcMovement(e);\r\n\r\n        switch (obj) {\r\n            case this.config.headerRect: {\r\n                this.playerPosition[0] += movX;\r\n                this.playerPosition[1] += movY;\r\n\r\n                setLS('winamp.position', JSON.stringify(this.playerPosition), true);\r\n\r\n                this.ackRender();\r\n\r\n                break;\r\n            }\r\n            case this.config.volumeSliderRect: {\r\n                const [relX] = this.getRelPos(...screenToBoardSpace(e.clientX, e.clientY));\r\n\r\n                const bndRect = this.config.volumeBoundsRect;\r\n                const sliderImg = this.images.hrSlider;\r\n\r\n                const [clampedX, clampedY] = this.clampHrSliderPos(relX, bndRect, sliderImg);\r\n\r\n                this.config.volumeSliderRect.x = clampedX;\r\n                this.config.volumeSliderRect.y = clampedY;\r\n\r\n                const newValue = this.mapHrSliderPos(clampedX, bndRect, sliderImg, 0, 1);\r\n                this.volume(newValue);\r\n\r\n                this.ackRender();\r\n\r\n                break;\r\n            }\r\n\r\n            case this.config.balanceSliderRect: {\r\n                const [relX] = this.getRelPos(...screenToBoardSpace(e.clientX, e.clientY));\r\n\r\n                const bndRect = this.config.soundBalanceBoundsRect;\r\n                const sliderImg = this.images.hrSlider;\r\n\r\n                const [clampedX, clampedY] = this.clampHrSliderPos(relX, bndRect, sliderImg);\r\n\r\n                this.config.balanceSliderRect.x = clampedX;\r\n                this.config.balanceSliderRect.y = clampedY;\r\n\r\n                const newValue = this.mapHrSliderPos(clampedX, bndRect, sliderImg, -1, 1);\r\n                this.balance(newValue);\r\n\r\n                this.ackRender();\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // clamp mouse position to slider bounds\r\n    clampHrSliderPos(relX, bndRect, sliderImg) {\r\n        // center the slider to the mouse pos\r\n        relX -= sliderImg.width / 2;\r\n\r\n        const clampX = clamp(relX, bndRect.x, bndRect.x + bndRect.w - sliderImg.width);\r\n        const constY = bndRect.y + (bndRect.h / 2) - (sliderImg.height / 2) + 1;\r\n\r\n        return [clampX | 0, constY | 0];\r\n    }\r\n\r\n    // convert slider position to output value\r\n    mapHrSliderPos(posX, bndRect, sliderImg, minValue, maxValue) {\r\n        const minPosX = bndRect.x;\r\n        const maxPosX = bndRect.x + bndRect.w - sliderImg.width;\r\n\r\n        const mappedVal = mapRange(posX, minPosX, maxPosX, minValue, maxValue);\r\n        return mappedVal;\r\n    }\r\n\r\n    // convert value to position\r\n    reverseMapHrSliderPos(value, bndRect, sliderImg, minValue, maxValue) {\r\n        const minPosX = bndRect.x;\r\n        const maxPosX = bndRect.x + bndRect.w - sliderImg.width;\r\n\r\n        const mappedPosX = mapRange(value, minValue, maxValue, minPosX, maxPosX);\r\n        return mappedPosX | 0;\r\n    }\r\n\r\n    // convert global board position to local canvas position\r\n    getRelPos(boardX, boardY) {\r\n        const playerX = boardX - this.playerPosition[0];\r\n        const playerY = boardY - this.playerPosition[1];\r\n\r\n        return [playerX, playerY];\r\n    }\r\n\r\n    // getHrSliderPos(minX, maxX, )\r\n\r\n    calcMovement(e) {\r\n        if (!this._lastHoldPos) {\r\n            return null;\r\n        }\r\n\r\n        const curBoardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n\r\n        const diffX = curBoardPos[0] - this._lastHoldPos[0];\r\n        const diffY = curBoardPos[1] - this._lastHoldPos[1];\r\n\r\n        return [diffX, diffY];\r\n    }\r\n\r\n    async loadMaterials() {\r\n        const {\r\n            images: urlsObj,\r\n            fonts\r\n        } = await importMaterials();\r\n\r\n        const imgObj = {};\r\n        for (let key of Object.keys(urlsObj)) {\r\n            let url = urlsObj[key].default;\r\n\r\n            imgObj[key] = await loadImage(url);\r\n        }\r\n\r\n        this.images = imgObj;\r\n        this.fonts = fonts;\r\n    }\r\n\r\n    ackRender() {\r\n        this.needRender = true;\r\n        globals.fxRenderer.requestRender();\r\n    }\r\n\r\n    render(ctx) {\r\n        if (this._destroyed) return 2;\r\n\r\n        const [x, y] = boardToScreenSpace(this.playerPosition[0], this.playerPosition[1]);\r\n        const z = camera.zoom;\r\n\r\n        if (this.needRender)\r\n            this.redraw();\r\n\r\n        ctx.save();\r\n        ctx.scale(z, z);\r\n        ctx.drawImage(this.canvas, x / z, y / z);\r\n        ctx.restore();\r\n\r\n        return 1\r\n    }\r\n\r\n    generateQueueText() {\r\n        if (!this.queue) return '';\r\n\r\n        const queue = [\r\n            ...this.queue.queue,\r\n            ...this.queue.defaultQueue\r\n        ].slice(0, 7);\r\n\r\n        const str = queue.map(s => {\r\n            let title = cutTextToWidth(s.title, 190);\r\n            return `${s.id ?? 'x'}. ${title} <${s.duration / 60 | 0}:${pad2(s.duration % 60 | 0)}>`\r\n\r\n            function cutTextToWidth(text, maxWidth) {\r\n                let curWidth = 0;\r\n                let curText = '';\r\n                for (const ch of text) {\r\n                    // every dot is 3px wide\r\n                    if (curWidth >= maxWidth - 9) {\r\n                        curText += '...';\r\n                        break;\r\n                    }\r\n\r\n                    if (ch === ' ' || /[-]/.test(ch)) curWidth += 5;\r\n                    else if (/[A-z]/.test(ch)) curWidth += 4;\r\n                    else if (ch === '.') curWidth += 2;\r\n                    else curWidth += 4;\r\n\r\n                    curWidth += 1;\r\n\r\n                    curText += ch;\r\n                }\r\n\r\n                return curText;\r\n            }\r\n        }).join('\\n');\r\n\r\n        return str;\r\n    }\r\n\r\n    redraw() {\r\n        this.needRender = false;\r\n\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.drawImage(this.images.bg, 0, 0);\r\n        this.ctx.drawImage(this.images.hrSlider, this.config.volumeSliderRect.x, this.config.volumeSliderRect.y);\r\n        this.ctx.drawImage(this.images.hrSlider, this.config.balanceSliderRect.x, this.config.balanceSliderRect.y);\r\n\r\n        this.drawTextInInput(this.title, this.config.titleRect, '#00E200');\r\n\r\n        if (this.currentTrack) {\r\n            const kbps = (2 * 2 * this.currentTrack.sampleRate) / 1000 | 0; // channels*sampleSize(16bit=2byte)*sampleRate\r\n            const khz = this.currentTrack.sampleRate / 1000 | 0;\r\n\r\n            this.drawTextInInput(kbps.toString(), this.config.kbpsRect, '#00E200');\r\n            this.drawTextInInput(khz.toString(), this.config.khzRect, '#00E200');\r\n\r\n            const sPassed = (Date.now() - this.currentTrack.startedAt) / 1000;\r\n\r\n            const mmPassed = pad2((sPassed / 60 | 0).toString());\r\n            const ssPassed = pad2((sPassed % 60 | 0).toString());\r\n\r\n            this.drawBigDigit(this.config.mm1Rect, mmPassed[0]);\r\n            this.drawBigDigit(this.config.mm2Rect, mmPassed[1]);\r\n            this.drawBigDigit(this.config.ss1Rect, ssPassed[0]);\r\n            this.drawBigDigit(this.config.ss2Rect, ssPassed[1]);\r\n\r\n            const progressPosX = this.reverseMapHrSliderPos(sPassed, this.config.progressSliderBndRect, this.images.hrSliderBig, 0, this.currentTrack.duration);\r\n            const progressPosY = this.config.progressSliderBndRect.y;\r\n\r\n            this.ctx.drawImage(this.images.hrSliderBig, progressPosX, progressPosY);\r\n        }\r\n\r\n        // this shit eats a lot of cpu\r\n        const queueText = this.generateQueueText();\r\n        if (queueText && queueText !== this._cache.queueText) {\r\n            const qTextImg = this.fonts.winamp.drawText(queueText, '#00E200');\r\n            if (qTextImg) {\r\n                this._cache.queueTextImg = qTextImg;\r\n                this._cache.queueText = queueText;\r\n                this.ctx.drawImage(qTextImg, this.config.queueBoxRect.x, this.config.queueBoxRect.y);\r\n            }\r\n        } else if (queueText) {\r\n            this.ctx.drawImage(this._cache.queueTextImg, this.config.queueBoxRect.x, this.config.queueBoxRect.y);\r\n        }\r\n    }\r\n\r\n    drawBigDigit(rect, number) {\r\n        const digitW = rect.w;\r\n        this.ctx.drawImage(this.images.digits, digitW * number, 0, rect.w, rect.h, rect.x, rect.y, rect.w, rect.h);\r\n    }\r\n\r\n    drawTextInInput(text, inputRect, color) {\r\n        const drawnText = this.fonts.winamp.drawText(text, color);\r\n        this.ctx.drawImage(drawnText, 0, 0, inputRect.w, drawnText.height, inputRect.x, ((inputRect.y + inputRect.h / 2) - drawnText.height / 2) | 0, inputRect.w, drawnText.height);\r\n    }\r\n\r\n    recalculateButtons() {\r\n        const smallSliderWidth = this.images.hrSlider.width;\r\n        const smallSliderHeight = this.images.hrSlider.height;\r\n\r\n        const volRect = this.config.volumeBoundsRect;\r\n        const volSliderX = mapRange(this.volumeLvl, 0, 1, volRect.x, (volRect.x + volRect.w) - smallSliderWidth);\r\n        const volSliderY = ((volRect.y + volRect.h / 2) - smallSliderHeight / 2) + 1\r\n\r\n        this.config.volumeSliderRect.x = volSliderX | 0;\r\n        this.config.volumeSliderRect.y = volSliderY | 0;\r\n        this.config.volumeSliderRect.w = smallSliderWidth;\r\n        this.config.volumeSliderRect.h = smallSliderHeight;\r\n\r\n        const balRect = this.config.soundBalanceBoundsRect;\r\n        const balSliderX = mapRange(this.sndBalance, -1, 1, balRect.x, (balRect.x + balRect.w) - smallSliderWidth);\r\n        const balSliderY = ((balRect.y + balRect.h / 2) - smallSliderHeight / 2) + 1\r\n\r\n        this.config.balanceSliderRect.x = balSliderX | 0;\r\n        this.config.balanceSliderRect.y = balSliderY | 0;\r\n        this.config.balanceSliderRect.w = smallSliderWidth;\r\n        this.config.balanceSliderRect.h = smallSliderHeight;\r\n    }\r\n\r\n    initAudioChain() {\r\n        if (!this.audioCtx || this.audioCtx.state === \"closed\") {\r\n            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\r\n        }\r\n\r\n        this.gainNode = this.audioCtx.createGain();\r\n        this.gainNode.gain.value = this.volumeLvl;\r\n\r\n        this.pannerNode = this.audioCtx.createStereoPanner();\r\n        this.pannerNode.pan.value = this.sndBalance;\r\n\r\n        if (this.audio) {\r\n            try { this.audio._destroyed = true; } catch { }\r\n            try { this.audio.pause(); } catch { }\r\n            try { this.audio.remove(); } catch { }\r\n        }\r\n\r\n        this.audio = document.createElement(\"audio\");\r\n        this.audio.autoplay = true;\r\n        this.audio.controls = false;\r\n        this.audio._destroyed = false;\r\n\r\n        this.addAudioStoppedListeners();\r\n\r\n        const srcNode = this.audioCtx.createMediaElementSource(this.audio);\r\n        srcNode.connect(this.gainNode).connect(this.pannerNode).connect(this.audioCtx.destination);\r\n    }\r\n\r\n    async startStream() {\r\n        if (this._destroyed) return;\r\n        if (this._streaming) return;\r\n\r\n        this._streaming = true;\r\n\r\n        const startFn = () => {\r\n            try {\r\n                if (!this.audio || this.audio._destroyed) {\r\n                    this.initAudioChain();\r\n                }\r\n\r\n                this.audio.src = `${location.protocol}//${location.hostname}/api/radio/stream`;\r\n                this.audio.autoplay = true;\r\n\r\n                const playPromise = this.audio.play();\r\n                if (playPromise) {\r\n                    playPromise.catch(err => console.warn(\"Playback blocked until user interaction:\", err));\r\n                }\r\n            } catch (err) {\r\n                console.error(\"Failed to start stream:\", err);\r\n                this._streaming = false;\r\n\r\n                if (!this._destroyed) {\r\n                    setTimeout(() => this.startStream(), 5000);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (!documentClicked) {\r\n            onDocumentClickCallbacks.push(startFn);\r\n        } else {\r\n            startFn();\r\n        }\r\n    }\r\n\r\n    async restartStream() {\r\n        if (this._destroyed) return;\r\n        this._streaming = false;\r\n        console.info(\"Restarting radio stream...\");\r\n        await this.startStream();\r\n    }\r\n\r\n    async startPolling() {\r\n        if (this._destroyed) return;\r\n        await this.startStream();\r\n    }\r\n\r\n\r\n    async updateSong() {\r\n        if (this._destroyed) return;\r\n\r\n        this.noFeed = true;\r\n\r\n        const song = await this.fetchCurTrack();\r\n\r\n        this.currentTrack = song;\r\n\r\n        const curTrackMins = song.duration / 60 | 0;\r\n        const curTrackSecs = song.duration % 60 | 0;\r\n        this.setTitle(this.currentTrack.title + ` <${curTrackMins}:${pad2(curTrackSecs)}>`);\r\n\r\n\r\n        this.noFeed = false;\r\n\r\n        this.ackRender();\r\n\r\n        this.updateQueue().then(() => this.ackRender());\r\n    }\r\n\r\n    async updateQueue() {\r\n        const queue = await this.fetchQueue();\r\n        if (!queue) return;\r\n\r\n        this.queue = queue;\r\n        this.ackRender();\r\n    }\r\n\r\n    async fetchCurTrack() {\r\n        const resp = await apiRequest('/radio/current-song');\r\n        const json = await resp.json();\r\n        if (!json.success) {\r\n            // toastr.error('cannot fetch current song! reload the page.');\r\n            return\r\n        }\r\n\r\n        return json.song;\r\n    }\r\n\r\n    async fetchQueue() {\r\n        const resp = await apiRequest('/radio/get-queue');\r\n        const json = await resp.json();\r\n        if (!json.success) {\r\n            // toastr.warn('cannot fetch song queue');\r\n            return\r\n        }\r\n\r\n        return json.queues;\r\n    }\r\n\r\n    setTitle(title) {\r\n        this._titleSet = Date.now();\r\n\r\n        this.title = title;\r\n\r\n        clearInterval(this._titleRollerInterval)\r\n\r\n        // roll only if it exceeds input width\r\n        if (this.fonts.winamp.measureText(this.title).width > this.config.titleRect.w) {\r\n            this._titleRollerInterval = setInterval(() => {\r\n                // rotate title by 1 char\r\n                const titleArr = this.title.split('');\r\n                titleArr.push(titleArr.shift());\r\n\r\n                this.title = titleArr.join('');\r\n                this.ackRender();\r\n            }, 300);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction pad2(num) {\r\n    return num.toString().padStart(2, '0');\r\n}\r\n\r\nexport function startWinampRadio() {\r\n    if (getLS('radioLover') === '1') {\r\n        initRadio();\r\n    } else {\r\n        createRadioStarterBtn();\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport default WinampPlayer","import toastr from 'toastr';\r\n\r\nimport chat, { fixChatPosition, toggleEmojis, updateEmojis } from './Chat';\r\nimport { game, showProtected } from './config';\r\nimport { ROLE, ROLE_I } from './constants';\r\nimport { urlInput } from './ui/elements';\r\nimport globals from './globals';\r\nimport { showHistoryCanvas, unloadHistoryCanvas, wipes } from './history';\r\nimport me from './me';\r\nimport player, { togglePlaced, updateBrush, updateMe } from './player';\r\nimport tools from './tools';\r\nimport { translate as t, translate as tr } from './translate';\r\nimport User from './user';\r\nimport Window, { ConfirmModal } from './Window';\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport { capitalize } from './utils/strings';\r\nimport { decodeKey, getEventKeyCode, htmlspecialchars, makeScreenshot, reverseFade, stringifyKeyEvent } from './utils/misc';\r\n\r\nimport arrowSvg from '../img/arrow.svg';\r\nimport desktopIcon from '../img/icon-desktop.svg';\r\nimport mobileIcon from '../img/icon-phone.svg';\r\nimport userImg from '../img/user2.png';\r\nimport dsLogo from '../img/discord-logo-circle.svg';\r\nimport ggLogo from '../img/gg-logo.svg';\r\nimport vkLogo from '../img/vk-logo.svg';\r\n\r\nimport lmbIcon from '../img/mouse/mouse-lmb.png';\r\nimport rmbIcon from '../img/mouse/mouse-rmb.png';\r\nimport mmbIcon from '../img/mouse/mouse-mmb.png';\r\nimport mb4Icon from '../img/mouse/mouse-4mb.png';\r\nimport mb5Icon from '../img/mouse/mouse-5mb.png';\r\nimport { apiRequest, fetchCaptcha, solveCaptcha } from './utils/api';\r\nimport { shareTemplate, showTemplates, updateTemplate } from './template';\r\nimport { setPaletteColorsSize, showPatternsOnPalette, swapToolsPos, unloadPalettePatterns } from './ui/config';\r\n\r\n\r\nconst mouseKeys = {\r\n    'LMB': lmbIcon,\r\n    'RMB': rmbIcon,\r\n    'MMB': mmbIcon,\r\n    '4MB': mb4Icon,\r\n    '5MB': mb5Icon,\r\n}\r\n\r\nexport function initButtons() {\r\n    $('#accountSettings').on('click', accountSettings);\r\n    $('#toolBinds').on('click', keyBinds);\r\n    $('#uiSettings').on('click', uiSettings);\r\n    $('#canvasSettings').on('click', gameSettings);\r\n    $('#toolsB').on('click', toolsWindow);\r\n    $('.authBtn').on('click', authWindow);\r\n    $('#showTemplates').on('click', showTemplates);\r\n    $('#shareTemplate').on('click', shareTemplate);\r\n}\r\n\r\nexport function initHelpButton() {\r\n    $('.helpBtn').on('click', () => {\r\n        help();\r\n    })\r\n}\r\n\r\nexport function showHelpIfFirstTime() {\r\n    const shownAlready = getLS('helpShown');\r\n    if (!shownAlready) {\r\n        setLS('helpShown', '1');\r\n        help();\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function initOnlineViewer() {\r\n    $('#onlineColumn .columnHeader').on('click', async () => {\r\n        let json;\r\n        try {\r\n            const resp = await fetch('/api/online');\r\n            json = await resp.json();\r\n        } catch (e) {\r\n            toastr.error(e);\r\n            return\r\n        }\r\n\r\n        onlineViewWindow(json);\r\n    });\r\n}\r\n\r\n\r\nfunction createCollapsibleBlock(title, bodyHtml, collapsed = true) {\r\n    const head = $('<div>');\r\n    head[0].style.cssText =\r\n        `width: 100%;\r\n    height: 30px;\r\n    background-color: #5f5f5f;\r\n    position: relative;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    user-select: none;\r\n    cursor: pointer`\r\n\r\n    head.append(`<div style=\"font-size:20px;text-transform:uppercase;\">${title}</div>`)\r\n\r\n    const arrow = $('<div>');\r\n    arrow[0].style.cssText =\r\n        `position: absolute;\r\n    top: 50%;\r\n    transform: translate(0, -50%);\r\n    left: 5px;\r\n    background-image: url(${arrowSvg});\r\n    background-size: 100%;\r\n    background-repeat: no-repeat;\r\n    transition: transform .2s ease-in-out;\r\n    width: 20px;\r\n    height: 20px;`\r\n\r\n    head.append(arrow);\r\n\r\n    const body = $('<div>');\r\n    body[0].style.cssText =\r\n        `max-height: 0;\r\n    overflow: hidden;\r\n    transition: max-height 0.3s linear;\r\n    font-size: 20px;`\r\n\r\n    const innerBody = $('<div>');\r\n    innerBody[0].style.cssText =\r\n        `padding:8px`\r\n    innerBody.html(bodyHtml);\r\n\r\n    body.append(innerBody);\r\n\r\n    const headBodyContainer = $('<div>');\r\n    headBodyContainer[0].style.cssText =\r\n        `margin-bottom: 1px;`\r\n    headBodyContainer.append(head, body)\r\n\r\n    let state = 0; // 0 - closed, 1 - opened\r\n    let reCheckHeightIntervalId = null;\r\n    function toggle() {\r\n        clearTimeout(reCheckHeightIntervalId);\r\n        if (state) {\r\n            arrow.css('transform', 'translate(0px, -50%) rotate(0deg)');\r\n            body.css('max-height', 0);\r\n        } else {\r\n            arrow.css('transform', 'translate(0px, -50%) rotate(180deg)');\r\n\r\n            requestAnimationFrame(() => {\r\n                // force layout calc reflow\r\n                // otherwise scrollHeight may be not updated\r\n                body[0].offsetHeight;\r\n\r\n                body.css('max-height', body[0].scrollHeight);\r\n\r\n                reCheckHeightIntervalId = setTimeout(() => {\r\n                    body.css('max-height', body[0].scrollHeight);\r\n                }, 300);\r\n            });\r\n        }\r\n        state = !state;\r\n    }\r\n    if (!collapsed) setTimeout(toggle);\r\n\r\n    head.on('click', toggle);\r\n\r\n    return headBodyContainer\r\n}\r\n\r\nexport function generateTable(arr = []) {\r\n    const table = $('<table class=\"columnTable\"></table>');\r\n    arr.forEach(([title, content]) => {\r\n        let tableBlock = $(`\r\n                <tr>\r\n                    ${content === void 0 ?\r\n                `<td colspan=\"2\">${title}</td>` :\r\n                `<td>${title}</td>\r\n                        <td>${content}</td>`\r\n            }\r\n                </tr>`);\r\n        table.append(tableBlock)\r\n    });\r\n\r\n    return table\r\n}\r\n\r\nexport function accountSettings() {\r\n    const settingsWin = new Window({\r\n        title: capitalize(t('account settings')),\r\n        center: true\r\n    });\r\n    if (!settingsWin.created) return;\r\n\r\n    let html = generateTable([\r\n        [tr('role'), ROLE_I[me.role].toUpperCase()],\r\n        [\r\n            tr('change name'),\r\n            `<input type=\"text\" id=\"name\" style=\"width:50%\"><button id=\"changeName\">yes</button>`\r\n        ],\r\n        [\r\n            `<button id=\"logout\">${tr('logout')}</button>`\r\n        ],\r\n        // [\r\n        //     `<button id=\"deleteAccount\">${tr('delete_account')}</button>`\r\n        // ]\r\n\r\n    ]);\r\n\r\n    $(settingsWin.body).append(html);\r\n\r\n    $('#name').val(me.name)\r\n    $('#changeName').on('click', () => {\r\n        const newName = $('#name').val();\r\n\r\n        if (!me.registered) {\r\n            return toastr.error('Hey wtf', '0_o');\r\n        }\r\n        if (newName.length < 0 || newName.length > 32) {\r\n            return toastr.error('Name length is not 0 < length < 32', 'Name change')\r\n        }\r\n        if (me.name === newName) {\r\n            return toastr.error('Name is the same as was', 'Name change')\r\n        }\r\n\r\n        fetch('/api/changename', {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                name: newName\r\n            }),\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            }\r\n        }).then(async r => {\r\n            const result = await r.json();\r\n            if (!result.errors.length) {\r\n                globals.socket.close();\r\n                toastr.success('Name successfully changed');\r\n                updateMe();\r\n            } else {\r\n                result.errors.map(e => {\r\n                    toastr.error(e, 'Name change error')\r\n                })\r\n            }\r\n        })\r\n    })\r\n\r\n    $('#logout').on('click', async () => {\r\n        if (me.registered) {\r\n            const req = await apiRequest('/auth/logout');\r\n            const success = await req.json();\r\n            if (success) {\r\n                location.pathname = '/';\r\n            } else {\r\n                toastr.error('Can\\'t log out');\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nexport function keyBinds() {\r\n    const keysWin = new Window({\r\n        title: capitalize(t('toolbinds settings')),\r\n        center: true\r\n    });\r\n    if (!keysWin.created) return;\r\n\r\n    let table = generateTable();\r\n\r\n\r\n\r\n    for (const tool of Object.values(tools)) {\r\n        if (!tool.key) continue;\r\n        if (tool.requiredRole > me.role) continue;\r\n\r\n        const tableRow = $(\r\n            `<tr>\r\n            <td>${t('toolName.' + tool.name)}</td>\r\n            <td>\r\n                <div class=\"toolKeys\" id=\"KEYS-${tool.name}\">\r\n                </div>\r\n                <button class=\"resetKeyBtn\" id=\"RESET-${tool.name}\"></button>\r\n                <button class=\"changeKeyBtn\" \"id=\"CHANGE-${tool.name}\"></button>\r\n            </td>\r\n        </tr>`);\r\n\r\n        table.append(tableRow);\r\n\r\n        const keysContainer = $('.toolKeys', tableRow);\r\n        const changeBtn = $('.changeKeyBtn', tableRow);\r\n        const resetBtn = $('.resetKeyBtn', tableRow);\r\n\r\n        changeBtn.on('click', () => {\r\n            if (globals.lockInputs) return;\r\n            globals.lockInputs = true;\r\n\r\n            keysContainer.html('<span>...</span>');\r\n\r\n            let clearFade = reverseFade(tableRow[0]);\r\n            const onkeydown = e => {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n\r\n                redrawToolKeys(e);\r\n\r\n                const code = getEventKeyCode(e);\r\n                if (isNormalKey(code) || isMouseKey(code)) {\r\n                    globals.toolManager.changeKey(tool, stringifyKeyEvent(e));\r\n                }\r\n            }\r\n            document.addEventListener('keydown', onkeydown);\r\n            document.addEventListener('pointerdown', onkeydown);\r\n\r\n            const onkeyup = e => {\r\n                const isMouse = isMouseKey(getEventKeyCode(e));\r\n                if (!isMouse && !e.code || e.code === 'ControlLeft' || e.code === 'AltLeft') return;\r\n\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n\r\n                cleanup();\r\n\r\n                globals.toolManager.saveBinds();\r\n            }\r\n\r\n            document.addEventListener('keyup', onkeyup);\r\n            document.addEventListener('pointerup', onkeyup);\r\n\r\n            function cleanup() {\r\n                clearFade?.call();\r\n                document.removeEventListener('keydown', onkeydown);\r\n                document.removeEventListener('pointerdown', onkeydown);\r\n                document.removeEventListener('keyup', onkeyup);\r\n                document.removeEventListener('pointerup', onkeyup);\r\n\r\n                globals.lockInputs = false;\r\n            }\r\n        });\r\n\r\n        resetBtn.on('click', () => {\r\n            if (globals.lockInputs) return;\r\n\r\n            redrawToolKeys(decodeKey(tool.defaultKey));\r\n\r\n            globals.toolManager.changeKey(tool, tool.defaultKey);\r\n            globals.toolManager.saveBinds();\r\n        })\r\n\r\n        function redrawToolKeys(key) {\r\n            const alt = key.alt ?? key.altKey;\r\n            const ctrl = key.ctrl ?? key.ctrlKey;\r\n\r\n            const keyCode = getEventKeyCode(key);\r\n\r\n            keysContainer.html('');\r\n\r\n            if (alt) {\r\n                keysContainer.append('<kbd>ALT</kbd> + ');\r\n            }\r\n            if (ctrl) {\r\n                keysContainer.append('<kbd>CTRL</kbd> + ');\r\n            }\r\n\r\n            if (isNormalKey(keyCode)) {\r\n                keysContainer.append(`<kbd>${keyCode}</kbd>`);\r\n            } else if (isMouseKey(keyCode)) {\r\n                const img = `<img src=\"${mouseKeys[keyCode]}\"/>`\r\n                keysContainer.append(`<kbd>${img}</kbd>`);\r\n            }\r\n        }\r\n\r\n        function isNormalKey(code) {\r\n            return code && !code.startsWith('Control') && !code.startsWith('Alt') && !isMouseKey(code)\r\n        }\r\n\r\n        function isMouseKey(code) {\r\n            return Object.keys(mouseKeys).includes(code);\r\n        }\r\n\r\n        const parsed = decodeKey(tool.key);\r\n\r\n        redrawToolKeys(parsed);\r\n    }\r\n\r\n    $(keysWin.body).append(table);\r\n}\r\n\r\nexport function uiSettings() {\r\n    const setWin = new Window({\r\n        title: capitalize(t('ui settings')),\r\n        center: true\r\n    });\r\n    if (!setWin.created) return;\r\n\r\n    const table = generateTable([\r\n        [t('colors size'), '<input type=\"range\" min=\"16\", max=\"64\" step=\"1\" id=\"colSize\"><div style=\"width:50px;\"><div>'],\r\n        [t('hide emojis'), '<input type=\"checkbox\" id=\"toggleEmojis\">'],\r\n        [t('emoji list'), '<input type=\"text\" id=\"emojiList\">'],\r\n        [`<button id=\"moreEmojis\">${t('super secret button')}</button>`],\r\n        [t('show placed pixels'), '<input type=\"checkbox\" id=\"togglePlaced\">'],\r\n        [t('show patterns over the palette'), '<input type=\"checkbox\" id=\"showPatterns\">'],\r\n        [t('tools_to_right_pos'), '<input type=\"checkbox\" id=\"swapToolsPos\">']\r\n    ]);\r\n    $(setWin.body).append(table);\r\n\r\n    function colorSizeChanged() {\r\n        const val = $('#colSize').val();\r\n        setPaletteColorsSize(val);\r\n        $('#colSize').next().text(val + 'px');\r\n        setLS('colorSize', val, true);\r\n        fixChatPosition();\r\n    }\r\n\r\n    const colSizeVal = getOrDefault('colorSize', 24, true);\r\n    $('#colSize').next().text(colSizeVal);\r\n    $('#colSize').val(colSizeVal)\r\n    $('#colSize').on('input', colorSizeChanged);\r\n\r\n    $('#toggleEmojis')[0].checked = getLS('hideEmojis') == 1;\r\n    $('#toggleEmojis').on('click', e => {\r\n        const state = !e.target.checked;\r\n        setLS('hideEmojis', state ? 0 : 1);\r\n        toggleEmojis(state);\r\n    });\r\n\r\n    $('#emojiList').val(getOrDefault('emojis', '        '));\r\n    $('#emojiList').on('change', e => {\r\n        setLS('emojis', e.target.value);\r\n        updateEmojis(e.target.value.split(' '));\r\n    })\r\n\r\n    $('#moreEmojis').on('click', () => {\r\n        const w = new Window(t('more emojis!'));\r\n        if (!w.created) return;\r\n\r\n        w.body.innerHTML = ''\r\n        w.body.style.userSelect = 'text';\r\n    });\r\n    $('#togglePlaced')[0].checked = getOrDefault('hidePlaced', 1) == 0;\r\n    $('#togglePlaced').on('click', e => {\r\n        const show = e.target.checked;\r\n        setLS('hidePlaced', show ? 0 : 1);\r\n        togglePlaced(show);\r\n    });\r\n\r\n    $('#showPatterns')[0].checked = globals.showPatterns;\r\n    $('#showPatterns').on('click', e => {\r\n        const show = e.target.checked;\r\n        globals.showPatterns = show;\r\n        setLS('showPalettePatterns', show ? '1' : '0');\r\n        show ? showPatternsOnPalette() : unloadPalettePatterns();\r\n    });\r\n\r\n    $('#swapToolsPos')[0].checked = +getOrDefault('swapToolsPos', 0) == 1;\r\n    $('#swapToolsPos').on('click', e => {\r\n        const swap = e.target.checked;\r\n        globals.showPatterns = swap;\r\n        setLS('swapToolsPos', swap ? '1' : '0');\r\n        swapToolsPos(swap);\r\n    });\r\n}\r\n\r\nexport function gameSettings() {\r\n    const win = new Window({\r\n        title: capitalize(t('game settings')),\r\n        center: true\r\n    });\r\n    if (!win.created) return;\r\n\r\n    // 1 for guests (packets disabled by server), 20 for admins, and 10 for others \r\n    let maxBrushSize = (me.role === ROLE.ADMIN ? 20 : (me.role < ROLE.USER ? 1 : 10))\r\n\r\n    const table = generateTable([\r\n        [\r\n            t('show protected'),\r\n            `<input type=\"checkbox\" id=\"showProtected\" ${game.showProtected ? 'checked' : ''}>`\r\n        ],\r\n        [\r\n            t('brush size'),\r\n            `<input type=\"checkbox\" id=\"customBrushSize\" ${player.brushSize > 1 ? 'checked' : ''}>\r\n            <input id=\"brushSize\" type=\"range\" value=\"${player.brushSize}\" ` +\r\n            `${player.brushSize == 1 ? 'disabled' : ''} min=\"2\" ` +\r\n            `max=\"${maxBrushSize}\" step=\"2\">` +\r\n            `<span id=\"brushSizeCounter\">${player.brushSize - 1}<span>`\r\n        ],\r\n        [\r\n            t('max saved pixels'),\r\n            `<input id=\"savePixelsInp\" type=\"number\" min=\"0\" value=\"${player.maxPlaced}\" style=\"width:4rem\">`\r\n        ],\r\n        [\r\n            t('disable chat colors'),\r\n            `<input type=\"checkbox\" id=\"disableChatColors\" ${chat.colorsEnabled ? '' : 'checked'}>`\r\n        ],\r\n        [\r\n            t('chat messages limit'),\r\n            `<input type=\"number\" id=\"chatLimit\" value=\"${game.chatLimit}\" title=\"maximum messages in chat\">`\r\n        ],\r\n        [\r\n            t('enable grid'),\r\n            `<input type=\"checkbox\" id=\"enableGridCB\" ${tools.grid.state == 1 ? 'checked' : ''}>`\r\n        ],\r\n        [\r\n            t('draw line length'),\r\n            `<input type=\"checkbox\" id=\"drawLineLenCB\" ${tools.line.drawLength ? 'checked' : ''} title=\"draw line length near it\">`\r\n        ],\r\n    ]);\r\n\r\n    $(win.body).append(table);\r\n\r\n    $('#showProtected').on('change', e => {\r\n        const show = e.target.checked;\r\n        game.showProtected = show;\r\n        showProtected(show);\r\n    });\r\n\r\n    $('#customBrushSize').on('change', e => {\r\n        const use = e.target.checked;\r\n\r\n        if (use) {\r\n            $('#brushSize').removeAttr('disabled');\r\n            updateBrush($('#brushSize').val());\r\n        } else {\r\n            $('#brushSize').attr('disabled');\r\n            updateBrush(1);\r\n        }\r\n    });\r\n\r\n    $('#brushSize').on('input', e => {\r\n        updateBrush(e.target.value);\r\n    });\r\n\r\n    $('#savePixelsInp').on('change', e => {\r\n        e = e.target;\r\n        if (+e.value < 0) e.value = 0;\r\n\r\n        player.maxPlaced = +e.value;\r\n        setLS('maxPlaced', player.maxPlaced)\r\n    });\r\n\r\n    $('#disableChatColors').on('change', e => {\r\n        const checked = e.target.checked\r\n\r\n        setLS('disableColors', checked.toString());\r\n\r\n        chat.setColors(!checked)\r\n    });\r\n\r\n    $('#chatLimit').on('change', e => {\r\n        const value = parseInt(e.target.value, 10);\r\n        if (isNaN(value) || value < 1) return;\r\n\r\n        setLS('chatLimit', value.toString());\r\n\r\n        game.chatLimit = value;\r\n    });\r\n\r\n    $('#enableGridCB').on('change', e => {\r\n        const checked = e.target.checked;\r\n\r\n        setLS('enableGrid', checked.toString());\r\n\r\n        if (checked) tools.grid.show();\r\n        else tools.grid.hide();\r\n    });\r\n\r\n    $('#drawLineLenCB').on('change', e => {\r\n        const checked = e.target.checked;\r\n\r\n        setLS('drawLineLen', checked.toString());\r\n\r\n        tools.line.drawLength = checked;\r\n    });\r\n}\r\n\r\nexport async function captchaModal() {\r\n    let win = new Window({\r\n        title: t('Captcha'),\r\n        center: true,\r\n        closeable: false\r\n    });\r\n\r\n    if (win.created) {\r\n        const [help, cont, inp] = $(\r\n            `<div>${t('Case insensitive, 0/o i/l are same')}. <a href=\"#\">${t('Can\\'t recognize?')}</a></div>` +\r\n            '<div class=\"captchaContainer\"></div>' +\r\n            '<input class=\"fullWidthInput\" type=\"text\"></input>'\r\n        );\r\n\r\n        help.children[0].onclick = captchaModal;\r\n\r\n        const [line] = $(`<div style=\"display:flex;justify-content:center\">${t('Captcha').toUpperCase()}:&nbsp;&nbsp;</div>`);\r\n        line.appendChild(inp);\r\n\r\n        win.body.appendChild(help)\r\n        win.body.appendChild(cont);\r\n        win.body.appendChild(line);\r\n\r\n        inp.addEventListener('keydown', async e => {\r\n            if (e.key === 'Enter') {\r\n                if (inp.value.length == 0) return;\r\n                let val = inp.value;\r\n                inp.value = '';\r\n\r\n                const success = await solveCaptcha(val);\r\n\r\n                if (success) {\r\n                    win.close();\r\n                } else {\r\n                    captchaModal();\r\n                }\r\n            }\r\n        })\r\n    } else win = win.oldWindow;\r\n\r\n    let svg;\r\n    try {\r\n        svg = await fetchCaptcha();\r\n    } catch (e) {\r\n        console.error('error downloading captcha image: ' + e);\r\n\r\n        globals.socket.close();\r\n        return win.close();\r\n    }\r\n\r\n    // according to default dark theme\r\n    svg = svg.replace('stroke=\"black\"', 'stroke=\"white\"');\r\n\r\n    $('.captchaContainer', win.body).html(svg);\r\n\r\n    win.moveToCenter();\r\n    $('input', win.body).trigger('focus');\r\n}\r\n\r\nexport function toolsWindow() {\r\n    const toolWin = new Window({\r\n        title: capitalize(t('tools')),\r\n        center: true\r\n    });\r\n    if (!toolWin.created) return;\r\n\r\n    const tableArr = [\r\n        [`<a href=\"/convert\" target=\"_blank\">${t('convert image into palette')}</a>`],\r\n        [`<button id=\"screenshot\">${t('save canvas')}</button>`],\r\n        [`<button id=\"showPrevWipes\">${t('tools.showPrevWipesBtn')}</button>`]\r\n    ]\r\n\r\n    if (me.role >= ROLE.MOD) {\r\n        tableArr.unshift([`<button id=\"searchUsersB\">${t('search users')}</button>`])\r\n    }\r\n\r\n    const table = generateTable(tableArr);\r\n    $(toolWin.body).append(table);\r\n\r\n    $('#searchUsersB', table).on('click', () => {\r\n        const win = new Window({\r\n            title: capitalize(t('search users')),\r\n            center: true\r\n        });\r\n        if (!win.created) return;\r\n\r\n        const table = generateTable([\r\n            [`<input type=\"text\" placeholder=\"nickname\" id=\"userSearchText\" max=\"32\" style=\"width:250px\"> ${t('OR')} ` +\r\n                '<input type=\"text\" placeholder=\"id\" id=\"userSearchId\" max=\"32\" style=\"width:50px\">' +\r\n                `<input type=\"checkbox\" id=\"searchIsBanned\"><label for=\"searchIsBanned\">${t('banned?')}</label>`],\r\n            ['<div id=\"searchUsersBody\">']\r\n        ]);\r\n\r\n        $(win.body).append(table);\r\n\r\n        const input = $('#userSearchText');\r\n\r\n        $('#userSearchId').on('input', async e => {\r\n            let num = e.target.value.trim();\r\n            num = +num;\r\n\r\n            if (isNaN(num) || num < 1 || num > Number.MAX_SAFE_INTEGER) {\r\n                return\r\n            }\r\n\r\n            const isBanned = $('#searchIsBanned')[0].checked;\r\n\r\n            const searchResp = await search(null, num, isBanned);\r\n            afterSearch(searchResp);\r\n        })\r\n\r\n        $('#userSearchText').on('input', async _ => {\r\n            let text = input.val().trim();\r\n            text = text.slice(0, 32);\r\n\r\n            const isBanned = $('#searchIsBanned')[0].checked;\r\n\r\n            const searchResp = await search(text, null, isBanned);\r\n            afterSearch(searchResp);\r\n        });\r\n\r\n        function afterSearch(resp) {\r\n            if (!resp || !resp.length) {\r\n                // clean up if nothing found\r\n                $('#searchUsersBody').html('');\r\n                return\r\n            };\r\n\r\n            let table = document.createElement('table');\r\n            table.className = 'innerTable';\r\n            table.innerHTML += '<tr><th>NICK</th><th>ID</th><th>ROLE</th><th>&nbsp;</th></tr>'\r\n\r\n            for (let user of resp) {\r\n                const safeNick = htmlspecialchars(user.name);\r\n\r\n                // little workaround with click listener,\r\n                // this might be shorter\r\n                const uinfoButton = document.createElement('button');\r\n                uinfoButton.className = 'userInfoBtn';\r\n                uinfoButton.innerHTML = `<img src=\"${userImg}\">`;\r\n                uinfoButton.addEventListener('click', async () => {\r\n                    const req = await apiRequest(`/userInfo?id=${user.id}`);\r\n                    const info = await req.json();\r\n                    await User.CreateWindow(info);\r\n                })\r\n\r\n                const row = $(\r\n                    `<tr>\r\n                        <td>${safeNick}</td><td>${user.id}</td>` +\r\n                    `<td>${user.role}</td>` +\r\n                    `<td></td>\r\n                    </tr>`\r\n                );\r\n\r\n                row[0].lastElementChild.appendChild(uinfoButton);\r\n                table.appendChild(row[0]);\r\n            }\r\n\r\n            $('#searchUsersBody').html(table);\r\n        }\r\n\r\n        async function search(term, id, isBanned) {\r\n            if (!isBanned) {\r\n                if (!term && !id) return;\r\n            }\r\n            if (term && id) return;\r\n\r\n            if (term) {\r\n                term = encodeURIComponent(term);\r\n            }\r\n            const req = await apiRequest(`/admin/users/search?isBanned=${isBanned ? 1 : 0}&${id ? `id=${id}` : `t=${term}`}`)\r\n\r\n            const json = await req.json();\r\n            return json\r\n        }\r\n    });\r\n\r\n    $('#screenshot').on('click', makeScreenshot);\r\n\r\n    $('#showPrevWipes').on('click', () => {\r\n        const wipesWin = new Window({\r\n            title: capitalize(t('prevWipesWinTitle'))\r\n        });\r\n        if (!wipesWin.created) return;\r\n\r\n        wipesWin.body.style.maxHeight = '200px';\r\n\r\n        if (!globals.mobile) {\r\n            wipesWin.moveTo(\r\n                toolWin.right + 5,\r\n                toolWin.top\r\n            );\r\n        } else {\r\n            wipesWin.moveToCenter();\r\n        }\r\n\r\n        const createWipeRow = function (wipeName) {\r\n            return [`<button data-name=\"${wipeName}\" class=\"showWipeBtn\">${wipeName}</button>`];\r\n        }\r\n        const table = generateTable(Object.keys(wipes).map(createWipeRow));\r\n        $(wipesWin.body).append(table);\r\n\r\n        $('.showWipeBtn', wipesWin.body).on('click', el => {\r\n            const name = el.target.dataset.name;\r\n            showHistoryCanvas(name);\r\n        });\r\n\r\n        const oldCloseFunc = wipesWin.close;\r\n        wipesWin.close = (...args) => {\r\n            unloadHistoryCanvas();\r\n\r\n            oldCloseFunc.call(wipesWin, ...args);\r\n        }\r\n    })\r\n}\r\n\r\nexport function authWindow() {\r\n    const win = new Window({\r\n        title: capitalize(t('LOG IN')),\r\n        center: true\r\n    });\r\n    if (!win.created) return;\r\n\r\n    const tableArr = [\r\n        [`<a href=\"/api/auth/vk\"><img src=\"${vkLogo}\" class=\"authLogo\">VK</a>`],\r\n        [`<a href=\"/api/auth/discord\"><img src=\"${dsLogo}\" class=\"authLogo\">DISCORD</a>`],\r\n        [`<a href=\"/api/auth/google\"><img src=\"${ggLogo}\" class=\"authLogo\">GOOGLE</a>`]\r\n    ]\r\n\r\n    const table = generateTable(tableArr);\r\n\r\n    $('td', table).css('text-align', 'left');\r\n    $('a', table).css('margin-left', '15px');\r\n\r\n    $(win.body).append(table);\r\n}\r\n\r\n\r\nexport function help() {\r\n    const helpWin = new Window({\r\n        title: t('help'),\r\n        center: true\r\n    });\r\n    if (!helpWin.created) return;\r\n\r\n    helpWin.body.style.maxWidth = '800px';\r\n    helpWin.body.style.width = '90vw';\r\n    helpWin.body.style.height = '90vh';\r\n\r\n    const desktopIconMacro = `<img class=\"smallSvgIcon\" src=\"${desktopIcon}\">`;\r\n    const mobileIconMacro = `<img class=\"smallSvgIcon\" src=\"${mobileIcon}\">`;\r\n\r\n    // TODO move this to translations\r\n    const intro = createCollapsibleBlock(t('intro.introHeader'),\r\n        `<div style=\"width:100%;text-align:center;\"><img src=\"./img/goroxels.png\" style=\"vertical-align: middle;\">${t('intro.desc')}</div><br><br>\r\n    ${t('intro.desc2')}`, false);\r\n\r\n    const howto = createCollapsibleBlock(t('how to play?'),\r\n        `<div style=\"display:inline-flex\">\r\n            <div>${t('intro.howToPlayDecs')}</div>\r\n            <div style=\"padding-left: 10px;\">\r\n                <div class=\"desktop\">\r\n                <video autoplay loop muted style=\"height:196px\"><source src=\"./video/clickerMouse.webm\" type=\"video/webm\"></video>\r\n                </div>\r\n                <div class=\"mobile\">\r\n                <video autoplay loop muted style=\"height:196px\"><source src=\"./video/phoneDrawing.mp4\" type=\"video/mp4\"></video>\r\n                </div>\r\n            </div>\r\n        </div>`);\r\n\r\n    const tools = createCollapsibleBlock(t('tools'),\r\n        `${t('intro.toolsDecs')}<br><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.toolsClicker')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/clicker.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${t('intro.toolsAS')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/as.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${t('intro.toolC')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/toolC.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.brush')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/brush2.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.line')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/line.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.flood')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/flood.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.grid')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <img src=\"./img/unavailable.png\" style=\"height:196px\">\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.ctrlZ')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/ctrlZ.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    ${desktopIconMacro}${mobileIconMacro}${t('intro.resetColors')}<br>`);\r\n\r\n    const tools2 = createCollapsibleBlock(t('intro.tools2header'),\r\n        `<div style=\"width:100%;text-align:center;\"><b>${t('intro.tools2desc')}</b></div><br><br>\r\n    ${desktopIconMacro}${t('intro.toolsHiders')}<br><br>\r\n    ${desktopIconMacro}${mobileIconMacro}${t('intro.multicol')}<br>\r\n    ${t('intro.multicol2')}<br>\r\n    ${t('intro.multicol3')}<br><br>\r\n    ${desktopIconMacro}${t('intro.sendCoords')}<br><br>\r\n    ${desktopIconMacro}${t('intro.templateTools')}<br>`);\r\n\r\n    const template = createCollapsibleBlock(t('template'),\r\n        `<div style=\"width:100%;text-align:center;\"><b>${t('intro.templateIntro')}</b></div><br><br>\r\n    ${t('intro.templateDesc')}<br><br>\r\n    ${t('intro.templateDescConvert')}<br><br>\r\n    <div class=\"helpWithVideoCont mobile\">\r\n        <video autoplay loop muted style=\"height:196px\"><source src=\"./video/patternDemo.webm\" type=\"video/webm\"></video>\r\n    </div>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${t('intro.templateDescReminder')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/patternDemo.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>`);\r\n\r\n    const author = createCollapsibleBlock(t('intro.authorHeader'),\r\n        `${t('intro.authorText')}<br>\r\n        ${t('intro.authorContacts')}<br>\r\n        ${t('intro.telegram_channel')}: <a href=\"https://t.me/goroxels\">t.me/goroxels</a><br>\r\n        ${t('intro.my_boosty')} <a href=\"https://boosty.to/gorox\">https://boosty.to/gorox</a>\r\n        <div style=\"text-align:center\"><img src=\"./img/3rdcf.png\" title=\" \"></div>`);\r\n\r\n\r\n    $(helpWin.body).append(intro, howto, tools, tools2, template, author);\r\n}\r\n\r\nexport function onlineViewWindow(json) {\r\n    let win = new Window({\r\n        title: capitalize(t('online')),\r\n        center: true,\r\n        closeable: true\r\n    });\r\n\r\n    if (!win.created) {\r\n        win = win.oldWindow;\r\n    }\r\n\r\n    win.body.style.width = '325px';\r\n    win.moveToCenter();\r\n\r\n    const tableArr = [];\r\n    Object.keys(json).forEach(key => {\r\n        if (key === 'TOTAL') {\r\n            win.updateTitle(t('online') + ` (${json[key]})`, true);\r\n            return;\r\n        }\r\n\r\n        const firstEl = `<a href=\"/${key}\" target=\"_shagorox\"><h3>${key}<h3></a>`;\r\n        const secondEl = `<h2>${json[key]}</h2>`;\r\n\r\n        tableArr.push([firstEl, secondEl]);\r\n    })\r\n\r\n    const table = generateTable(tableArr);\r\n\r\n    $('*', win.body).remove();\r\n    $(win.body).append(table);\r\n}\r\n\r\nexport function templatesWindow(templatesJson) {\r\n    let win = new Window({\r\n        title: capitalize(t('templates_title')),\r\n        center: true,\r\n        closeable: true\r\n    });\r\n\r\n    if (!win.created) {\r\n        return;\r\n    }\r\n\r\n    win.body.classList.add('templatesBody');\r\n    win.body.style.maxWidth = 'min(495px, 90vw)'; // 5 items\r\n    if (globals.mobile) {\r\n        win.body.style.justifyContent = 'space-evenly';\r\n    }\r\n\r\n    const templatesJsonSorted = templatesJson\r\n        .slice()\r\n        .sort((a, b) => {\r\n            const aIsMine = me.id === a.userId;\r\n            const bIsMine = me.id === b.userId;\r\n\r\n            if (aIsMine !== bIsMine) {\r\n                return aIsMine ? 1 : -1;\r\n            }\r\n\r\n            return new Date(a.createdAt) - new Date(b.createdAt);\r\n        });\r\n\r\n    const meAdmin = me.role === ROLE.ADMIN;\r\n    for (const tempJson of templatesJsonSorted) {\r\n        const meOwner = me.id === tempJson.userId;\r\n        const canDelete = meOwner || meAdmin;\r\n\r\n        const templateThumbLink = `api/template/img?t=thumb&f=${tempJson.thumb}`;\r\n\r\n        const templateEl = $(\r\n            `<div class=\"templateItem ${meOwner ? 'myTemplateItem' : ''}\">\r\n                <button class=\"templateBtn ${canDelete ? 'deleteBtn' : ''}\"></button>\r\n                <button class=\"templateBtn infoBtn\">i</button>\r\n                <img src=\"${templateThumbLink}\" alt=\"thumbnail\">\r\n                <div class=\"templateName\">${tempJson.name}</div>\r\n            </div>`\r\n        );\r\n\r\n        $(win.body).prepend(templateEl);\r\n\r\n        templateEl.find('.deleteBtn').on('click', async e => {\r\n            e.stopPropagation();\r\n\r\n            new ConfirmModal(t('confirm_template_deletion'), async (confirmed) => {\r\n                if (!confirmed) return;\r\n                const resp = await apiRequest(`/template/del?name=${encodeURIComponent(tempJson.name)}`, { method: 'POST' });\r\n                const data = await resp.json();\r\n                if (data.success) {\r\n                    templateEl.remove();\r\n                }\r\n            })\r\n        });\r\n\r\n        templateEl.find('.infoBtn').on('click', async e => {\r\n            e.stopPropagation();\r\n\r\n            let ownerName = '???';\r\n            try {\r\n                const resp = await apiRequest(`/userInfo?id=${tempJson.userId}`);\r\n                const data = await resp.json();\r\n                if (data && data.name) {\r\n                    ownerName = htmlspecialchars(data.name);\r\n                }\r\n            } catch (e) {\r\n                console.error('  userInfo', e);\r\n            }\r\n\r\n            const isMine = me.id === tempJson.userId;\r\n            const createdDate = new Date(tempJson.createdAt).toLocaleString();\r\n\r\n            const infoWin = new Window({\r\n                title: capitalize(t('template_info')),\r\n                center: true,\r\n                closeable: true\r\n            });\r\n\r\n            if (!infoWin.created) return;\r\n\r\n            infoWin.body.style.width = '280px';\r\n            infoWin.body.innerHTML = `\r\n                <ul class=\"templateInfoList\">\r\n                    <li><b>${t('name')}:</b> ${tempJson.name}</li>\r\n                    <li><b>${t('createdAt')}:</b> ${createdDate}</li>\r\n                    <li><b>${t('owner')}:</b> ${ownerName}</li>\r\n                    <li><b>${t('isMine')}:</b> ${isMine ? t('yes') : t('no')}</li>\r\n                    <li><b>${t('public')}:</b> ${tempJson.public ? t('yes') : t('no')}</li>\r\n                </ul>\r\n            `;\r\n        });\r\n\r\n\r\n        templateEl.on('click', () => {\r\n            let imgLink = `GRX/f=${tempJson.file}`;\r\n            if (tempJson.origWidth) {\r\n                imgLink += `&w=${tempJson.origWidth}`;\r\n            }\r\n\r\n            urlInput.val(imgLink);\r\n            updateTemplate();\r\n        })\r\n    }\r\n}\r\n\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \".\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"game\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkgoroxels_client\"] = self[\"webpackChunkgoroxels_client\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"penis\"], () => (__webpack_require__(\"./src/js/main.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}