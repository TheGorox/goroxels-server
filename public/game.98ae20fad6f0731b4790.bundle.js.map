{"version":3,"file":"game.98ae20fad6f0731b4790.bundle.js","mappings":";;;;;;;;;;;;;;AAAA,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,yBAAyB;;;;;;;;;;;;;;;ACA/D,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,8BAA8B;;;;;;;;;;;;;;;ACApE,iEAAe,qBAAuB,2BAA2B;;;;;;;;;;;;;;;ACAjE,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,iCAAiC;;;;;;;;;;;;;;;ACAvE,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,8BAA8B;;;;;;;;;;;;;;;ACApE,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,yBAAyB;;;;;;;;;;;;;;;ACA/D,iEAAe,qBAAuB,kBAAkB;;;;;;;;;;;;;;;ACAxD,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,gBAAgB;;;;;;;;;;;;;;;ACAtD,iEAAe,qBAAuB,iBAAiB;;;;;;;;;;;;;;;ACAvD,iEAAe,qBAAuB,oBAAoB;;;;;;;;;;;;;;;ACA1D,iEAAe,qBAAuB,iCAAiC;;;;;;;;;;;;;;;ACAvE,iEAAe,qBAAuB,wBAAwB;;;;;;;;;;;;;;;ACA9D,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,uBAAuB;;;;;;;;;;;;;;;ACA7D,iEAAe,qBAAuB,wBAAwB;;;;;;;;;;;;;;;ACA9D,iEAAe,qBAAuB,6BAA6B;;;;;;;;;;;;;;;ACAnE,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,4BAA4B;;;;;;;;;;;;;;;ACAlE,iEAAe,qBAAuB,sBAAsB;;;;;;;;;;;;;;;ACA5D,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;ACAzD,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;;;;ACA3D,iEAAe,qBAAuB,qBAAqB;;;;;;;;;;;;ACA3D;;;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1Be;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrCgC;AAKf;AAC6C;AAC9D;AACe;AACf;AACA;AACA;AACA;AACA,qBAAqB,8CAAS;AAC9B,sBAAsB,8CAAS;AAC/B;AACA;AACA,iDAAiD,8CAAS;AAC1D;AACA;AACA;AACA,gDAAgD,8CAAS,EAAE,8CAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gDAAO,CAAC,iEAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8CAAS;AAC5D;AACA;AACA,kDAAkD,8CAAS,EAAE,8CAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,2BAA2B,+CAAU;AACrC;AACA;AACA;AACA;AACA,iCAAiC,8CAAS;AAC1C;AACA;AACA;AACA,0BAA0B,8CAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAS;AACnC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC9GgC;AACJ;AAKV;AAGU;AACW;AACf;AACkC;AAC1D;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ,gDAAO;AACf;AACA;AACA,YAAY,gDAAO;AACnB,SAAS;AACT;AACA,QAAQ,gDAAO;AACf;AACA;AACA,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA,YAAY,oDAAU,qBAAqB,6CAAQ,CAAC,KAAK,EAAE,KAAK,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAK;AACrC;AACA;AACA,gCAAgC;AAChC,oBAAoB,6DAAoB;AACxC;AACA,gBAAgB,gDAAO;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAQ;AACvB;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA,iDAAiD,+CAAU;AAC3D;AACA;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC,wBAAwB,gDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAS;AAC5C,iCAAiC,8CAAS;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvKiC;AACA;AACjC;AACA;AACA;AACA;AACA;AACe,2BAA2B,+CAAY;AACtD;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,iDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzHkC;AAClC;AACe,yBAAyB,+CAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,CAAC;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA;AACA;AACA,iCAAiC,CAAC;AAClC;AACA;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA,2BAA2B,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1Ee;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpD2D;AAC7B;AACmB;AACjB;AACA;AACkB;AAI5B;AACY;AACE;AACN;AAC4B;AAC1D;AACA,iBAAiB,2EAA8B;AAC/C;AACA;AACe;AACf;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA,2CAA2C,gDAAO,CAAC,iEAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAM;AAC7B;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,+CAAU,CAAC,+CAAM;AAC3C;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAgB;AAC5C;AACA;AACA;AACA;AACA,mBAAmB,+CAAM,KAAK,gDAAO,kCAAkC,+CAAM;AAC7E,mBAAmB,+CAAM,KAAK,gDAAO,mCAAmC,+CAAM;AAC9E;AACA,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAS;AACrC,4BAA4B,8CAAS;AACrC;AACA;AACA,iBAAiB,gDAAO;AACxB,gBAAgB,gDAAO;AACvB;AACA;AACA,yDAAyD,GAAG,GAAG,GAAG;AAClE;AACA;AACA,yDAAyD,GAAG,GAAG,GAAG;AAClE;AACA;AACA;AACA,wBAAwB,8DAAoB;AAC5C;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,sEAAsE,8CAAS,EAAE,8CAAS;AAC1F;AACA;AACA;AACA;AACA,4FAA4F,8CAAS,EAAE,8CAAS;AAChH;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4FAA4F,8CAAS,EAAE,8CAAS;AAChH;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,iDAAQ;AAChB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpOkC;AACX;AACvB;AAMoB;AAIH;AACc;AACL;AACA;AACe;AACX;AACA;AACW;AACD;AACxC;AACe,qBAAqB,+CAAY;AAChD;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,KAAK,KAAK,GAAG,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C,4BAA4B,6CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC,YAAY,gDAAO;AACnB;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,6CAA6C,gDAAO;AACpD;AACA;AACA;AACA,oBAAoB,gDAAO;AAC3B;AACA,iBAAiB;AACjB,oBAAoB,gDAAO,iBAAiB,6CAAI;AAChD;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA,oBAAoB,gDAAO,YAAY,gDAAO;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA,4BAA4B,+CAAM;AAClC,4BAA4B,sDAAY;AACxC;AACA,oBAAoB,MAAM,cAAc,sDAAS;AACjD;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B,gBAAgB,6CAAI;AACpB;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B;AACA;AACA;AACA;AACA,iBAAiB,qDAAc;AAC/B,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB,gBAAgB,sDAAY;AAC5B;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA,kCAAkC,mDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,6BAA6B,gDAAO;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB,iDAAiD,8CAAO;AACxD;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAM;AACxB,YAAY,uDAAY,CAAC,+CAAM;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B,2CAA2C;AAC3C,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxXA;AACA;AACA;AACkD;AACX;AACK;AAC5C;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAQ,CAAC,GAAG,OAAO,GAAG,OAAO;AAC1D,YAAY,0DAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,mDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAY,SAAS,iDAAS,EAAE,iDAAS;AACxD;AACA;AACA;AACA;AACA,6BAA6B,gDAAQ,CAAC,GAAG,OAAO,GAAG,OAAO;AAC1D,YAAY,0DAAqB;AACjC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAY;AACnD;AACA;AACA,8BAA8B,mDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;ACjHiC;AACE;AACnC;AACe,mBAAmB,+CAAY;AAC9C,6DAA6D,4CAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdkC;AACF;AACJ;AACE;AACA;AAGD;AAKP;AAC8B;AAC9B;AACtB;AACA,eAAe,gDAAO;AACtB;AACA;AACA,uBAAuB,sEAAkB;AACzC;AACA,iBAAiB,+CAAM,eAAe,+CAAM;AAC5C;AACA;AACA;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA,2BAA2B,+CAAM,GAAG,IAAI,+CAAM,GAAG;AACjD;AACA,QAAQ,+CAAM,gBAAgB,+CAAM;AACpC,QAAQ,gDAAO;AACf;AACA;AACA,iBAAiB,2EAA8B;AAC/C;AACe,0BAA0B,+CAAY;AACrD;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B,oBAAoB,8CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAAE;AACV;AACA;AACA;AACA;AACA,gDAAgD,2CAAE;AAClD;AACA;AACA;AACA,oBAAoB,CAAC,UAAU,KAAK;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,oBAAoB,+CAAM;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM;AACtB,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oBAAoB,+CAAM;AAC1B,oBAAoB,+CAAM;AAC1B;AACA;AACA,aAAa;AACb;AACA,uCAAuC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,8DAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,8DAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,+CAAM;AACtC,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM,eAAe,+CAAM,eAAe,+CAAM;AAChE;AACA;AACA,oBAAoB,+CAAM,gBAAgB,+CAAM,KAAK,+CAAM,gBAAgB,+CAAM;AACjF,oBAAoB,gDAAO;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAK;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9RA;AACA;AACA;AAC4B;AACY;AACD;AACvC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,4BAA4B,uDAAQ,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA,gBAAgB,6CAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAM;AAC1B;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,6CAAM;AACtB;AACA;AACA;AACA,oBAAoB,6CAAM;AAC1B;AACA,oBAAoB,6CAAM;AAC1B,iBAAiB;AACjB,aAAa;AACb;AACA,YAAY,CAAC;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,6CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/RsB;AAIJ;AACY;AAKD;AAGD;AACK;AACD;AAUb;AAUD;AACwB;AAChB;AACI;AACgB;AAC0B;AAC1B;AACF;AAChB;AACe;AAC3C;AACO,2CAA2C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACO;AACP,UAAU,2CAAE;AACZ;AACA,IAAI,+CAAM;AACV,QAAQ,2CAAE;AACV,QAAQ,gDAAS;AACjB,QAAQ,gDAAS;AACjB;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC,mBAAmB,2CAAE;AAC9B,QAAQ,CAAC;AACT,MAAM;AACN,QAAQ,gDAAS;AACjB,QAAQ,gDAAS,KAAK,sDAAE;AACxB;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA;AACO;AACP,sBAAsB,6CAAQ;AAC9B;AACA,QAAQ,8CAAM,CAAC,2CAAE;AACjB,qBAAqB,8CAAM,CAAC,2CAAE,WAAW,6CAAQ;AACjD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAY;AAC/B,IAAI,+CAAQ;AACZ;AACA,iBAAiB,iEAAY;AAC7B,IAAI,6CAAM;AACV;AACA,iBAAiB,iEAAY;AAC7B,IAAI,6CAAM;AACV;AACA,oBAAoB,iEAAY;AAChC,IAAI,gDAAS;AACb;AACA;AACA;AACA,IAAI,0DAAK,eAAe,iDAAQ;AAChC,IAAI,0DAAK,eAAe,iDAAQ;AAChC,IAAI,0DAAK,iBAAiB,iDAAQ;AAClC,IAAI,0DAAK,kBAAkB,iDAAQ;AACnC;AACA;AACO;AACP,IAAI,iDAAQ;AACZ,IAAI,iDAAQ;AACZ;AACA;AACA;AACA;AACA,IAAI,+CAAQ;AACZ,IAAI,6CAAM;AACV,IAAI,6CAAM;AACV,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAM,KAAK,iDAAQ;AAC/B,YAAY,6CAAM,KAAK,iDAAQ;AAC/B;AACA,YAAY,iDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,YAAY,CAAC;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,IAAI,CAAC,iCAAiC,qDAAe;AACrD,IAAI,CAAC,2BAA2B,8CAAQ;AACxC,IAAI,CAAC,4BAA4B,gDAAU;AAC3C,IAAI,CAAC,gCAAgC,kDAAY;AACjD,IAAI,CAAC,wBAAwB,iDAAW;AACxC,IAAI,CAAC,yBAAyB,gDAAU;AACxC;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA,YAAY,CAAC,+BAA+B,gDAAO;AACnD;AACA,4BAA4B,gDAAS;AACrC;AACA,uBAAuB,gDAAS;AAChC;AACA,YAAY,gDAAS;AACrB;AACA,YAAY,8CAAI;AAChB,UAAU;AACV;AACA,YAAY,CAAC;AACb;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA,QAAQ,8CAAI;AACZ,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA,QAAQ,8CAAI;AACZ,QAAQ,8CAAI,eAAe,0DAAK;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO,+CAAU;AACjB;AACA,KAAK;AACL;AACA;AACA,mBAAmB,+CAAU;AAC7B;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,+CAAM,oBAAoB,gDAAO;AAC7C,SAAS;AACT;AACA,IAAI,gDAAO;AACX;AACA;AACO;AACP,mBAAmB,gDAAO;AAC1B,sBAAsB,gDAAO;AAC7B;AACA,2CAA2C,2CAAE,SAAS,4CAAI,SAAS,gDAAO;AAC1E;AACA,YAAY,+CAAM,oBAAoB,gDAAO;AAC7C;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C,gBAAgB,+CAAM,UAAU,+CAAM,eAAe,+CAAM;AAC3D;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,SAAS;AACT,MAAM;AACN,2BAA2B,2CAAE,QAAQ,4CAAI;AACzC,YAAY,MAAM,OAAO,sDAAE,8BAA8B,sDAAE;AAC3D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACO;AACP,QAAQ,2CAAM;AACd,QAAQ,2CAAM;AACd,QAAQ,2CAAM;AACd,MAAM;AACN,QAAQ,2CAAM,cAAc,2CAAM;AAClC,yBAAyB,2CAAM;AAC/B;AACA;AACA;AACO;AACP,QAAQ,8CAAO;AACf,QAAQ,8CAAO;AACf,QAAQ,8CAAO;AACf,MAAM;AACN,QAAQ,8CAAO,oBAAoB,8CAAO;AAC1C,yBAAyB,8CAAO;AAChC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ;AACR,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP,IAAI,yCAAI;AACR,IAAI,gDAAO;AACX;AACA,KAAK;AACL,IAAI,gDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,sBAAsB,CAAC;AACvB;AACA;AACA;AACA,cAAc;AACd;AACA,+BAA+B,CAAC;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,CAAC;AACT,wBAAwB,CAAC;AACzB;AACA;AACA,YAAY,CAAC;AACb,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP;AACA,eAAe,qEAAuB;AACtC;AACA,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,EAAE,gBAAgB,IAAI;AACtD;AACA;AACA;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA;AACO;AACP,YAAY,CAAC,uBAAuB,CAAC;AACrC;AACA;AACO;AACP,sBAAsB,CAAC;AACvB;AACA;AACA;AACA,wCAAwC,GAAG;AAC3C;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,KAAK;AACL;AACA;AACO;AACP,IAAI,+CAAM;AACV,IAAI,gDAAO;AACX;AACA,IAAI,gDAAO;AACX;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,YAAY,CAAC,2BAA2B,CAAC;AACzC;AACA;AACO;AACP;AACA,IAAI,CAAC;AACL;AACA,QAAQ,CAAC;AACT;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA,uBAAuB,+CAAM;AAC7B,QAAQ,0DAAK,gBAAgB,+CAAM;AACnC,qBAAqB,+CAAM;AAC3B;AACA,CAAC;AACD;AACO;AACP,uBAAuB,0DAAK;AAC5B,uBAAuB,qEAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAK;AACtB,iBAAiB,iEAAY;AAC7B,mBAAmB,iEAAY;AAC/B,iBAAiB,0DAAK;AACtB,QAAQ,0DAAK;AACb;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL,QAAQ,CAAC;AACT,QAAQ,8CAAI;AACZ,KAAK;AACL,IAAI,CAAC;AACL,QAAQ,CAAC;AACT,QAAQ,8CAAI;AACZ,KAAK;AACL;AACA;AACA;AACA,IAAI,CAAC;AACL,QAAQ,8CAAI;AACZ,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAO;AACX,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,KAAK;AACL;AACA;AACO;AACP,mBAAmB,gDAAO;AAC1B;AACA;AACA,0BAA0B,+CAAU,EAAE,EAAE,6DAAe,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,4CAAO;AACX,oBAAoB,wDAAQ,KAAK,wDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAU;AAClC;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAW;AACvB;AACA;AACA,4BAA4B,QAAQ;AACpC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC,QAAQ,EAAE;AACnB,KAAK;AACL;AACA;AACO;AACP,IAAI,CAAC;AACL;AACA;AACO;AACP;AACA,oBAAoB,0DAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA;AACA,QAAQ,0DAAgB;AACxB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,CAAC;AAC3E;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACO;AACP,0BAA0B,CAAC;AAC3B,IAAI,CAAC;AACL;AACA;AACA;AACA,oBAAoB,CAAC;AACrB,2BAA2B,CAAC;AAC5B;AACA,qBAAqB,0DAAK;AAC1B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb,YAAY,0DAAK;AACjB;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAK;AAC9B;AACA,QAAQ,0DAAK;AACb,QAAQ,8CAAI;AACZ;AACA;AACA;AACA;AACA,uBAAuB,uDAAY;AACnC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3tB6B;AACJ;AAC0B;AACnD;AAC4B;AACY;AACZ;AACA;AACH;AACI;AAC7B;AAC6B;AAC7B;AACmC;AACL;AACL;AACG;AACA;AACC;AACF;AACC;AACG;AACH;AACM;AACT;AACzB;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;AC1BgB;AAId;AACiB;AACyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAY;AAC5B,gBAAgB,iEAAY;AAC5B;AACA,mBAAmB,iEAAY;AAC/B;AACA,mBAAmB,+CAAU;AAC7B,mBAAmB,gDAAW;AAC9B,kBAAkB,+CAAU;AAC5B,kBAAkB,gDAAW;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,+CAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAK;AAC3B,sBAAsB,0DAAK;AAC3B,sBAAsB,0DAAK;AAC3B;AACA,kBAAkB,cAAc;AAChC,CAAC;AACD;AACA,iEAAgB,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;AC5GM;AACL;AACP;AACc;AACD;AACqB;AAClB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAC;AACxB;AACA;AACA;AACA,yCAAyC,iEAAY;AACrD;AACA,gCAAgC,0DAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA,0BAA0B,+CAAU;AACpC;AACA,qCAAqC,CAAC;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,4DAAS;AACrC;AACA;AACA,8CAA8C,qCAAqC,iBAAiB,MAAM;AAC1G;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,QAAQ,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA,wBAAwB,CAAC;AACzB;AACA;AACA,yBAAyB,CAAC;AAC1B;AACA,YAAY,CAAC;AACb,YAAY,CAAC;AACb,SAAS;AACT,YAAY,CAAC;AACb,wBAAwB,CAAC,cAAc,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAgB;AACnC,mBAAmB,6DAAgB;AACnC;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB,wCAAwC,sCAAsC;AAC9E,kDAAkD,SAAS,IAAI,KAAK;AACpE,uCAAuC,KAAK;AAC5C;AACA;AACA,QAAQ,CAAC;AACT;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC,oCAAoC,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ,gDAAO;AACf;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,oBAAoB,IAAI,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAS,WAAW,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA,+CAA+C,qDAAE;AACjD;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gDAAS;AACjB,0BAA0B,gDAAS;AACnC;AACA,gBAAgB,gDAAS;AACzB,cAAc;AACd,gBAAgB,gDAAS;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gDAAO,kBAAkB;;;;;;;;;;;;;;;;;ACvXxC;AACA;AACO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;AC1EO,iBAAiB,CAAC;AACzB,aAAa,CAAC;AACd,aAAa,CAAC;AACd,gBAAgB,CAAC;AACjB;AACA,SAAS,CAAC;AACV,WAAW,CAAC;AACZ,gBAAgB,CAAC;AACjB,eAAe,CAAC;AAChB,cAAc,CAAC;;;;;;;;;;;;;;;;;ACTiB;AAChC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,gDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtFiC;AACQ;AACzC;AAGqB;AACrB;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAY;AAC5B,sBAAsB,qDAAY;AAClC;AACA;AACA,YAAY,2EAA8B;AAC1C,aAAa;AACb,gBAAgB;AAChB,oBAAoB,CAAC;AACrB,kBAAkB,CAAC;AACnB,iBAAiB,CAAC;AAClB,gBAAgB,CAAC;AACjB,gBAAgB,CAAC;AACjB,iBAAiB,CAAC;AAClB,wBAAwB,CAAC;AACzB,mBAAmB,CAAC;AACpB;AACA;;;;;;;;;;;;;;;;;;AC9BO;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CyB;AACzB;AAC8B;AACE;AACU;AACR;AACM;AACV;AACU;AACiD;AACzF;AACmC;AAShB;AAC4C;AACjC;AACG;AACmB;AACX;AACzC;AACA;AACA,IAAI,6CAAc;AAClB,UAAU,6CAAe;AACzB;AACA;AACA;AACA,MAAM,EAAE,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAO;AACpB,YAAY,gEAAmB;AAC/B;AACA;AACA,QAAQ,yDAAc;AACtB,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA,yBAAyB,gDAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAM;AACV,IAAI,wDAAW;AACf;AACA,IAAI,4CAAc;AAClB;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,CAAC;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAM,qBAAqB,+CAAM;AAC9D,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAM;AAC7B,IAAI,gDAAO;AACX;AACA,6BAA6B,qDAAY;AACzC,IAAI,gDAAO;AACX;AACA,2CAA2C,iDAAQ;AACnD,IAAI,gDAAO;AACX;AACA,2BAA2B,iDAAU;AACrC,IAAI,gDAAO;AACX;AACA,IAAI,gDAAO,mBAAmB,oDAAW;AACzC;AACA,IAAI,gDAAO,UAAU,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,QAAQ,CAAC;AACT,KAAK;AACL;AACA,QAAQ,CAAC;AACT,KAAK;AACL;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA,IAAI,+CAAiB;AACrB,YAAY,+CAAiB;AAC7B,YAAY,2DAAK;AACjB;AACA,sBAAsB,2CAAK;AAC3B,sBAAsB,CAAC;AACvB,kCAAkC,YAAY,kBAAkB;AAChE,sBAAsB,sDAAS,YAAY;AAC3C,qBAAqB,sDAAS;AAC9B,sBAAsB,sDAAS,yEAAyE;AACxG,wBAAwB,sDAAS,gEAAgE;AACjG,4CAA4C,IAAI,sDAAS,wEAAwE;AACjI;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA,YAAY,2DAAK;AACjB,SAAS;AACT,KAAK;AACL;AACA,IAAI,mDAAQ;AACZ,IAAI,iDAAa;AACjB,IAAI,qDAAU;AACd,IAAI,gEAAqB;AACzB,CAAC;;;;;;;;;;;;;;;;;;ACpLsC;AACL;AAClC;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA,UAAU,4CAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB;AACA,KAAK;AACL;AACA;AACA,+CAA+C,4CAAI;AACnD,KAAK;AACL;AACA;AACA,+BAA+B,oDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/D8B;AACE;AACkC;AAClE;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,iEAAY;AAClC,0BAA0B,iEAAY;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,CAAC;AACT;AACA,YAAY,CAAC;AACb;AACA;AACA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA,QAAQ,CAAC;AACT;AACA,YAAY,CAAC;AACb;AACA;AACA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,+CAAM;AAChC,KAAK;AACL;AACA;AACA,kBAAkB,0DAAK;AACvB;;;;;;;;;;;;;;;;;;AClEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrC8B;AAGT;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAKoB;AACpB;AACA;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAM,KAAK,gDAAO,yBAAyB,+CAAM;AACpE,mBAAmB,+CAAM,KAAK,gDAAO,yBAAyB,+CAAM;AACpE;AACA,kCAAkC,+CAAM;AACxC,kCAAkC,+CAAM;AACxC;AACA;AACA;AACA,kDAAkD,+CAAM,cAAc,+CAAM;AAC5E,KAAK;AACL;AACA;AACA,0BAA0B,6CAAM;AAChC,0BAA0B,6CAAM;AAChC;AACA,qCAAqC,gDAAS;AAC9C;AACA,oBAAoB,+CAAQ;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,+CAAQ;AACvB,KAAK;AACL;AACA;AACA,gBAAgB,gDAAS;AACzB,KAAK;AACL;AACA,QAAQ,gDAAS;AACjB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEyB;AACM;AAC/B;AACoC;AAGZ;AAIK;AAC7B;AAC6B;AAGV;AAQF;AACY;AAGV;AAYD;AACiB;AACnC;AACsD;AACN;AACU;AAC1D;AACgD;AACM;AACF;AACpD;AACkC;AACZ;AACuB;AACqB;AACE;AACtC;AACK;AACnC;AACmD;AACD;AACZ;AACtC;AACA,eAAe,gDAAO;AACtB;AACA;AACA,WAAW,gDAAO;AAClB;AACA;AACA;AACA,WAAW,gDAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,gBAAgB,+CAAM,SAAS,+CAAM;AACrC;AACA,QAAQ,+CAAM,sBAAsB,+CAAM;AAC1C;AACA,iBAAiB,+CAAM,IAAI,+CAAM,MAAM,+CAAM,SAAS,+CAAM;AAC5D;AACA;AACA,oCAAoC,+CAAM,iBAAiB,+CAAM;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAU,kBAAkB,gDAAW;AACjE;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iCAAiC,gDAAO;AACxC;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,MAAM;AACN;AACA;AACA;AACA,IAAI,gDAAO;AACX;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,IAAI,gDAAO;AACX;AACA;AACA;AACA,IAAI,gDAAO;AACX;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,yCAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA,YAAY,qDAAU,CAAC,+CAAM,IAAI,+CAAM;AACvC;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA,gCAAgC,+CAAM;AACtC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA,iEAAiE,4CAAE,QAAQ,6CAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAM,IAAI,+CAAM;AACtC;AACA,mBAAmB,qDAAM;AACzB;AACA;AACA;AACA,YAAY,+CAAM;AAClB,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA,YAAY,qDAAU;AACtB,UAAU;AACV,YAAY,sDAAW;AACvB;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAU;AACtC;AACA,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,mEAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAa,IAAI;AACzB;AACA;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mEAAW,EAAE,6CAAI;AACtE;AACA,sEAAsE,6CAAI;AAC1E;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,6BAA6B,sEAAkB,CAAC,+CAAM,IAAI,+CAAM;AAChE,kCAAkC,+CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,+BAA+B,sEAAkB,CAAC,+CAAM,KAAK,+CAAM,gBAAgB,+CAAM,KAAK,+CAAM;AACpG,8BAA8B,gDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc,gBAAgB,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc,gBAAgB,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAAM;AAC3C,qCAAqC,+CAAM;AAC3C;AACA;AACA;AACA;AACA,8BAA8B,+CAAM,IAAI,+CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM,uBAAuB,+CAAM,+CAA+C,+CAAM;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gEAAQ;AAC/C;AACA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAkB;AACvC,6CAA6C,uDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAM,IAAI,+CAAM;AAC7B;AACA;AACA,yBAAyB,+CAAM;AAC/B,+BAA+B,+CAAM;AACrC,mCAAmC,+CAAM,IAAI,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAkB;AACvC,6CAA6C,uDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAM,IAAI,+CAAM;AACnD;AACA,qBAAqB,yCAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAM,IAAI,+CAAM;AACjC;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,qBAAqB,+CAAM;AAC3B;AACA,6BAA6B,+CAAM;AACnC,mCAAmC,+CAAM;AACzC,uCAAuC,+CAAM,IAAI,+CAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,uDAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO,WAAW,gDAAO;AACzC,0BAA0B;AAC1B;AACA;AACA,gBAAgB,+CAAM,gBAAgB,+CAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,8BAA8B,+CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA,mCAAmC,sEAAkB;AACrD,2CAA2C,+CAAM,OAAO,+CAAM;AAC9D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qEAAa;AAClE;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,+BAA+B,+CAAM,IAAI,+CAAM;AAC/C;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA,qCAAqC,kEAAY;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM,IAAI,+CAAM;AAC3C;AACA,0CAA0C,+CAAM,QAAQ,+CAAM;AAC9D;AACA;AACA,gBAAgB,+CAAM;AACtB,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAE;AAC3B;AACA;AACA;AACA;AACA;AACA,wCAAwC,+CAAU;AAClD;AACA,iDAAiD,sEAAkB;AACnE,uDAAuD,+CAAM,OAAO,+CAAM;AAC1E,qBAAqB;AACrB;AACA;AACA;AACA,oCAAoC,+CAAM;AAC1C;AACA,wCAAwC,sEAAkB;AAC1D,sCAAsC,sEAAkB;AACxD;AACA;AACA;AACA,4DAA4D,+CAAM;AAClE,0DAA0D,+CAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,gDAAgD;AAChD,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAM;AACzC,mCAAmC,+CAAM;AACzC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,yBAAyB,gDAAO;AAChC;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAM;AACrC;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM,IAAI,+CAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA,gBAAgB,qDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,2CAA2C,gEAAQ;AACnD;AACA,oBAAoB,6CAAI;AACxB;AACA,kBAAkB,CAAC;AACnB;AACA,IAAI,gDAAS;AACb,IAAI,gDAAS;AACb,CAAC;AACD;AACA,sBAAsB,6CAAI;AAC1B,mBAAmB,+CAAM,iBAAiB,+CAAM;AAChD;AACA,qBAAqB,6CAAI;AACzB;AACA,gBAAgB,+CAAM;AACtB,6BAA6B,+CAAU;AACvC;AACA,IAAI,+CAAM;AACV,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA,gBAAgB,+CAAM;AACtB,mBAAmB,+CAAU;AAC7B;AACA,IAAI,+CAAM;AACV,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA,IAAI,qDAAU;AACd,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA,IAAI,wDAAa;AACjB,CAAC;AACD;AACA,oBAAoB,6CAAI,uCAAuC;AAC/D;AACA,IAAI,2DAAgB;AACpB,CAAC;AACD;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA,oBAAoB,+CAAM,iBAAiB,+CAAM;AACjD,oBAAoB,+CAAM,UAAU,+CAAM,eAAe,+CAAM;AAC/D;AACA,qBAAqB,+CAAM;AAC3B,qBAAqB,+CAAM;AAC3B;AACA,kCAAkC,+CAAM;AACxC;AACA,gBAAgB,qDAAU;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,yCAAyC,kEAAU;AACnD;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAY;AAC9C;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,kEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,qBAAqB,sEAAkB;AACvC,iCAAiC,sEAAkB;AACnD;AACA,cAAc,gBAAgB;AAC9B,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAS;AACrB,iBAAiB,8CAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,oBAAoB,8CAAS;AAC7B;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,oBAAoB,8CAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA,mBAAmB,+CAAM;AACzB,mBAAmB,+CAAM;AACzB;AACA;AACA,2BAA2B,sEAAkB;AAC7C,sBAAsB,+CAAM;AAC5B;AACA,4BAA4B,iDAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAE;AACvC;AACA;AACA;AACA,uBAAuB,+CAAM;AAC7B,uBAAuB,+CAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAU;AACtD,4CAA4C,gDAAW;AACvD;AACA;AACA,8BAA8B,2DAAY,OAAO,4CAAO;AACxD,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAAI;AACxD;AACA;AACA,6BAA6B,kEAAY;AACzC,wBAAwB,6CAAI;AAC5B;AACA,QAAQ,kDAAQ;AAChB,QAAQ,kDAAQ;AAChB,MAAM;AACN,sBAAsB,kDAAQ;AAC9B,QAAQ,kDAAQ;AAChB;AACA,IAAI,yDAAc;AAClB,CAAC;AACD;AACA,wBAAwB,6CAAI;AAC5B;AACA,QAAQ,kDAAQ;AAChB,QAAQ,kDAAQ;AAChB,MAAM;AACN,sBAAsB,kDAAQ;AAC9B,QAAQ,kDAAQ;AAChB;AACA,IAAI,yDAAc;AAClB,CAAC;AACD;AACA,qBAAqB,6CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM,IAAI,+CAAM;AAC3C;AACA,+BAA+B,+CAAM,QAAQ,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA;AACA;AACA;AACA,+BAA+B,qDAAM;AACrC;AACA;AACA,yBAAyB,yCAAE;AAC3B;AACA;AACA;AACA,yCAAyC,sEAAkB;AAC3D;AACA,wCAAwC,+CAAU;AAClD,6CAA6C,+CAAM,OAAO,+CAAM;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM,IAAI,+CAAM;AACzD;AACA,qBAAqB,qDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,qDAAU;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,sDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAI,iCAAiC;AAC1D;AACA,QAAQ,+CAAM;AACd,QAAQ,+CAAM,wBAAwB,sDAAW;AACjD,IAAI,sDAAW,CAAC,+CAAM;AACtB,CAAC;AACD;AACA,qBAAqB,6CAAI,gCAAgC;AACzD;AACA,QAAQ,+CAAM,wBAAwB,sDAAW;AACjD,IAAI,sDAAW,CAAC,+CAAM;AACtB,CAAC;AACD;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,QAAQ,+CAAM;AACd,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAM,IAAI,+CAAM;AAChD,cAAc;AACd,yBAAyB,+CAAM;AAC/B,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,+CAAM;AAC9B,wBAAwB,+CAAM;AAC9B;AACA;AACA,cAAc;AACd,uBAAuB,+CAAM;AAC7B,uBAAuB,+CAAM;AAC7B;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAkB;AACpD;AACA,gCAAgC,wBAAwB;AACxD;AACA,kCAAkC,sEAAkB;AACpD;AACA;AACA;AACA,cAAc;AACd,iCAAiC,sEAAkB;AACnD,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA,kCAAkC,gDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAkB;AACxD;AACA;AACA;AACA,kCAAkC,gDAAO;AACzC,gCAAgC,4CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6CAAI;AACrD;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAO;AACP;AACA;AACA;AACA;AACA,oBAAoB,+CAAM,IAAI,+CAAM;AACpC;AACA,uBAAuB,qDAAU,sBAAsB,6CAAQ,CAAC,KAAK,EAAE,KAAK,EAAE;AAC9E;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA,yBAAyB,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,0BAA0B,EAAE,IAAI,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAgB;AAC9C;AACA,iCAAiC;AACjC,sCAAsC;AACtC,MAAM;AACN,sBAAsB,UAAU;AAChC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAkB;AACrD,gCAAgC,+CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAE;AACpB;AACA,KAAK;AACL;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA,0BAA0B,6DAAa,EAAE,6DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,CAAC;AAC3B,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,CAAC;AAC3B,2BAA2B,CAAC;AAC5B,2BAA2B,CAAC;AAC5B;AACA,0BAA0B,+CAAM,IAAI,+CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM;AAC/C,8BAA8B,yCAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAG;AACjC;AACA;AACA;AACA;AACA,kDAAkD,+CAAM;AACxD;AACA,4BAA4B,+CAAM;AAClC,yDAAyD,+CAAU;AACnE;AACA;AACA,uCAAuC,sEAAkB;AACzD;AACA;AACA;AACA,sBAAsB,+CAAM,OAAO,+CAAM;AACzC;AACA;AACA;AACA,sCAAsC,+CAAM;AAC5C,sCAAsC,+CAAM;AAC5C;AACA,gBAAgB,+CAAM;AACtB,gCAAgC,+CAAU,CAAC,+CAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA,gCAAgC,+CAAU,CAAC,+CAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C,6CAAI;AAChD;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjwED,UAAU,mBAAO,CAAC,oDAAQ;AAC1B;AAGkB;AACY;AACY;AACb;AACG;AACV;AACtB;AACA;AACqC;AACF;AACI;AACX;AACkB;AAC9C;AAC2C;AACI;AACI;AACH;AAChD;AACA;AACkD;AACA;AAClD;AACA,IAAI,+DAAU;AACd,IAAI,+DAAU;AACd;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,wBAAwB,+CAAM;AAC9B;AACA,sBAAsB,aAAa,sDAAE,uCAAuC;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,GAAG;AACnC,wCAAwC,kBAAkB,qCAAqC,GAAG,gCAAgC,gBAAgB;AAClJ;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAAE,UAAU,4CAAI,UAAU,2CAAE;AACnE;AACA;AACA,wBAAwB,4CAAI;AAC5B,kCAAkC,kCAAkC,GAAG,KAAK;AAC5E,aAAa;AACb,+CAA+C,IAAI;AACnD;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,YAAY,2CAAE,SAAS,4CAAI;AAC3B;AACA,4EAA4E,sDAAE,eAAe;AAC7F,4CAA4C,sDAAE,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,MAAM,cAAc,sDAAE;AAC1C,iBAAiB;AACjB,cAAc;AACd,gBAAgB,MAAM,SAAS,sDAAE;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA,4BAA4B,MAAM,OAAO,sDAAE;AAC3C;AACA,+BAA+B,oDAAU,wBAAwB,GAAG;AACpE;AACA;AACA,gBAAgB,MAAM,SAAS,sDAAE;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAgB;AACzC,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,GAAG;AACnC,sBAAsB,8BAA8B,oBAAoB,WAAW,uBAAuB;AAC1G,iGAAiG,qDAAO,CAAC;AACzG,yCAAyC,YAAY;AACrD,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,GAAG,EAAE,wBAAwB;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,SAAS;AACT;AACA;AACA;AACA,QAAQ,2CAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAQ;AAC/B;AACA;AACA;AACA,uBAAuB,6DAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C,+BAA+B,EAAE,IAAI,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClQ+B;AACE;AACkB;AAOhC;AACnB;AACO;AACP,aAAa,+CAAM,KAAK,0CAAO;AAC/B,aAAa,+CAAM,KAAK,0CAAO;AAC/B;AACA,sCAAsC,+CAAM;AAC5C,uCAAuC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,gEAAkB;AACrC,mBAAmB,gEAAkB;AACrC;AACA;AACA,sBAAsB,8CAAS;AAC/B,oBAAoB,8CAAS,UAAU;AACvC;AACA,sBAAsB,8CAAS;AAC/B,oBAAoB,8CAAS;AAC7B;AACA;AACA,sCAAsC,mBAAmB,kDAAa,GAAG;AACzE,0CAA0C,mBAAmB,kDAAa,GAAG;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,+CAAU,kBAAkB,gDAAW;AAC5D;AACA;;;;;;;;;;;;;;;;;;;;;;ACjD+B;AACE;AAGjB;AAGG;AACnB;AACO;AACP,oCAAoC,gDAAO,gCAAgC,+CAAM;AACjF,oCAAoC,gDAAO,iCAAiC,+CAAM;AAClF;AACA,uBAAuB,+CAAM,KAAK,0CAAO;AACzC,uBAAuB,+CAAM,KAAK,0CAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,SAAS,+CAAM,KAAK,0CAAO;AAC3B,SAAS,+CAAM,KAAK,0CAAO;AAC3B;AACA,SAAS,+CAAM;AACf,SAAS,+CAAM;AACf;AACA,SAAS,gDAAO,6BAA6B;AAC7C,SAAS,gDAAO;AAChB;AACA;AACA;AACA;AACO;AACP,iBAAiB,8CAAS;AAC1B,iBAAiB,8CAAS;AAC1B;AACA,mBAAmB,8CAAS;AAC5B,mBAAmB,8CAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,8CAAS,cAAc,8CAAS;AACjD;;;;;;;;;;;;;;;ACpDA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA;;;;;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfmB;AACc;AACjC;AACO;AACA;AACP;AACA,QAAQ,+CAAU;AAClB,QAAQ,gDAAW;AACnB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,CAAC,YAAY,gDAAO;AACxC;AACA;AACA;AACA;AACA,IAAI,CAAC,YAAY,gDAAO;AACxB;AACA;AACO;AACP;AACA,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACO;AACP,OAAO,gDAAO;AACd;AACA,cAAc,CAAC;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,qBAAqB,IAAI,GAAG,MAAM,GAAG,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,GAAG,QAAQ,GAAG,QAAQ;AAChD;AACA,cAAc,OAAO,IAAI,KAAK;AAC9B;AACA;AACO;AACP;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC9IA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnJqB;AACiB;AACX;AACT;AAC6C;AAC7C;AACU;AACZ;AACA;AACS;AACxC;AACwD;AACC;AACpB;AACrC;AACA;AACA;AACA,IAAI,oDAAoD;AACxD;AACA,kBAAkB,gJAAkC;AACpD,wBAAwB,gLAAkD;AAC1E,2BAA2B,8JAAyC;AACpE,sBAAsB,sJAAqC;AAC3D;AACA;AACA,sBAAsB,8CAAS,CAAC,+DAAa,EAAE,+DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAM,QAAQ,+CAAM;AACtC;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0DAAK;AAC9C,6BAA6B,OAAO;AACpC,2BAA2B,0DAAK,qCAAqC,MAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO,oBAAoB,yCAAE;AACrC;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,gDAAO;AACf;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAO;AACf;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA;AACA,oCAAoC,sEAAkB;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,kBAAkB,+CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,IAAI,OAAO,GAAG,oBAAoB,GAAG,0BAA0B;AAC1F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB,IAAI,kBAAkB;AAChF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa,GAAG,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAU;AACrC;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAU;AACrC;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5oBM;AAIA;AACrB;AACoC;AACN;AACW;AACV;AACC;AACV;AACO;AAC2N;AAC5N;AACA;AACF;AACwC;AACxC;AACsB;AAChD;AACuC;AACA;AACM;AAC7C;AACwC;AACY;AACZ;AACxC;AACO;AACP,kBAAkB,CAAC;AACnB;AACA,yBAAyB,CAAC;AAC1B;AACA,sBAAsB;AACtB,mCAAmC,MAAM;AACzC,uBAAuB,MAAM;AAC7B,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,4BAA4B,+CAAM;AAClC,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS,qDAAE,UAAU,8CAAM,CAAC,2CAAE;AAC9B;AACA,YAAY,qDAAE;AACd;AACA;AACA;AACA,mCAAmC,qDAAE,WAAW;AAChD;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC,cAAc,2CAAE;AACrB,IAAI,CAAC;AACL,wBAAwB,CAAC;AACzB;AACA,aAAa,2CAAE;AACf,mBAAmB,mDAAY;AAC/B;AACA;AACA,mBAAmB,mDAAY;AAC/B;AACA,YAAY,2CAAE;AACd,mBAAmB,mDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,gDAAO;AACvB,gBAAgB,qDAAc;AAC9B,gBAAgB,kDAAQ;AACxB,cAAc;AACd;AACA,oBAAoB,mDAAY;AAChC,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA,IAAI,CAAC;AACL,YAAY,2CAAE;AACd,8BAA8B,oDAAU;AACxC;AACA;AACA;AACA,cAAc;AACd,gBAAgB,mDAAY;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,wBAAwB,+CAAM;AAC9B,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qCAAqC,+CAAK;AAC1C;AACA,gCAAgC,2CAAE;AAClC;AACA,yBAAyB,CAAC;AAC1B;AACA,kBAAkB,UAAU;AAC5B;AACA,iCAAiC,UAAU;AAC3C,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB,4BAA4B,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAK;AACjD;AACA,oBAAoB,CAAC;AACrB,oBAAoB,CAAC;AACrB;AACA;AACA;AACA,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+CAAK;AAClD;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAK;AACjB,SAAS;AACT;AACA,uBAAuB,sDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,uBAAuB,+CAAM;AAC7B,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS,qDAAS,sGAAsG;AACxH,SAAS,qDAAS;AAClB,SAAS,qDAAS;AAClB,oCAAoC,qDAAS,wBAAwB;AACrE,SAAS,qDAAS;AAClB,SAAS,qDAAS;AAClB;AACA,IAAI,CAAC;AACL;AACA;AACA,oBAAoB,CAAC;AACrB,QAAQ,8DAAoB;AAC5B,QAAQ,CAAC;AACT,QAAQ,2DAAK;AACb,QAAQ,yDAAe;AACvB;AACA;AACA,uBAAuB,kEAAY;AACnC,IAAI,CAAC;AACL,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACA,IAAI,CAAC,+BAA+B,2DAAK;AACzC,IAAI,CAAC;AACL;AACA,QAAQ,2DAAK;AACb,QAAQ,sDAAY;AACpB,KAAK;AACL;AACA,IAAI,CAAC,mBAAmB,kEAAY;AACpC,IAAI,CAAC;AACL,QAAQ,2DAAK;AACb,QAAQ,sDAAY;AACpB,KAAK;AACL;AACA,IAAI,CAAC;AACL,sBAAsB,+CAAM,CAAC,qDAAS;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,CAAC,+BAA+B,kEAAY;AAChD,IAAI,CAAC;AACL;AACA,QAAQ,2DAAK;AACb,QAAQ,sDAAY;AACpB,KAAK;AACL;AACA,IAAI,CAAC,+BAA+B,gDAAO;AAC3C,IAAI,CAAC;AACL;AACA,QAAQ,gDAAO;AACf,QAAQ,2DAAK;AACb,eAAe,+DAAqB,KAAK,+DAAqB;AAC9D,KAAK;AACL;AACA;AACO;AACP,oBAAoB,+CAAM;AAC1B,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,2CAAE,UAAU,4CAAI,eAAe,2CAAE,QAAQ,4CAAI;AACrE;AACA;AACA;AACA,YAAY,qDAAS;AACrB,yDAAyD,yCAAI,gCAAgC;AAC7F;AACA;AACA,YAAY,qDAAS;AACrB,2DAA2D,+CAAM,gCAAgC;AACjG,wDAAwD,+CAAM,WAAW;AACzE,eAAe,+CAAM,mCAAmC;AACxD,oBAAoB,aAAa;AACjC,2CAA2C,+CAAM,eAAe;AAChE;AACA;AACA,YAAY,qDAAS;AACrB,sEAAsE,+CAAM,WAAW;AACvF;AACA;AACA,YAAY,qDAAS;AACrB,6DAA6D,8CAAI,gCAAgC;AACjG;AACA;AACA,YAAY,qDAAS;AACrB,0DAA0D,yCAAI,WAAW;AACzE;AACA;AACA,YAAY,qDAAS;AACrB,uDAAuD,+CAAK,gCAAgC;AAC5F;AACA;AACA,YAAY,qDAAS;AACrB,wDAAwD,+CAAK,kCAAkC;AAC/F;AACA;AACA,YAAY,qDAAS;AACrB,yDAAyD,+CAAK,mCAAmC;AACjG;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA,QAAQ,yCAAI;AACZ,QAAQ,uDAAa;AACrB,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb,YAAY,qDAAW,CAAC,CAAC;AACzB,UAAU;AACV,YAAY,CAAC;AACb,YAAY,qDAAW;AACvB;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL,QAAQ,qDAAW;AACnB,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA,QAAQ,+CAAM;AACd,QAAQ,2DAAK,cAAc,+CAAM;AACjC,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,4DAAK;AACb;AACA,QAAQ,8CAAI;AACZ,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA,QAAQ,yCAAI;AACZ,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,2DAAK;AACb;AACA,QAAQ,+CAAK;AACb,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,2DAAK;AACb;AACA,qBAAqB,+CAAK;AAC1B,aAAa,+CAAK;AAClB,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,2DAAK;AACb;AACA,QAAQ,+CAAK;AACb,KAAK;AACL;AACA;AACO;AACP,kBAAkB,+CAAM;AACxB,eAAe,qDAAS;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA,kCAAkC,CAAC;AACnC,oBAAoB,qDAAS,uCAAuC,gBAAgB,qDAAS,sBAAsB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAC,2BAA2B,0BAA0B,qDAAS,0BAA0B,OAAO,MAAM;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAY;AAClD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA,oBAAoB,sDAAY;AAChC,MAAM;AACN;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,wBAAwB,+CAAM;AAC9B,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,qDAAS,+BAA+B;AACvF,oCAAoC,qDAAS,gBAAgB;AAC7D;AACA;AACA,OAAO,2CAAE,SAAS,4CAAI;AACtB,uDAAuD,qDAAS,iBAAiB;AACjF;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL,wBAAwB,+CAAM;AAC9B,mBAAmB,2DAAU,CAAC,qDAAS;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA,4GAA4G,qDAAS,QAAQ;AAC7H;AACA,0FAA0F,qDAAS,YAAY;AAC/G;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA,sBAAsB,CAAC;AACvB;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,6BAA6B,CAAC;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,CAAC;AACjB;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA,iCAAiC,6DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,qDAAqD,uDAAO,CAAC;AAC7D;AACA,sCAAsC,oDAAU,iBAAiB,QAAQ;AACzE;AACA,0BAA0B,8CAAI;AAC9B,iBAAiB;AACjB;AACA,4BAA4B,CAAC;AAC7B;AACA,8BAA8B,SAAS,WAAW,QAAQ;AAC1D,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU,iCAAiC,iBAAiB,GAAG,WAAW,GAAG,SAAS,KAAK,EAAE;AAC3H;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,CAAC,4BAA4B,oDAAc;AAC/C;AACA;AACO;AACP,oBAAoB,+CAAM;AAC1B,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,yDAAM,CAAC;AACpD,kDAAkD,qEAAM,CAAC;AACzD,mDAAmD,yDAAM,CAAC;AAC1D;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA,iBAAiB,CAAC;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB,IAAI,MAAM;AAC/E;AACA,kBAAkB,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAQ,CAAC;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB,CAAC;AAClB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,sBAAsB,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,CAAC;AAC/B;AACA,4BAA4B;AAC5B;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mCAAmC,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,+CAAM;AAC9B,eAAe,qDAAS;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAS;AAClD,gCAAgC,kBAAkB,8DAA8D,IAAI,qDAAS,eAAe;AAC5I,MAAM,qDAAS,gBAAgB;AAC/B,MAAM,qDAAS,gBAAgB;AAC/B;AACA,yCAAyC,qDAAS;AAClD;AACA,mBAAmB,qDAAS,wBAAwB;AACpD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,yCAAyC,qDAAS;AAClD,WAAW,qDAAS,oBAAoB;AACxC;AACA,eAAe,qDAAS,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,gBAAgB;AACxC;AACA;AACA;AACA;AACA,MAAM,qDAAS,sBAAsB;AACrC;AACA,0CAA0C,qDAAS;AACnD,gCAAgC,kBAAkB,OAAO,qDAAS,qBAAqB;AACvF,MAAM,qDAAS,sBAAsB;AACrC,MAAM,qDAAS,mBAAmB;AAClC,MAAM,qDAAS,oBAAoB;AACnC,MAAM,qDAAS,oBAAoB;AACnC,MAAM,qDAAS,qBAAqB;AACpC,MAAM,qDAAS,wBAAwB;AACvC;AACA,4CAA4C,qDAAS;AACrD,gCAAgC,kBAAkB,OAAO,qDAAS,wBAAwB;AAC1F,MAAM,qDAAS,uBAAuB;AACtC,MAAM,qDAAS,8BAA8B;AAC7C;AACA,eAAe,qDAAS,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAS;AACnD,WAAW,qDAAS,qBAAqB;AACzC,UAAU,qDAAS,yBAAyB;AAC5C;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACO;AACP,kBAAkB,+CAAM;AACxB,eAAe,2DAAU,CAAC,qDAAS;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAS,kBAAkB,UAAU;AACjE;AACA;AACA;AACA,qCAAqC,IAAI,2BAA2B,IAAI;AACxE,gCAAgC,UAAU;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,CAAC;AACL,IAAI,CAAC;AACL;;;;;;UClyBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;;;;;WCFA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;;;;UEhDA;UACA;UACA;UACA;UACA","sources":["webpack://goroxels-client/./src/img/3rdcf.png","webpack://goroxels-client/./src/img/admin-badge.svg","webpack://goroxels-client/./src/img/arrow.svg","webpack://goroxels-client/./src/img/badges/badge0.png","webpack://goroxels-client/./src/img/badges/badge1.png","webpack://goroxels-client/./src/img/chunkPlaceholder.png","webpack://goroxels-client/./src/img/creator-badge.svg","webpack://goroxels-client/./src/img/cross.svg","webpack://goroxels-client/./src/img/discord-logo-circle.svg","webpack://goroxels-client/./src/img/dots.svg","webpack://goroxels-client/./src/img/fb-logo.svg","webpack://goroxels-client/./src/img/goroxels.png","webpack://goroxels-client/./src/img/mod-badge.svg","webpack://goroxels-client/./src/img/protectedPattern.png","webpack://goroxels-client/./src/img/stripes.png","webpack://goroxels-client/./src/img/telegram.svg","webpack://goroxels-client/./src/img/toolIcons/clicker.png","webpack://goroxels-client/./src/img/toolIcons/floodfill.png","webpack://goroxels-client/./src/img/toolIcons/line.png","webpack://goroxels-client/./src/img/toolIcons/move.png","webpack://goroxels-client/./src/img/toolIcons/protect.png","webpack://goroxels-client/./src/img/toolIcons/revert.png","webpack://goroxels-client/./src/img/trash2.svg","webpack://goroxels-client/./src/img/unavailable.png","webpack://goroxels-client/./src/img/user.svg","webpack://goroxels-client/./src/img/user2.png","webpack://goroxels-client/./src/img/vk-logo.svg","webpack://goroxels-client/./src/img/winamp/bg.png","webpack://goroxels-client/./src/img/winamp/bg2.png","webpack://goroxels-client/./src/img/winamp/digits.png","webpack://goroxels-client/./src/img/winamp/hr-slider-btn-small.png","webpack://goroxels-client/./src/img/winamp/slider-btn.png","webpack://goroxels-client/./src/video/as.webm","webpack://goroxels-client/./src/video/brush.webm","webpack://goroxels-client/./src/video/brush2.webm","webpack://goroxels-client/./src/video/clicker.webm","webpack://goroxels-client/./src/video/clickerMouse.webm","webpack://goroxels-client/./src/video/ctrlZ.webm","webpack://goroxels-client/./src/video/flood.webm","webpack://goroxels-client/./src/video/line.webm","webpack://goroxels-client/./src/video/patternDemo.webm","webpack://goroxels-client/./src/video/toolC.webm","webpack://goroxels-client/./src/font/pixel/min5.png","webpack://goroxels-client/./src/font/pixel/min5.txt","webpack://goroxels-client/./src/font/pixel/winamp.png","webpack://goroxels-client/./src/font/pixel/winamp.txt","webpack://goroxels-client/./src/css/colorVars.css","webpack://goroxels-client/./src/css/style.css","webpack://goroxels-client/./src/img/winamp/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/js/Bucket.js","webpack://goroxels-client/./src/js/Chunk.js","webpack://goroxels-client/./src/js/ChunkManager.js","webpack://goroxels-client/./src/js/EventManager.js","webpack://goroxels-client/./src/js/MiniWindow.js","webpack://goroxels-client/./src/js/Pattern.js","webpack://goroxels-client/./src/js/Renderer.js","webpack://goroxels-client/./src/js/Socket.js","webpack://goroxels-client/./src/js/TempChunkPlaceholder.js","webpack://goroxels-client/./src/js/Tool.js","webpack://goroxels-client/./src/js/ToolManager.js","webpack://goroxels-client/./src/js/Window.js","webpack://goroxels-client/./src/js/actions.js","webpack://goroxels-client/./src/js/assets.js","webpack://goroxels-client/./src/js/camera.js","webpack://goroxels-client/./src/js/chat.js","webpack://goroxels-client/./src/js/constants.js","webpack://goroxels-client/./src/js/elements.js","webpack://goroxels-client/./src/js/fxcanvas.js","webpack://goroxels-client/./src/js/globals.js","webpack://goroxels-client/./src/js/indexedDb.js","webpack://goroxels-client/./src/js/main.js","webpack://goroxels-client/./src/js/me.js","webpack://goroxels-client/./src/js/player.js","webpack://goroxels-client/./src/js/protocol.js","webpack://goroxels-client/./src/js/template.js","webpack://goroxels-client/./src/js/tools.js","webpack://goroxels-client/./src/js/user.js","webpack://goroxels-client/./src/js/utils/camera.js","webpack://goroxels-client/./src/js/utils/conversions.js","webpack://goroxels-client/./src/js/utils/cssColorsList.js","webpack://goroxels-client/./src/js/utils/ip.js","webpack://goroxels-client/./src/js/utils/math.js","webpack://goroxels-client/./src/js/utils/misc.js","webpack://goroxels-client/./src/js/utils/shapes.js","webpack://goroxels-client/./src/js/utils/strings.js","webpack://goroxels-client/./src/js/winamp/PcmPlayer.js","webpack://goroxels-client/./src/js/winamp/player.js","webpack://goroxels-client/./src/js/windows.js","webpack://goroxels-client/webpack/bootstrap","webpack://goroxels-client/webpack/runtime/amd define","webpack://goroxels-client/webpack/runtime/chunk loaded","webpack://goroxels-client/webpack/runtime/compat get default export","webpack://goroxels-client/webpack/runtime/define property getters","webpack://goroxels-client/webpack/runtime/hasOwnProperty shorthand","webpack://goroxels-client/webpack/runtime/make namespace object","webpack://goroxels-client/webpack/runtime/publicPath","webpack://goroxels-client/webpack/runtime/jsonp chunk loading","webpack://goroxels-client/webpack/before-startup","webpack://goroxels-client/webpack/startup","webpack://goroxels-client/webpack/after-startup"],"sourcesContent":["export default __webpack_public_path__ + \"/img/3rdcf.png\";","export default __webpack_public_path__ + \"/img/admin-badge.svg\";","export default __webpack_public_path__ + \"/img/arrow.svg\";","export default __webpack_public_path__ + \"/img/badge0.png\";","export default __webpack_public_path__ + \"/img/badge1.png\";","export default __webpack_public_path__ + \"/img/chunkPlaceholder.png\";","export default __webpack_public_path__ + \"/img/creator-badge.svg\";","export default __webpack_public_path__ + \"/img/cross.svg\";","export default __webpack_public_path__ + \"/img/discord-logo-circle.svg\";","export default __webpack_public_path__ + \"/img/dots.svg\";","export default __webpack_public_path__ + \"/img/fb-logo.svg\";","export default __webpack_public_path__ + \"/img/goroxels.png\";","export default __webpack_public_path__ + \"/img/mod-badge.svg\";","export default __webpack_public_path__ + \"/img/protectedPattern.png\";","export default __webpack_public_path__ + \"/img/stripes.png\";","export default __webpack_public_path__ + \"/img/telegram.svg\";","export default __webpack_public_path__ + \"/img/clicker.png\";","export default __webpack_public_path__ + \"/img/floodfill.png\";","export default __webpack_public_path__ + \"/img/line.png\";","export default __webpack_public_path__ + \"/img/move.png\";","export default __webpack_public_path__ + \"/img/protect.png\";","export default __webpack_public_path__ + \"/img/revert.png\";","export default __webpack_public_path__ + \"/img/trash2.svg\";","export default __webpack_public_path__ + \"/img/unavailable.png\";","export default __webpack_public_path__ + \"/img/user.svg\";","export default __webpack_public_path__ + \"/img/user2.png\";","export default __webpack_public_path__ + \"/img/vk-logo.svg\";","export default __webpack_public_path__ + \"/img/bg.png\";","export default __webpack_public_path__ + \"/img/bg2.png\";","export default __webpack_public_path__ + \"/img/digits.png\";","export default __webpack_public_path__ + \"/img/hr-slider-btn-small.png\";","export default __webpack_public_path__ + \"/img/slider-btn.png\";","export default __webpack_public_path__ + \"/video/as.webm\";","export default __webpack_public_path__ + \"/video/brush.webm\";","export default __webpack_public_path__ + \"/video/brush2.webm\";","export default __webpack_public_path__ + \"/video/clicker.webm\";","export default __webpack_public_path__ + \"/video/clickerMouse.webm\";","export default __webpack_public_path__ + \"/video/ctrlZ.webm\";","export default __webpack_public_path__ + \"/video/flood.webm\";","export default __webpack_public_path__ + \"/video/line.webm\";","export default __webpack_public_path__ + \"/video/patternDemo.webm\";","export default __webpack_public_path__ + \"/video/toolC.webm\";","export default __webpack_public_path__ + \"/font/min5.png\";","export default __webpack_public_path__ + \"/font/min5.txt\";","export default __webpack_public_path__ + \"/font/winamp.png\";","export default __webpack_public_path__ + \"/font/winamp.txt\";","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","var map = {\n\t\"./bg.png\": \"./src/img/winamp/bg.png\",\n\t\"./bg2.png\": \"./src/img/winamp/bg2.png\",\n\t\"./digits.png\": \"./src/img/winamp/digits.png\",\n\t\"./hr-slider-btn-small.png\": \"./src/img/winamp/hr-slider-btn-small.png\",\n\t\"./slider-btn.png\": \"./src/img/winamp/slider-btn.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/winamp sync \\\\.png$\";","export default class Bucket{\r\n    constructor(delay, max){\r\n        this._allowance = 0;\r\n\r\n        this.delay = delay;\r\n        this.max = max;\r\n\r\n        this.lastCheck = Date.now();\r\n    }\r\n\r\n    get allowance () {\r\n        if(this.delay === 0) return Infinity;\r\n        \r\n        this._allowance += (Date.now() - this.lastCheck) / this.delay;\r\n\r\n        this.lastCheck = Date.now();\r\n\r\n        if(this._allowance > this.max) this._allowance = this.max;\r\n\r\n        return this._allowance\r\n    }\r\n\r\n    set allowance(c){\r\n        this._allowance = c;\r\n    }\r\n\r\n    spend(count){\r\n        if(this.delay === 0) return true;\r\n\r\n        let allow = this.allowance;\r\n\r\n        if(allow < count) return false;\r\n\r\n        this.allowance  = allow - count;\r\n\r\n        return true\r\n    }\r\n}","import Pattern from './Pattern';\r\nimport {\r\n    chunkSize,\r\n    bgrPalette,\r\n    game\r\n} from './config'\r\nimport protectedPatternUrl from '../img/protectedPattern.png';\r\n\r\nexport default class Chunk {\r\n    constructor(x, y, buffer) {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        this.width = chunkSize;\r\n        this.height = chunkSize;\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = this.canvas.height = chunkSize;\r\n\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        this.imgData = this.ctx.createImageData(chunkSize, chunkSize);\r\n        this.view = new Uint32Array(this.imgData.data.buffer);\r\n\r\n        // protected\r\n\r\n        // chunksized means the canvas with sizes of the chunk, filled with \"protected\" pattern\r\n        this.protectedPatternChunkSized = null;\r\n        this._protectedPattern = new Pattern(protectedPatternUrl);\r\n        this._protectedPattern.onload = () => {\r\n            this.needRender = true;\r\n            // pattern shift is an offset, to shift\r\n            // the texture for current chunk, because it might not\r\n            // be dividable by chunk size (pattern misjoint between chunks in result)\r\n            const patternShift = [\r\n                (this.x * this.width) % this._protectedPattern.canvas.width,\r\n                (this.y * this.height) % this._protectedPattern.canvas.height\r\n            ]\r\n\r\n            this.protectedPatternChunkSized = this._protectedPattern.createFilledCanvas(this.width, this.height, patternShift[0], patternShift[1]);\r\n        }\r\n\r\n        this.pCanvas = document.createElement('canvas');\r\n        this.pCanvas.width = this.pCanvas.height = chunkSize;\r\n\r\n        this.pCtx = this.pCanvas.getContext('2d');\r\n        this.pImgData = this.pCtx.createImageData(chunkSize, chunkSize);\r\n        this.pView = new Uint32Array(this.pImgData.data.buffer);\r\n\r\n        this.needRender = true;\r\n\r\n        this.fromBuffer(buffer);\r\n    }\r\n\r\n    render() {\r\n        if (this.needRender) {\r\n            this.needRender = false;\r\n            this.ctx.putImageData(this.imgData, 0, 0);\r\n\r\n            if (game.showProtected) {\r\n                this.ctx.globalAlpha = 0.7;\r\n\r\n                this.pCtx.putImageData(this.pImgData, 0, 0);\r\n                if(this.protectedPatternChunkSized !== null){\r\n                    this.pCtx.globalCompositeOperation = 'source-in';\r\n                    this.pCtx.drawImage(this.protectedPatternChunkSized, 0, 0);\r\n                    this.pCtx.globalCompositeOperation = 'source-over'; // back to default\r\n                }\r\n\r\n                this.ctx.drawImage(this.pCanvas, 0, 0);\r\n\r\n                this.ctx.globalAlpha = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    fromBuffer(buf) {\r\n        let col, isProtected;\r\n        for (let i = 0; i < buf.byteLength; i++) {\r\n            col = buf[i];\r\n            isProtected = col & 0x80;\r\n\r\n            isProtected && (this.pView[i] = 0xFFFF0000);\r\n            this.view[i] = bgrPalette[col & 0x7F];\r\n        }\r\n    }\r\n\r\n    get(x, y) {\r\n        return this.view[x + y * chunkSize]\r\n    }\r\n\r\n    set(x, y, c) {\r\n        const i = x + y * chunkSize\r\n\r\n        this.view[i] = c;\r\n\r\n        this.needRender = true;\r\n    }\r\n\r\n    setProtect(x, y, state) {\r\n        const i = x + y * chunkSize;\r\n        this.pView[i] = state ? 0xFFFF0000 : 0;\r\n\r\n        this.needRender = true;\r\n    }\r\n\r\n    getProtect(x, y) {\r\n        const i = x + y * chunkSize;\r\n        return !!this.pView[i];\r\n    }\r\n}","import globals from './globals';\r\nimport Chunk from './Chunk';\r\nimport {\r\n    bgrPalette,\r\n    argbToId,\r\n    boardWidth, boardHeight, chunkSize, canvasId\r\n} from './config';\r\nimport {\r\n    boardToChunk\r\n} from './utils/conversions'\r\nimport { apiRequest } from './actions';\r\nimport Pako from 'pako';\r\nimport TempChunkPlaceholder from './TempChunkPlaceholder';\r\n\r\nexport default class ChunkManager {\r\n    constructor() {\r\n        this.chunks = new Map();\r\n\r\n        this.loadingChunks = new Set();\r\n\r\n        // globals.socket.on('chunk', (cx, cy, cdata) => {\r\n        //     let key = this.getChunkKey(cx, cy);\r\n        //     if (this.loadingChunks.has(key)){\r\n        //         this.loadingChunks.delete(key);\r\n        //     }\r\n\r\n        //     let chunk = new Chunk(cx, cy, cdata);\r\n        //     this.chunks.set(key, chunk);\r\n\r\n        //     globals.renderer.needRender = true;\r\n        // })\r\n\r\n        globals.socket.on('place', (x, y, col) => {\r\n            this.setChunkPixel(x, y, col);\r\n\r\n            globals.renderer.needRender = true;\r\n        })\r\n\r\n        globals.socket.on('protect', (x, y, state) => {\r\n            this.setProtect(x, y, state);\r\n            \r\n            globals.renderer.needRender = true;\r\n        })\r\n    }\r\n\r\n    getChunkKey(x, y) {\r\n        return x << 4 | y\r\n    }\r\n\r\n    reloadChunks(){\r\n        this.test = true;\r\n        let loadQueue = [...this.chunks.values()];\r\n        const interval = setInterval(() => {\r\n            if(this.loadingChunks.size < 3){\r\n                const chunk = loadQueue.pop();\r\n                if(!chunk){\r\n                    return clearInterval(interval);\r\n                }\r\n                this.loadChunk(chunk.x, chunk.y);\r\n            }\r\n        }, 30)\r\n    }\r\n\r\n    loadChunk(x, y) {\r\n        let key = this.getChunkKey(x, y);\r\n\r\n        if (globals.socket.connected && !this.loadingChunks.has(key) && this.loadingChunks.size < 5) {\r\n            this.loadingChunks.add(key);\r\n            // globals.socket.requestChunk(x, y);\r\n            apiRequest(`/getchunk?canvas=${canvasId}&x=${x}&y=${y}`).then(async (resp) => {\r\n                \r\n                let key = this.getChunkKey(x, y);\r\n                if (this.loadingChunks.has(key)){\r\n                    this.loadingChunks.delete(key);\r\n                }\r\n\r\n                // use pako only if chunk got from socket\r\n                // const cdataCompressed = await resp.arrayBuffer();\r\n                // const cdata = Pako.inflate(cdataCompressed);\r\n\r\n                const cdata = await resp.arrayBuffer();\r\n\r\n                let chunk = new Chunk(x, y, new Uint8Array(cdata));\r\n                this.chunks.set(key, chunk);\r\n\r\n                chunk.render(); // workaround because TempChunkPlaceholder getting zeroes until chunk is rendered once\r\n                new TempChunkPlaceholder(x, y).save(chunk.canvas);\r\n\r\n                globals.renderer.needRender = true;\r\n            });\r\n        }\r\n    }\r\n\r\n    clearLoadingChunks(){\r\n        this.loadingChunks = new Set;\r\n    }\r\n\r\n    hasChunk(x, y) {\r\n        let key = this.getChunkKey(x, y);\r\n\r\n        return this.chunks.has(key);\r\n    }\r\n\r\n    getChunk(x, y) {\r\n        let key = this.getChunkKey(x, y);\r\n\r\n        if (!this.chunks.has(key)) {\r\n            return 0\r\n        }\r\n        return this.chunks.get(key)\r\n    }\r\n\r\n    getChunkPixel(x, y) {\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n        let chunk = this.getChunk(cx, cy);\r\n\r\n        if (!chunk || x < 0 || y < 0) return -1\r\n\r\n        let argb = chunk.get(offx, offy);\r\n\r\n        return argbToId[argb]\r\n    }\r\n\r\n    setChunkPixel(x, y, col) {\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n\r\n        let key = this.getChunkKey(cx, cy);\r\n        if (this.chunks.has(key)) {\r\n            this.chunks.get(key).set(offx, offy, bgrPalette[col])\r\n        }\r\n    }\r\n\r\n    setProtect(x, y, state){\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n\r\n        let key = this.getChunkKey(cx, cy);\r\n        if (this.chunks.has(key)) {\r\n            this.chunks.get(key).setProtect(offx, offy, state)\r\n        }\r\n    }\r\n\r\n    getProtect(x, y){\r\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\r\n        let chunk = this.getChunk(cx, cy);\r\n        if (!chunk) return -1\r\n\r\n        return chunk.getProtect(offx, offy);\r\n    }\r\n\r\n    // for the screenshot function\r\n    dumpAll(){\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = boardWidth;\r\n        canvas.height = boardHeight;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        this.chunks.forEach(chunk => {\r\n            if(!chunk.canvas) return;\r\n\r\n            const offX = chunk.x * chunkSize,\r\n                offY = chunk.y * chunkSize;\r\n            \r\n            ctx.drawImage(chunk.canvas, offX, offY)\r\n        })\r\n        return canvas\r\n    }\r\n}","import EventEmitter from 'events'\r\nimport interact from 'interactjs'\r\n\r\nfunction anyInputFocused() {\r\n    return document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA'\r\n}\r\n\r\nexport default class EventManager extends EventEmitter {\r\n    /**\r\n     * \r\n     * @param {Element} element \r\n     */\r\n    constructor(element) {\r\n        super();\r\n\r\n        this.el = element\r\n\r\n        this._zoomed = false;\r\n\r\n        // true from when two pointers started touch\r\n        // until both of them off\r\n        this.startedGesture = false,\r\n            this.pointers = 0;\r\n        function checkGesture(evName) {\r\n            let wasGesture = this.startedGesture;\r\n            if (evName === 'up') {\r\n                this.pointers = Math.max(this.pointers - 1, 0);\r\n                if (this.pointers == 0) this.startedGesture = false;\r\n            } else if (evName === 'down') {\r\n                if (++this.pointers >= 2)\r\n                    wasGesture = this.startedGesture = true;\r\n            }\r\n            return wasGesture\r\n        }\r\n        checkGesture = checkGesture.bind(this)\r\n\r\n        // some of my friends has an issue where \r\n        // event.movementX/Y sometimes was not present\r\n        let pointerMovementWorkaround = {};\r\n\r\n        const FFA_REPLACE_MOVEMENT = true;\r\n\r\n        element.addEventListener('pointerdown', e => {\r\n            e.gesture = checkGesture('down');\r\n            this.emit('mousedown', e);\r\n        });\r\n        document.addEventListener('pointermove', e => {\r\n            if (FFA_REPLACE_MOVEMENT || !e.movementX || !e.movementY) {\r\n                // by default, movementX and movementY are read only\r\n                Object.defineProperty(e, 'movementX', {\r\n                    writable: true\r\n                });\r\n                Object.defineProperty(e, 'movementY', {\r\n                    writable: true\r\n                });\r\n\r\n                let lastPos = pointerMovementWorkaround[e.pointerId];\r\n                if (!lastPos) {\r\n                    e.movementX = 0;\r\n                    e.movementY = 0;\r\n                } else {\r\n                    e.movementX = e.clientX - lastPos[0];\r\n                    e.movementY = e.clientY - lastPos[1];\r\n                }\r\n\r\n                pointerMovementWorkaround[e.pointerId] = [e.clientX, e.clientY];\r\n            }\r\n            // not emitted because Interactjs below will emit this correctly\r\n            if (!checkGesture('move')) {\r\n                this.emit('mousemove', e);\r\n            }\r\n        });\r\n        document.addEventListener('pointerup', e => {\r\n            let pointersCnt = this.pointers;\r\n            e.gesture = checkGesture('up');\r\n\r\n            // emit event only if 'pointerdown' event was on canvas\r\n            if (pointersCnt)\r\n                this.emit('mouseup', e);\r\n\r\n            delete pointerMovementWorkaround[e.pointerId];\r\n        });\r\n\r\n        interact(element).gesturable({\r\n            onmove: e => {\r\n                // console.log(e);\r\n                this.emit('zoom', e.ds);\r\n\r\n                this.emit('mousemove', {\r\n                    buttons: e.buttons,\r\n\r\n                    clientX: e.clientX,\r\n                    clientY: e.clientY,\r\n\r\n                    movementX: e.dx * devicePixelRatio,\r\n                    movementY: e.dy * devicePixelRatio,\r\n\r\n                    gesture: true\r\n                })\r\n            }\r\n        })\r\n\r\n        this.tickLoop = setInterval(() => {\r\n            this.emit('tick')\r\n        }, 1000 / 60);\r\n\r\n        document.addEventListener('keydown', e => {\r\n            if (!anyInputFocused()) {\r\n                this.emit('keydown', e)\r\n            }\r\n        });\r\n\r\n        document.addEventListener('keyup', e => {\r\n            if (!anyInputFocused()) {\r\n                this.emit('keyup', e)\r\n            }\r\n        });\r\n\r\n        element.addEventListener('wheel', e => this.emit('wheel', e))\r\n        element.addEventListener('mouseleave', e => this.emit('mouseleave', e))\r\n    }\r\n}","import EventEmitter from 'events';\r\n\r\nexport default class MiniWindow extends EventEmitter{\r\n    // 1=ok, 2=ok+cancel\r\n    constructor(title='', closeButtons=1){\r\n        super();\r\n\r\n        this.title = title;\r\n\r\n        this._closeButtons = closeButtons;\r\n\r\n        this.element = null;\r\n        this.bodyElement = null;\r\n\r\n        this.closed = false;\r\n\r\n        this._create();\r\n    }\r\n\r\n    _create(){\r\n        const html = $(`\r\n        <div class=\"miniWindow\">\r\n            <div class=\"miniWindowTitle\">\r\n                ${this.title}\r\n            </div>\r\n            <div class=\"miniWindowBody\">\r\n            </div>\r\n            <div class=\"miniWindowButtons\">\r\n            </div>\r\n        </div>\r\n        `);\r\n\r\n        const buttons = [];\r\n        if(this._closeButtons >= 1){\r\n            const okButton = $('<button>ok</button>');\r\n            okButton.on('click', this.buttonHandler.bind(this, 'ok'));\r\n            buttons.push(okButton);\r\n        }\r\n        if(this._closeButtons >= 2){\r\n            const cancelButton = $('<button>cancel</button>');\r\n            cancelButton.on('click', this.buttonHandler.bind(this, 'cancel'));\r\n            buttons.push(cancelButton);\r\n        }\r\n        \r\n        buttons.forEach(b => $('.miniWindowButtons', html).append(b));\r\n\r\n        this.element = html;\r\n        this.bodyElement = $('.miniWindowBody', html);\r\n    }\r\n\r\n    buttonHandler(buttonName){\r\n        const event = {\r\n            _cancelledClose: false,\r\n            cancelClose: function(){ this._cancelledClose = true }\r\n        }\r\n\r\n        switch(buttonName){\r\n            case 'ok':\r\n                this.emit('okClicked', event);\r\n                break;\r\n            case 'cancel':\r\n                this.emit('cancelClicked', event);\r\n        }\r\n\r\n        if(!event._cancelledClose){\r\n            this.close();\r\n        }\r\n    }\r\n\r\n    close(){\r\n        this.removeAllListeners();\r\n        this.element.remove();\r\n        this.closed = true;\r\n    }\r\n}","export default class Pattern{\r\n    constructor(url){\r\n        this.url = url;\r\n        this.loaded = false;\r\n\r\n        this.canvas = null\r\n\r\n        this._load()\r\n    }\r\n\r\n    _load(){\r\n        const canvas = document.createElement('canvas');\r\n        \r\n        const img = new Image();\r\n        img.src = this.url;\r\n\r\n        img.onload = () => {\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n\r\n            canvas.getContext('2d').drawImage(img, 0, 0);\r\n\r\n            this.canvas = canvas;\r\n\r\n            this.loaded = true;\r\n            this.onload();\r\n        }\r\n    }\r\n\r\n    createFilledCanvas(width, height, offsetX, offsetY){\r\n        const ctx = this.canvas.getContext('2d');\r\n        const pattern = ctx.createPattern(this.canvas, 'repeat');\r\n\r\n        const filledCanvas = document.createElement('canvas');\r\n        filledCanvas.width = width;\r\n        filledCanvas.height = height;\r\n\r\n        const filledCtx = filledCanvas.getContext('2d');\r\n        \r\n        filledCtx.fillStyle = pattern;\r\n        \r\n        // this \"save restore\" shit is copied from stackoverflow\r\n        // it's needed to actually shift the pattern\r\n        filledCtx.save();\r\n        filledCtx.translate(offsetX, offsetY);\r\n        filledCtx.fillRect(-offsetX, -offsetY, width, height);\r\n        filledCtx.restore();\r\n\r\n        return filledCanvas;\r\n    }\r\n\r\n    onload(){}\r\n}","import ChunkPlaceholder from '../img/chunkPlaceholder.png';\r\nimport camera from './camera';\r\nimport { chunkSize, hexPalette } from './config';\r\nimport globals from './globals';\r\nimport Pattern from './Pattern';\r\nimport { getVisibleChunks } from './utils/camera';\r\nimport {\r\n    halfMap,\r\n    insanelyLongMobileBrowserCheck\r\n} from './utils/misc';\r\nimport template from './template';\r\nimport shapes from './utils/shapes';\r\nimport player from './player';\r\nimport TempChunkPlaceholder from './TempChunkPlaceholder';\r\n\r\nconst isMobile = insanelyLongMobileBrowserCheck();\r\n\r\n\r\nexport default class Renderer {\r\n    /**\r\n     * \r\n     * @param {CanvasRenderingContext2D} ctx \r\n     */\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n        this.canvas = this.ctx.canvas;\r\n\r\n        this.chunkPlaceholderPattern = new Pattern(ChunkPlaceholder);\r\n        this.chunkPlaceholderPattern.onload = () => {\r\n            this.needRender = true;\r\n        }\r\n        this.chunkPreviews = {};\r\n\r\n        this.needRender = true;\r\n\r\n        this.preRendered = {\r\n            brush: {\r\n                canvas: undefined,\r\n                ctx: undefined,\r\n                imageData: undefined,\r\n\r\n                circle: undefined,\r\n            }\r\n        }\r\n\r\n        this.preRender();\r\n    }\r\n\r\n    preRender(){\r\n        this.preRenderBrush();\r\n    }\r\n\r\n    preRenderBrush(){\r\n        // TODO make it render only before brush used\r\n        // because it renders on every zoom\r\n        const size = player.brushSize,\r\n            zoom = camera.zoom;\r\n        \r\n        if(zoom < 1) return\r\n\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvas.height = zoom*(size+1);\r\n        const ctx = canvas.getContext('2d');\r\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\r\n\r\n        const r = size/2;\r\n\r\n        const circle = shapes.filledCircle(0, 0, r);\r\n        let circleMatrix = [];\r\n        for(let y = 0; y < size+1; y++){\r\n            circleMatrix.push((new Array(size+1)).fill(0))\r\n        }\r\n        \r\n        circle.forEach(([x, y]) => {\r\n            circleMatrix[x+r][y+r] = 1;\r\n        })\r\n        \r\n        ctx.beginPath();\r\n        ctx.lineWidth = zoom / 4;\r\n        ctx.strokeStyle = hexPalette[player.color];\r\n        ctx.lineCap = 'square';\r\n\r\n        ctx.fillStyle = 'blue';\r\n\r\n        for(let x = 0; x < size; x++){\r\n            for(let y = 0; y < size; y++){\r\n                if(isBound(x, y)) continue;\r\n\r\n                let upper = isBound(x, y-1),\r\n                    left = isBound(x - 1, y),\r\n                    right = isBound(x + 1, y),\r\n                    bottom = isBound(x, y + 1);\r\n\r\n                if(upper){\r\n                    ctx.moveTo(x*zoom, y*zoom);\r\n                    ctx.lineTo((x+1)*zoom, y*zoom);\r\n                }\r\n                if(left){\r\n                    ctx.moveTo(x*zoom, y*zoom);\r\n                    ctx.lineTo(x*zoom, (y+1)*zoom);\r\n                }\r\n                if(right){\r\n                    ctx.moveTo((x+1)*zoom, y*zoom);\r\n                    ctx.lineTo((x+1)*zoom, (y+1)*zoom);\r\n                }\r\n                if(bottom){\r\n                    ctx.moveTo((x+1)*zoom, (y+1)*zoom);\r\n                    ctx.lineTo(x*zoom, (y+1)*zoom);\r\n                }\r\n            }\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n\r\n        function isBound(x, y){\r\n            // check is pixel opaque/out of array\r\n\r\n            if(x < 0 || x >= size || y < 0 || y >= size) return true;\r\n\r\n            return !circleMatrix[x][y];\r\n        }\r\n\r\n        this.preRendered.brush.canvas = canvas;\r\n        this.preRendered.brush.ctx = canvas;\r\n        this.preRendered.brush.imageData = canvas;\r\n        this.preRendered.brush.circle = circle;\r\n    }\r\n\r\n    requestRender(){\r\n        if(this.needRender){\r\n            this.needRender = false;\r\n\r\n            this.render()\r\n        }\r\n\r\n        globals.fxRenderer.render();\r\n    }\r\n\r\n    correctSmoothing(){\r\n        if(isMobile) return;\r\n\r\n        if (camera.zoom < 1) {\r\n            this.ctx.imageSmoothingEnabled = true;\r\n            this.ctx.canvas.style.imageRendering = 'auto'\r\n        } else {\r\n            this.ctx.imageSmoothingEnabled = false;\r\n            this.ctx.canvas.style.imageRendering = 'pixelated'\r\n        }\r\n    }\r\n\r\n    render() {\r\n        // smooth when zoom < 1, pixelated otherwise\r\n        this.correctSmoothing();\r\n\r\n        let visibleChunks = getVisibleChunks();\r\n\r\n        // clear veiwport\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        let camX = camera.x + halfMap[0] - ((this.canvas.width >> 1) / camera.zoom);\r\n        let camY = camera.y + halfMap[1] - ((this.canvas.height >> 1) / camera.zoom);\r\n\r\n        let zoom = camera.zoom;\r\n\r\n        if(zoom === 1){\r\n            // for Firefox, to render normally at least on zoom 1\r\n            camX = Math.floor(camX)\r\n            camY = Math.floor(camY)\r\n        }\r\n\r\n        this.ctx.save();\r\n        this.ctx.translate(Math.floor(-camX*zoom), Math.floor(-camY*zoom));\r\n        this.ctx.scale(zoom, zoom);\r\n\r\n        visibleChunks.forEach(chunkCord => {\r\n            let [cx, cy] = chunkCord;\r\n\r\n            let offX = cx * chunkSize;\r\n            let offY = cy * chunkSize;\r\n\r\n\r\n            if (!globals.chunkManager.hasChunk(cx, cy)){\r\n                globals.chunkManager.loadChunk(cx, cy);\r\n\r\n                // search for chunk preview placeholder\r\n                let chunkPreview = this.chunkPreviews[`${cx}-${cy}`];\r\n                if(!chunkPreview){\r\n                    // create one if not found (one-time op)\r\n                    chunkPreview = this.chunkPreviews[`${cx}-${cy}`] = {\r\n                        loaded: false,\r\n                        data: null\r\n                    };\r\n                    new TempChunkPlaceholder(cx, cy).load().then(imgData => {\r\n                        chunkPreview.data = imgData;\r\n                        chunkPreview.loaded = true;\r\n                        this.needRender = true;\r\n                    });\r\n                }else if (chunkPreview.loaded && chunkPreview.data !== null){\r\n                    // or, render it if it's loaded and found in db\r\n                    this.ctx.drawImage(chunkPreview.data, offX, offY, chunkSize, chunkSize);\r\n\r\n                    // also render default placeholder over it, to clarify we are dealing with preview\r\n                    if(this.chunkPlaceholderPattern.loaded){\r\n                        this.ctx.globalAlpha = 0.5;\r\n                        this.ctx.drawImage(this.chunkPlaceholderPattern.canvas, offX, offY, chunkSize, chunkSize);\r\n                        this.ctx.globalAlpha = 1;\r\n                    }\r\n                }else {\r\n\r\n                    // fallback to default placeholder if available\r\n                    if(this.chunkPlaceholderPattern.loaded)\r\n                        this.ctx.drawImage(this.chunkPlaceholderPattern.canvas, offX, offY, chunkSize, chunkSize);\r\n                }\r\n\r\n                return\r\n            }\r\n            \r\n            const chunk = globals.chunkManager.getChunk(cx, cy);\r\n\r\n            chunk.render();\r\n            this.ctx.drawImage(chunk.ctx.canvas, offX, offY);\r\n        });\r\n\r\n        this.ctx.restore();\r\n\r\n        template.render()\r\n    }\r\n}","import EventEmitter from 'events';\r\nimport pako from 'pako'\r\n\r\nimport {\r\n    OPCODES,\r\n    STRING_OPCODES,\r\n    unpackPixel,\r\n    packPixel\r\n} from './protocol';\r\nimport {\r\n    canvasId,\r\n    canvasName\r\n} from './config'\r\nimport globals from './globals'\r\nimport User from './user';\r\nimport chat from './chat';\r\nimport { captchaModal } from './windows';\r\nimport Window from './Window';\r\nimport player from './player';\r\nimport { updatePlaced } from './actions';\r\nimport { translate } from './translate';\r\n\r\nexport default class Socket extends EventEmitter {\r\n    constructor(port) {\r\n        super();\r\n\r\n        const scheme = location.protocol.startsWith('https') ? 'wss' : 'ws';\r\n        const host = location.hostname || 'localhost';\r\n        this.url = `${scheme}://${host}:${port}`;\r\n\r\n        this.pendingPixels = {};\r\n\r\n        this.connectedOnce = false;\r\n\r\n        this.connect();\r\n    }\r\n\r\n    get connected() {\r\n        return this.socket && this.socket.readyState === WebSocket.OPEN\r\n    }\r\n\r\n    connect() {\r\n        this.socket = new WebSocket(this.url);\r\n        this.socket.binaryType = 'arraybuffer';\r\n\r\n        this.socket.onopen = () => {\r\n            this.sendChatSubscribe('global', this.connectedOnce);\r\n            this.sendChatSubscribe(canvasName, this.connectedOnce);\r\n            this.sendCanvas(canvasId);\r\n\r\n            this.emit('opened');\r\n            console.log('Socket has been connected');\r\n\r\n            if(!this.connectedOnce) this.connectedOnce = true;\r\n        }\r\n\r\n        this.socket.onmessage = this.onmessage.bind(this);\r\n\r\n        this.socket.onclose = () => {\r\n            this.emit('closed');\r\n            Object.values(globals.users).forEach(u => u.close(u.id));\r\n            globals.users = {};\r\n\r\n            globals.chunkManager.clearLoadingChunks();\r\n\r\n            setTimeout(() => {\r\n                console.log('reconnect');\r\n                this.reconnect();\r\n            }, Math.random()*1000);\r\n        }\r\n    }\r\n\r\n    close(){\r\n        this.socket.close();\r\n    }\r\n\r\n    reconnect() {\r\n        this.socket.onmessage = null;\r\n        this.socket.onopen = null;\r\n        this.socket.onclose = null;\r\n\r\n        this.connect();\r\n    }\r\n\r\n    onmessage({\r\n        data: message\r\n    }) {\r\n        if (typeof message === 'string') {\r\n            this.onStringMessage(message);\r\n        } else {\r\n            // must be ping\r\n            if (!message.byteLength) return;\r\n\r\n            this.onBinaryMessage(message);\r\n        }\r\n    }\r\n\r\n    onStringMessage(msg) {\r\n        let decoded;\r\n        try {\r\n            decoded = JSON.parse(msg);\r\n        } catch (e) {\r\n            console.log('onStringMessage message decoding error: ' + e, 'message: ' + msg);\r\n            return\r\n        }\r\n\r\n        switch (decoded.c) {\r\n            case STRING_OPCODES.userJoin: {\r\n                const {\r\n                    nick: name,\r\n                    userId,\r\n                    id,\r\n                    registered,\r\n                    role,\r\n                    badges\r\n                } = decoded;\r\n\r\n                const badgesParsed = badges?.split('|').filter(x => x.length).map(x => +x);\r\n\r\n                let sameUser;\r\n                if(name){\r\n                    sameUser = Object.values(globals.users).find(u => u.name === name);\r\n                }\r\n\r\n                if(sameUser){\r\n                    globals.users[id] = sameUser;\r\n                    sameUser.newConnection(id);\r\n                }else{\r\n                    globals.users[id] = new User(name, id, userId, registered, role, badgesParsed);\r\n                }\r\n\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.userLeave: {\r\n                const id = decoded.id;\r\n\r\n                if (globals.users[id]) globals.users[id].close(id);\r\n\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.error: {\r\n                decoded.errors.forEach(error => {\r\n                    if(error === 'error.captcha'){\r\n                        if(!Window.Exists('Captcha'))\r\n                            captchaModal();\r\n                    }\r\n                    toastr.error(error, translate('Error from the Socket:'), {\r\n                        preventDuplicates: true\r\n                    });\r\n                });\r\n\r\n                break;\r\n            }\r\n\r\n            case STRING_OPCODES.chatMessage: {\r\n                chat.addMessage(decoded)\r\n\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.alert: {\r\n                // todo нормальный попап\r\n                toastr.info(decoded.msg, 'ALERT', {\r\n                    timeOut: 1000*60*5,\r\n                    extendedTimeOut: 1000*60*5\r\n                })\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.me: {\r\n                player.id = decoded.id;\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.reload: {\r\n                location.reload();\r\n                break\r\n            }\r\n\r\n            case STRING_OPCODES.reloadChunks: {\r\n                globals.chunkManager.reloadChunks();\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    onBinaryMessage(msg) {\r\n        const dv = new DataView(msg);\r\n\r\n        switch (dv.getUint8(0)) {\r\n            case OPCODES.captcha: {\r\n                captchaModal();\r\n                break\r\n            }\r\n            case OPCODES.chunk: {\r\n                const cx = dv.getUint8(1);\r\n                const cy = dv.getUint8(2);\r\n\r\n                const chunkData = pako.inflate(dv.buffer.slice(3));\r\n\r\n                this.emit('chunk', cx, cy, chunkData);\r\n\r\n                break\r\n            }\r\n\r\n            case OPCODES.place: {\r\n                const x = dv.getUint16(1);\r\n                const y = dv.getUint16(3);\r\n                const col = dv.getUint8(5);\r\n\r\n                const id = dv.getUint32(5);\r\n\r\n                this.onIncomingPixel([x, y, col], id);\r\n                break\r\n            }\r\n\r\n            case OPCODES.online: {\r\n                const count = dv.getUint16(1);\r\n\r\n                this.emit('online', count);\r\n                break\r\n            }\r\n\r\n            case OPCODES.pixels: {\r\n                const isProtect = !!dv.getUint8(1),\r\n                    uid = dv.getUint32(2, false);\r\n                let x, y, col;\r\n                for(let i = 6; i < dv.byteLength; i+=5){\r\n                    x = dv.getUint16(i);\r\n                    y = dv.getUint16(i+2);\r\n                    col = dv.getUint8(i+4);\r\n                    if(isProtect){\r\n                        this.emit('protect', x, y, col);\r\n                    }else{\r\n                        this.emit('place', x, y, col, uid);\r\n                    }\r\n                }\r\n\r\n                const user = globals.users[uid];\r\n                if(user) user.updateCoords(col, x, y);\r\n                \r\n                break\r\n            }\r\n\r\n            case OPCODES.ping: {\r\n                this.socket.send(new Uint8Array([OPCODES.ping]));\r\n                break\r\n            }\r\n\r\n            case OPCODES.placeBatch: {\r\n                const PIXEL_LENGTH = 9;\r\n\r\n                const totalPixels = (dv.byteLength-1) / PIXEL_LENGTH;\r\n                if(totalPixels % 1 !== 0){\r\n                    console.warn('TotalPixels length is not integer');\r\n                }\r\n\r\n                for(let off = 1; off < dv.byteLength; off += PIXEL_LENGTH){\r\n                    const x = dv.getUint16(off);\r\n                    const y = dv.getUint16(off+2);\r\n                    const c = dv.getUint8(off+4);\r\n                    const placerId = dv.getUint32(off+5);\r\n\r\n                    this.onIncomingPixel([x, y, c], placerId);\r\n                }\r\n                break\r\n            }\r\n\r\n            case OPCODES.updateRadio: {\r\n                const type = dv.getUint8(1);\r\n                this.emit('radio', type);\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    onIncomingPixel([x, y, col], id){\r\n        const user = globals.users[id];\r\n        if(user) user.updateCoords(col, x, y);\r\n\r\n        const key = x + ',' + y;\r\n        let timeout = this.pendingPixels[key];\r\n        if(timeout){\r\n            clearTimeout(timeout);\r\n            delete this.pendingPixels[key];\r\n        }\r\n\r\n        this.emit('place', x, y, col, id);\r\n\r\n        // does not work, id is not player id\r\n        if(id === player.id)\r\n            updatePlaced(player.placedCount++);\r\n    }\r\n\r\n    requestChunk(x, y) {\r\n        let dv = new DataView(new ArrayBuffer(1 + 1 + 1));\r\n        dv.setUint8(0, OPCODES.chunk);\r\n        dv.setUint8(1, x);\r\n        dv.setUint8(2, y);\r\n\r\n        this.socket.send(dv.buffer)\r\n    }\r\n\r\n    sendPixel(x, y, c) {\r\n        let dv = new DataView(new ArrayBuffer(1 + 5))\r\n\r\n        dv.setUint8(0, OPCODES.place);\r\n        dv.setUint16(1, x);\r\n        dv.setUint16(3, y);\r\n        dv.setUint8(5, c);\r\n\r\n        this.socket.send(dv.buffer);\r\n    }\r\n\r\n    sendPixels(pixels, isProtect=false) {\r\n        let dv = new DataView(new ArrayBuffer(6 + pixels.length*5))\r\n\r\n        dv.setUint8(0, OPCODES.pixels);\r\n        dv.setUint8(1, isProtect ? 1 : 0); // isProtect\r\n        for(let i = 0; i < pixels.length; i++){\r\n            let offset = i*5 + 6;\r\n            const [x, y, col] = pixels[i];\r\n\r\n            dv.setUint16(offset, x);\r\n            dv.setUint16(offset+2, y);\r\n            dv.setUint8(offset+4, col);\r\n        }\r\n\r\n        this.socket.send(dv.buffer)\r\n    }\r\n\r\n    sendCanvas(id) {\r\n        const dv = new DataView(new ArrayBuffer(2));\r\n        dv.setUint8(0, OPCODES.canvas);\r\n        dv.setUint8(1, id);\r\n\r\n        this.socket.send(dv.buffer);\r\n    }\r\n\r\n    sendChatSubscribe(channel, isReconnect){\r\n        const packet = {\r\n            c: STRING_OPCODES.subscribeChat,\r\n            ch: channel,\r\n            reconnect: isReconnect\r\n        }\r\n\r\n        this.socket.send(JSON.stringify(packet));\r\n    }\r\n\r\n    sendChatMessage(text, channel, whisper=false) {\r\n        const packet = {\r\n            c: STRING_OPCODES.chatMessage,\r\n            msg: text,\r\n            ch: channel\r\n        }\r\n\r\n        if(whisper) packet.whisper = whisper;\r\n\r\n        this.socket.send(JSON.stringify(packet));\r\n    }\r\n\r\n    sendChatWhisper(text, channel, whisperId){\r\n        return this.sendChatMessage(text, channel, whisperId);\r\n    }\r\n\r\n    sendAlert(to, text){\r\n        const packet = {\r\n            c: STRING_OPCODES.alert,\r\n            to,\r\n            msg: text\r\n        }\r\n\r\n        this.socket.send(JSON.stringify(packet));\r\n    }\r\n}","// this class is for loading/getting saved chunk placeholder,\r\n// based on the previous loaded chunk image\r\n\r\nimport { canvasId, chunkSize } from './config.js';\r\nimport * as idxDb from './indexedDb.js'\r\nimport { resizeCanvas } from './utils/misc';\r\n\r\nexport default class TempChunkPlaceholder {\r\n    constructor(chunkX, chunkY) {\r\n        this.x = chunkX;\r\n        this.y = chunkY;\r\n    }\r\n\r\n    // load from localStorage\r\n    async load() {\r\n        return new Promise((res, rej) => {\r\n            const dbKey = `${canvasId}-${this.x}-${this.y}`;\r\n            idxDb.addInitCallback(async () => {\r\n                try {\r\n                    const chunkData = await this._loadFromDb(dbKey);\r\n                    const chunkCanvas = this._fromData(chunkData);\r\n\r\n                    res(chunkCanvas);\r\n                } catch (error) {\r\n                    rej(error);\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    async _loadFromDb(dbKey) {\r\n        return new Promise((res, rej) => {\r\n            let transaction = idxDb.database.transaction(\"chunkPlaceholders\", \"readonly\");\r\n\r\n            let request = transaction.objectStore(\"chunkPlaceholders\").get(dbKey);\r\n    \r\n            request.onsuccess = function () {\r\n                const chunk = request.result;\r\n\r\n                if(chunk === undefined) return res(null);\r\n                return res(chunk);\r\n            };\r\n    \r\n            request.onerror = function (event) {\r\n                rej(request.error);\r\n            };\r\n    \r\n            transaction.onabort = function () {\r\n                rej(request.error);\r\n            };\r\n        })\r\n    }\r\n\r\n    _fromData(savedChunk){\r\n        const canvas = document.createElement('canvas');\r\n\r\n        canvas.width = savedChunk.width;\r\n        canvas.height = savedChunk.height;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        const imageData = ctx.createImageData(canvas.width, canvas.height);\r\n        imageData.data.set(savedChunk.data);\r\n\r\n        ctx.putImageData(imageData, 0, 0);\r\n\r\n        return resizeCanvas(canvas, chunkSize, chunkSize);\r\n    }\r\n\r\n    async save(chunkCanvas){\r\n        return new Promise((res, rej) => {\r\n            const dbKey = `${canvasId}-${this.x}-${this.y}`;\r\n            idxDb.addInitCallback(async () => {\r\n                try {\r\n                    await this._saveToDb(dbKey, chunkCanvas);\r\n\r\n                    res();\r\n                } catch (error) {\r\n                    rej(error);\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    async _saveToDb(dbKey, chunkCanvas){\r\n        return new Promise((res, rej) => {\r\n            // 50x50 is hardcoded size for all previews\r\n            const resizedChunkCanvas = resizeCanvas(chunkCanvas, 50, 50);\r\n            const resizedImgData = resizedChunkCanvas.getContext('2d').getImageData(0, 0, 50, 50);\r\n\r\n            let transaction = idxDb.database.transaction(\"chunkPlaceholders\", \"readwrite\");\r\n\r\n            let request = transaction.objectStore(\"chunkPlaceholders\").put({\r\n                'chunk_key': dbKey,\r\n\r\n                width: resizedImgData.width,\r\n                height: resizedImgData.height,\r\n                data: resizedImgData.data,\r\n            });\r\n    \r\n            request.onsuccess = function () {\r\n                res();\r\n            };\r\n    \r\n            request.onerror = function (event) {\r\n                rej(request.error);\r\n            };\r\n    \r\n            transaction.onabort = function () {\r\n                rej(request.error);\r\n            };\r\n        })\r\n    }\r\n}","import EventEmitter from 'events'\r\nimport { ROLE } from './constants';\r\n\r\nexport default class Tool extends EventEmitter{\r\n    constructor(name, defaultKey=null, iconURL=null, minRole=ROLE.GUEST){\r\n        super();\r\n\r\n        this.name = name;\r\n        this.icon = iconURL;\r\n\r\n        this.key = defaultKey ? defaultKey.toString() : undefined;\r\n\r\n        this.requiredRole = minRole;\r\n    }\r\n}","import EventEmitter from 'events';\r\nimport globals from './globals';\r\nimport tools from './tools';\r\nimport camera from './camera';\r\nimport player from './player';\r\nimport {\r\n    screenToBoardSpace\r\n} from './utils/conversions';\r\nimport {\r\n    insanelyLongMobileBrowserCheck,\r\n    stringifyKeyEvent,\r\n    decodeKey\r\n} from './utils/misc';\r\nimport { getLS, setLS } from './utils/localStorage';\r\nimport me from './me';\r\n\r\nconst coords = globals.elements.coords;\r\n\r\nfunction updatePlayerCoords(clientX, clientY) {\r\n    let [newX, newY] = screenToBoardSpace(clientX, clientY);\r\n\r\n    if (newX === player.x && newY === player.y) {\r\n        return\r\n    }\r\n\r\n    player.x = newX;\r\n    player.y = newY;\r\n\r\n    coords.innerText = `(${player.x}, ${player.y})`\r\n\r\n    if (player.color != -1 && camera.zoom > 1)\r\n        globals.renderer.needRender = true;\r\n}\r\n\r\nconst isMobile = insanelyLongMobileBrowserCheck();\r\n\r\nexport default class ToolManager extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n\r\n        this.tools = tools;\r\n        this.tool = tools.mover;\r\n\r\n        this._keyBinds = {};\r\n        this._colorBinds = {};\r\n        this.activeTools = {};\r\n\r\n        this.addTools();\r\n        this.loadBinds();\r\n        this.initEvents();\r\n\r\n        this.ctrlDown = false;\r\n        this.altDown = false;\r\n\r\n        me.callOnLoaded(this.filterTools.bind(this));\r\n    }\r\n\r\n    filterTools() {\r\n        Object.keys(this.tools).forEach(name => {\r\n            if (this.tools[name].requiredRole > me.role) {\r\n                delete this._keyBinds[this.tools[name].key];\r\n\r\n                if (isMobile) {\r\n                    $(`#tool_${name}`).remove();\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    addTools() {\r\n        const toolsEl = document.getElementById('tools');\r\n\r\n        Object.keys(this.tools).forEach(name => {\r\n            const tool = this.tools[name];\r\n\r\n            if (isMobile) {\r\n                if (!tool.icon) return;\r\n\r\n                let el = document.createElement('div');\r\n                el.classList = 'toolContainer';\r\n                el.id = `tool_${name}`;\r\n                let img = document.createElement('img');\r\n                img.className = 'toolIcon';\r\n                img.src = tool.icon;\r\n\r\n                el.appendChild(img);\r\n                toolsEl.appendChild(el); // todo add click choosing etc\r\n\r\n                el.addEventListener('pointerdown', choose.bind(this));\r\n\r\n                function choose() {\r\n                    let oldTool = document.getElementsByClassName('toolContainer selected')[0]\r\n                    if (oldTool)\r\n                        oldTool.className = 'toolContainer';\r\n\r\n                    el.classList = ['toolContainer selected'];\r\n                    this.tool = tool;\r\n                }\r\n                if (tool.name === 'mover')\r\n                    choose.apply(this);\r\n            } else {\r\n                if (player)\r\n                    this._keyBinds[tool.key] = tool;\r\n            }\r\n        })\r\n    }\r\n\r\n    initEvents() {\r\n        let em = globals.eventManager;\r\n\r\n        if (isMobile) {\r\n            em.on('zoom', zoom => {\r\n                camera.zoom *= zoom + 1;\r\n                camera.checkZoom();\r\n                globals.renderer.needRender = true;\r\n                globals.fxRenderer.needRender = true;\r\n            });\r\n\r\n            em.on('mousedown', e => {\r\n                updatePlayerCoords(e.clientX, e.clientY);\r\n            });\r\n\r\n            em.on('mousemove', e => {\r\n                updatePlayerCoords(e.clientX, e.clientY);\r\n            });\r\n\r\n            let events = [\r\n                ['mousedown', 'down'],\r\n                ['mousemove', 'move'],\r\n                ['mouseup', 'up']\r\n            ];\r\n\r\n            events.forEach(event => {\r\n                const [realEvent, myEvent] = event;\r\n                em.on(realEvent, e => {\r\n                    let tool = this.tool;\r\n                    if (e && e.gesture) {\r\n                        this.tool.emit('_gesture');\r\n                        tool = this.tools.mover;\r\n                    }\r\n                    if (!tool) return\r\n\r\n                    // emit to selected tool\r\n                    tool.emit(myEvent, e);\r\n                    // emit to other subscribers\r\n                    this.emit(myEvent, e);\r\n                });\r\n            });\r\n        } else {\r\n            // TODO все слушатели напрямую к eventManager\r\n            em.on('mousedown', e => {\r\n                this.tools.mover.emit('down', e)\r\n            });\r\n            em.on('mouseup', e => {\r\n                if (e.button === 2) {\r\n                    player.switchColor(-1);\r\n                    player.switchSecondColor(-1);\r\n                }\r\n                this.tools.mover.emit('up', e);\r\n            });\r\n            em.on('mousemove', e => {\r\n                if (e.buttons === 0 || camera.noMoving) {\r\n                    updatePlayerCoords(e.clientX, e.clientY);\r\n                }\r\n\r\n                this.tool.emit('move', e)\r\n                this.emit('move', e);\r\n            });\r\n\r\n            em.on('keydown', e => {\r\n                let str = stringifyKeyEvent(e);\r\n                if (!str) return;\r\n\r\n                const tool = this._keyBinds[str];\r\n\r\n                if (tool) {\r\n                    // TODO\r\n                    this.tool = tool; // костыль, переделать\r\n                    // Как? подписываться на mousemove при down\r\n                    // и отписываться при up\r\n                    tool.emit('down', e);\r\n                }\r\n            });\r\n\r\n            em.on('keyup', e => {\r\n                let str = stringifyKeyEvent(e);\r\n                if (!str) return;\r\n\r\n                const tool = this._keyBinds[str];\r\n\r\n                for (let name of Object.keys(this.tools)) {\r\n                    const tool2 = this.tools[name];\r\n\r\n                    if (!tool2.key || tool2 === tool)\r\n                        continue;\r\n\r\n                    const key = decodeKey(tool2.key);\r\n                    if (key.code === e.code) {\r\n                        tool2.emit('up', e)\r\n                    }\r\n                }\r\n\r\n                if (tool) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n\r\n                    tool.emit('up', e);\r\n                }\r\n            });\r\n\r\n            em.on('wheel', e => {\r\n                const oldZoom = camera.zoom;\r\n                camera.zoomTo(e.deltaY);\r\n\r\n                const dx = e.clientX - window.innerWidth / 2;\r\n                const dy = e.clientY - window.innerHeight / 2;\r\n\r\n                camera.moveTo((dx / oldZoom), (dy / oldZoom));\r\n                camera.moveTo(-(dx / camera.zoom), -(dy / camera.zoom));\r\n\r\n                if(localStorage.getItem('iHaveProblems') === 'yes'){\r\n                    camera.x = Math.round(camera.x); camera.y = Math.round(camera.y);\r\n                    globals.renderer.needRender = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        function specKeysHandlers(e){\r\n            this.ctrlDown = e.ctrlKey;\r\n            this.altDown = e.altKey;\r\n        }\r\n\r\n        em.on('keydown', specKeysHandlers.bind(this));\r\n        em.on('keyup', specKeysHandlers.bind(this));\r\n\r\n        // TODO: add listener directly to ToolManager, istead of tool itself, avoiding cyclic check\r\n        em.on('tick', e => {\r\n            Object.keys(this.tools).forEach(name => {\r\n                const tool = this.tools[name];\r\n                if (tool.listenerCount('tick') > 0) {\r\n                    tool.emit('tick', e);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    changeKey(tool, key) {\r\n        const oldKey = tool.key;\r\n        delete this._keyBinds[oldKey];\r\n\r\n        tool.key = key;\r\n        this._keyBinds[key] = tool\r\n    }\r\n\r\n    loadBinds() {\r\n        const str = getLS('keyBinds');\r\n        let newBinds;\r\n        try {\r\n            newBinds = JSON.parse(str);\r\n            if (!newBinds)\r\n                return;\r\n        } catch {\r\n            toastr.error('Error on parsing key binds from local storage');\r\n            localStorage.removeItem('keyBinds');\r\n            return\r\n        }\r\n\r\n        let toolname;\r\n        for (let key of Object.keys(newBinds)) {\r\n            if (toolname = this.findByName(key))\r\n                this.changeKey(this.tools[toolname], newBinds[key]);\r\n        }\r\n    }\r\n\r\n    findByName(name) {\r\n        const keys = Object.keys(this.tools);\r\n        return keys.find(key => this.tools[key].name === name)\r\n    }\r\n\r\n    initColorBinds(){\r\n\r\n    }\r\n\r\n    loadColorBinds(){\r\n\r\n    }\r\n}","// copied from template 3.0\r\n// copyright GOROX\r\n\r\nimport jQuery from 'jquery';\r\nimport trashSVG from '../img/trash2.svg'\r\nimport closeSVG from '../img/cross.svg'\r\n\r\nconst deleteEl = document.createElement('div'); // элемент для удаления окон\r\ndeleteEl.style.cssText =\r\n    `\r\n    width: 80px;\r\n    height: 80px;\r\n    line-height: 80px;\r\n    text-align: center;\r\n    border: solid 2px white;\r\n    border-radius: 50%;\r\n    opacity: .5;\r\n    position: absolute;\r\n    z-index: 8;\r\n    bottom: 10px;\r\n    right: 10px;\r\n    background-color: red;\r\n    color: white;\r\n    font-size: 68px;\r\n    padding-left: 3px; /* костыль из-за кривой иконки мусорки */\r\n    display: none;\r\n    user-select: none;\r\n    transition: all .2s ease;\r\n    background-image: url(${trashSVG});\r\n`;\r\n\r\nlet deleteRange = document.createElement('div');\r\ndeleteRange.style.cssText =\r\n    `\r\n    opacity: .1;\r\n    width: 300px;\r\n    height: 300px;\r\n    position: absolute;\r\n    border-radius: 50%;\r\n    z-index: 7;\r\n    bottom: -100px;\r\n    right: -100px;\r\n    background-color: red;\r\n    display: none;\r\n`\r\n\r\ndeleteEl.onpointerenter = deleteRange.onpointerenter = () => {\r\n    deleteEl.style.opacity = '1';\r\n};\r\n\r\ndeleteEl.onpointerleave = deleteRange.onpointerleave = () => {\r\n    deleteEl.style.opacity = '.5';\r\n};\r\n\r\n// disabled due new way to close\r\n// document.body.appendChild(deleteEl);\r\n// document.body.appendChild(deleteRange);\r\n\r\nlet windows = [];\r\nwindow.windows = windows;\r\n\r\nexport default class Window {\r\n    static Exists(title){\r\n        return windows.some(x => x.title === title)\r\n    }\r\n    static Find(title){\r\n        return windows.find(x => x.title === title)\r\n    }\r\n    constructor(config) {\r\n        // all values also will be loaded from config few lines below\r\n\r\n        // title can be passed instead of config\r\n        if(typeof config == 'string')\r\n            config = {title:config}\r\n\r\n        this.created = false;\r\n\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        this.title = \"\";\r\n\r\n        this.parent = document.body;\r\n\r\n        // do not set to false if closeable\r\n        this.moveable = true;\r\n        this.closeable = true;\r\n        this.closed = false;\r\n\r\n        this.center = false;\r\n\r\n        // here\r\n        Object.assign(this, config);\r\n\r\n        if (Window.Exists(this.title)) {\r\n            this.oldWindow = Window.Find(this.title);\r\n            return\r\n        }\r\n\r\n        this.created = true;\r\n\r\n        if(!this.block){ // for static windows like chat\r\n            this.block = this.createParentBlock();\r\n            this.moveTo(this.x, this.y); // user defined coordinates\r\n            this.parent.appendChild(this.block);\r\n        }\r\n\r\n        if (this.center) {\r\n            this.moveToCenter();\r\n            // костыль: центрирует неправильно до рендера\r\n            setTimeout(() => this.moveToCenter());\r\n        }\r\n\r\n        this.addFeatures();\r\n\r\n        windows.push(this);\r\n    }\r\n\r\n    updateTitle(newTitle, temp=false){\r\n        if(!temp){\r\n            this.title = newTitle;\r\n        }\r\n        const head = $('.windowTitle', this.element);\r\n\r\n        // this makes \".innerHtml = ...\" of method below purposeless\r\n        // since html is not saved here\r\n        head.text(newTitle);\r\n    }\r\n\r\n    createParentBlock() {\r\n        let el = document.createElement('div');\r\n        el.className = 'window';\r\n        this.element = el;\r\n\r\n        let head = document.createElement('div');\r\n        head.className = 'windowHeader'\r\n        head.innerHTML = '<h3 class=\"windowTitle\">' + this.title + '</h3>';\r\n        el.appendChild(head);\r\n\r\n        if(this.closeable){\r\n            const closer = document.createElement('div');\r\n            closer.className = 'closeWindow';\r\n            closer.innerHTML = '<div></div>';\r\n\r\n            closer.addEventListener('pointerdown', event => {\r\n                // prevent window moving\r\n                event.stopPropagation();\r\n            });\r\n            closer.addEventListener('click', this.close.bind(this));\r\n            head.appendChild(closer);\r\n        }\r\n\r\n        let body = document.createElement('div');\r\n        body.className = 'windowBody';\r\n        el.appendChild(body);\r\n        this.body = body;\r\n\r\n        return el\r\n    }\r\n\r\n    moveTo(x, y) {\r\n        const rect = this.block.getBoundingClientRect();\r\n        const w = rect.width,\r\n            h = rect.height;\r\n\r\n        this.x = Math.max(-w+10, x);\r\n        this.y = Math.max(-h+10, y);\r\n\r\n        this.x = Math.min(window.innerWidth-10, this.x);\r\n        this.y = Math.min(window.innerHeight-10, this.y);\r\n\r\n        this.block.style.left = this.x + 'px';\r\n        this.block.style.top = this.y + 'px';\r\n    }\r\n\r\n    moveBy(x, y) {\r\n        this.moveTo(this.x + x, this.y + y);\r\n    }\r\n\r\n    moveToCenter() {\r\n        let windowWidth = window.innerWidth,\r\n            windowHeight = window.innerHeight;\r\n\r\n        let blockWidth = this.block.offsetWidth,\r\n            blockHeight = this.block.offsetHeight;\r\n\r\n        this.moveTo(\r\n            windowWidth / 2 - blockWidth / 2,\r\n            windowHeight / 2 - blockHeight / 2\r\n        );\r\n    }\r\n\r\n    addFeatures() {\r\n        if (this.moveable) {\r\n            const ratio = window.devicePixelRatio||1;\r\n\r\n            $(this.block).on('pointerdown', () => {\r\n                let self = this;\r\n\r\n                jQuery(document).on('pointermove', moved)\r\n\r\n                function moved(e) {\r\n                    e = e.originalEvent;\r\n\r\n                    let movedX = e.movementX/ratio,\r\n                        movedY = e.movementY/ratio;\r\n\r\n                    self.moveBy(movedX, movedY);\r\n                }\r\n\r\n                if (this.closeable) {\r\n                    deleteEl.style.display = 'block';\r\n                    deleteRange.style.display = 'block';\r\n\r\n                    jQuery([deleteEl, deleteRange]).one('pointerup', () => {\r\n                        this.close();\r\n                    })\r\n                }\r\n\r\n                jQuery(document).one('pointerup pointerleave', () => {\r\n                    deleteEl.style.display = 'none';\r\n                    deleteRange.style.display = 'none';\r\n\r\n                    jQuery([deleteEl, deleteRange]).off('pointerup');\r\n\r\n                    jQuery(document).off('pointermove', moved);\r\n                });\r\n            });\r\n\r\n            $(this.body).on('pointerdown', e => {\r\n                e.stopPropagation();\r\n            })\r\n        }\r\n\r\n        // for window be in screen after\r\n        // screen rotation\r\n        window.addEventListener('orientationchange', () => {\r\n            setTimeout(() => {\r\n                this.moveTo(this.x, this.y);\r\n            }, 500);\r\n        })\r\n    }\r\n\r\n    close() {\r\n        jQuery(this.block).remove();\r\n        this.closed = true;\r\n        windows.splice(windows.indexOf(this), 1);\r\n    }\r\n}\r\n\r\nlet Modal_exists = false;\r\nexport class Modal{\r\n    static get isRunning(){\r\n        return Modal_exists\r\n    }\r\n    static set isRunning(val){\r\n        return Modal_exists=val;\r\n    }\r\n\r\n    constructor(config={}){\r\n        if(Modal.isRunning)\r\n            throw new Error('Modal is running');\r\n\r\n        this.body = null;\r\n\r\n        Object.assign(this, config);\r\n        this.init();\r\n\r\n        Modal.isRunning = true;\r\n    }\r\n\r\n    init(){\r\n        const els = \r\n        $(`<div class=\"modalBg\">\r\n            <div class=\"modalCont\">\r\n            </div>\r\n        </div>`);\r\n\r\n        this.bgEl = els[0];\r\n        this.contEl = this.bgEl.children[0];\r\n\r\n        $('#ui').append(els);\r\n    }\r\n\r\n    close(){\r\n        this.bgEl.remove();\r\n    }\r\n}","import me from './me';\r\nimport {\r\n    canvasName,\r\n    cooldown, downloaded, game, hexPalette, palette\r\n} from './config';\r\nimport player from './player';\r\nimport {\r\n    getLS,\r\n    getOrDefault,\r\n    setLS\r\n} from './utils/localStorage'\r\nimport {\r\n    screenToBoardSpace\r\n} from './utils/conversions'\r\nimport template from './template'\r\nimport globals from './globals';\r\nimport {\r\n    chatInput,\r\n    chat as chatEl,\r\n    ui,\r\n    topMenu,\r\n    urlInput,\r\n    xInput,\r\n    yInput,\r\n    opacInput\r\n} from './elements'\r\nimport {\r\n    accountSettings,\r\n    keyBinds,\r\n    uiSettings,\r\n    gameSettings,\r\n    toolsWindow,\r\n    help,\r\n    authWindow,\r\n    onlineViewWindow\r\n} from './windows'\r\nimport { ROLE, ROLE_I } from './constants'\r\nimport chat from './chat';\r\nimport Window from './Window';\r\nimport { translate as t_ } from './translate';\r\nimport { getPathsafeDate, getRecommendedColorSize } from './utils/misc';\r\nimport { patterns } from './convert/patterns';\r\nimport { isDarkColor } from './utils/color';\r\nimport Chunk from './Chunk';\r\nimport WinampPlayer from './winamp/player';\r\n\r\nexport async function apiRequest(path, config = {}) {\r\n    // handle json body of request\r\n    if (config.body && typeof config.body === 'object') {\r\n        if (!config.headers) config.headers = {};\r\n\r\n        config.headers['Content-Type'] = 'application/json';\r\n        config.body = JSON.stringify(config.body);\r\n    }\r\n    const response = await fetch('/api' + path, config);\r\n\r\n    if (response.headers.get('Content-Type') && response.headers.get('Content-Type').includes('application/json')) {\r\n        try {\r\n            const json = await response.json()\r\n\r\n            if (json.errors) {\r\n                json.errors.forEach(error => {\r\n                    toastr.error(error, undefined, {\r\n                        preventDuplicates: true\r\n                    });\r\n                })\r\n            }\r\n\r\n            response.json = () => json;\r\n        } catch (e) { }\r\n    }\r\n\r\n    return response\r\n}\r\n\r\nexport async function updateMe() {\r\n    await me.load();\r\n\r\n    player.updateBucket(getMyCooldown());\r\n    if (me.registered) {\r\n        chatInput.removeAttr('disabled');\r\n        chatInput.val('');\r\n\r\n        $('#loginButtons,.authBtn').hide();\r\n        $('#chatNick,#chatChannels').show();\r\n        $('#chatNick').text(me.name);\r\n        $('#chatHeader').addClass('logged');\r\n    } else {\r\n        chatInput.attr('disabled');\r\n        chatInput.val(t_('login to chat'));\r\n\r\n        // $('#chatNick').text('CHAT');\r\n        $('#chatNick,#chatChannels').hide();\r\n        $('#loginButtons,.authBtn').show();\r\n        $('#chatHeader').removeClass('logged');\r\n    }\r\n}\r\n\r\nexport function getMyCooldown() {\r\n    const cooldowns = cooldown;\r\n\r\n    if (ROLE_I[me.role] == 'ADMIN') return [0, 32]\r\n    return cooldowns[ROLE_I[me.role]] || cooldown.GUEST;\r\n}\r\n\r\nexport function initInputs() {\r\n    loadValues();\r\n    initHandlers();\r\n    initButtons();\r\n    initChat();\r\n}\r\n\r\nfunction loadValues() {\r\n    const urlVal = getOrDefault('template.url', 'https://i.imgur.com/4GQIMQ7.png', true);\r\n    urlInput.val(urlVal);\r\n\r\n    const xVal = getOrDefault('template.x', 0, true);\r\n    xInput.val(parseInt(xVal, 10));\r\n\r\n    const yVal = getOrDefault('template.y', 0, true);\r\n    yInput.val(parseInt(yVal, 10));\r\n\r\n    const opacVal = getOrDefault('template.opac', 0.5, true);\r\n    opacInput.val(parseFloat(opacVal));\r\n}\r\n\r\nfunction saveTemplate() {\r\n    setLS('template.x', template.x, true);\r\n    setLS('template.y', template.y, true);\r\n    setLS('template.url', template.url, true);\r\n    setLS('template.opac', template.opacity, true);\r\n}\r\n\r\nexport function updateTemplate() {\r\n    template.update();\r\n    template.render();\r\n    saveTemplate();\r\n}\r\n\r\nfunction initHandlers() {\r\n    urlInput.on('input', updateTemplate);\r\n    xInput.on('input', updateTemplate);\r\n    yInput.on('input', updateTemplate);\r\n    opacInput.on('input', updateTemplate);\r\n\r\n    updateTemplate();\r\n}\r\n\r\nfunction initTemplateMoveByMouse() {\r\n    $(document).on('mousedown', e => {\r\n        if (!e.ctrlKey) return;\r\n\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n\r\n        let lastCord = screenToBoardSpace(e.clientX, e.clientY).map(x => x |= 0);\r\n\r\n        function mousemove(e) {\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n\r\n            const boardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n            boardPos[0] |= 0;\r\n            boardPos[1] |= 0;\r\n\r\n            let [lastX, lastY] = boardPos;\r\n\r\n            if (lastX === lastCord[0] && lastY === lastCord[1])\r\n                return;\r\n\r\n            // console.log(lastX, lastY, boardPos, lastCord)\r\n\r\n            xInput.val(template.x -= lastCord[0] - lastX);\r\n            yInput.val(template.y -= lastCord[1] - lastY);\r\n\r\n            template.render();\r\n\r\n            lastCord = boardPos;\r\n\r\n            saveTemplate();\r\n        }\r\n        $(document).on('mousemove', mousemove);\r\n        $(document).one('mouseup mouseleave', () => {\r\n            $(document).off('mousemove', mousemove);\r\n        })\r\n    })\r\n}\r\n\r\nfunction initButtons() {\r\n    $('#accountSettings').on('click', accountSettings);\r\n    $('#toolBinds').on('click', keyBinds);\r\n    $('#uiSettings').on('click', uiSettings);\r\n    $('#canvasSettings').on('click', gameSettings);\r\n    $('#toolsB').on('click', toolsWindow);\r\n    $('.authBtn').on('click', authWindow);\r\n}\r\n\r\nfunction initChat() {\r\n    $(document).on('keydown', e => {\r\n        if (e.key !== 'Enter') return;\r\n\r\n        if ($('#chatInput').is(':focus') || globals.mobile) {\r\n            // send if focused\r\n            const message = chatInput.val();\r\n            if (!message.length)\r\n                return chatInput.trigger('blur');\r\n\r\n            chatInput.val('');\r\n\r\n            chat.handleMessage(message);\r\n        } else {\r\n            // or focus if not\r\n            $('#chatInput').trigger('focus');\r\n        }\r\n    });\r\n\r\n    $('#chatChannels>div').on('click', (e) => {\r\n        const ch = e.target.dataset.channel;\r\n        chat.switchChannel(ch);\r\n        setLS('chatChannel', ch);\r\n    });\r\n\r\n    resolveWhenConfigDownloaded().then(() => {\r\n        chat.loadChannelElements();\r\n        chat.switchChannel(getLS('chatChannel') || 'global');\r\n    })\r\n\r\n    initChatHeightWorkaround();\r\n}\r\n\r\nasync function resolveWhenConfigDownloaded(){\r\n    if(downloaded){\r\n        return;\r\n    }else{\r\n        return new Promise(res => {\r\n            const int = setInterval(() => {\r\n                if(downloaded){\r\n                    clearInterval(int);\r\n                    res();\r\n                }\r\n            }, 10);\r\n        })\r\n    }\r\n}\r\n\r\nexport function placePixels(pixels, store = true) {\r\n    // does not checks pixels\r\n\r\n    if (store) {\r\n        pixels.forEach(([x, y]) => {\r\n            player.placed.push([x, y, globals.chunkManager.getChunkPixel(x, y)]);\r\n        })\r\n    }\r\n    globals.socket.sendPixels(pixels, false);\r\n}\r\n\r\nexport function placePixel(x, y, col, store = true) {\r\n    const oldCol = globals.chunkManager.getChunkPixel(x, y),\r\n        isProtected = globals.chunkManager.getProtect(x, y);\r\n\r\n    if (oldCol !== col && (!isProtected || me.role >= ROLE.MOD) && globals.socket.connected) {\r\n        if (store) {\r\n            player.placed.push([x, y, globals.chunkManager.getChunkPixel(x, y)]);\r\n\r\n            if (player.placed.length > player.maxPlaced * 2) {\r\n                player.placed = player.placed.slice(-player.maxPlaced);\r\n            }\r\n        }\r\n\r\n        globals.chunkManager.setChunkPixel(x, y, col);\r\n        globals.socket.sendPixel(x, y, col);\r\n\r\n        globals.socket.pendingPixels[x + ',' + y] = setTimeout(() => {\r\n            globals.chunkManager.setChunkPixel(x, y, oldCol);\r\n            globals.renderer.needRender = true;\r\n        }, 3000)\r\n    } else {\r\n        if (isProtected && me.role < ROLE.MOD) {\r\n            toastr.error(t_('This pixel is protected.'), t_('Error!'), {\r\n                preventDuplicates: true,\r\n                timeOut: 750\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nexport function toggleChat() {\r\n    if (chatEl.css('display') === 'none') {\r\n        chatEl.show();\r\n        chatEl.css('left', '');\r\n    } else {\r\n        chatEl.css('left', -chatEl.width() - 30);\r\n        setTimeout(() => chatEl.hide(), 500);\r\n    }\r\n}\r\n\r\nexport function toggleTopMenu() {\r\n    if (topMenu.css('display') === 'none') {\r\n        topMenu.show();\r\n        topMenu.css('margin-top', '');\r\n    } else {\r\n        topMenu.css('margin-top', -topMenu.height() - 30);\r\n        setTimeout(() => topMenu.hide(), 500);\r\n    }\r\n}\r\n\r\nexport function toggleEverything() {\r\n    // $('#ui>div>div').each((_, el) => {\r\n    //     if(el.style.getPropertyPriority('display') == 'important')\r\n    //         return;\r\n\r\n    //     if (el.style.display === 'none') {\r\n    //         $(el).css('display', '')\r\n    //     } else {\r\n    //         $(el).css('display', 'none')\r\n    //     }\r\n    // })\r\n    $('#ui').fadeToggle(100);\r\n    fixChatPosition();\r\n}\r\n\r\nexport function showProtected(show = true) {\r\n    game.showProtected = show;\r\n    globals.chunkManager.chunks.forEach(chunk => {\r\n        chunk.needRender = true;\r\n    });\r\n    globals.renderer.needRender = true;\r\n}\r\n\r\nfunction initModMenu() {\r\n    initSliding();\r\n    initSendAlerts();\r\n\r\n    function initSliding() {\r\n        $('#modMenu .title').on('click', e => {\r\n            const m = $('#modMenu');\r\n            if (m.data('state') === 'open') {\r\n                m.data('state', 'close');\r\n                m.css('right', '');\r\n            } else {\r\n                m.data('state', 'open');\r\n                m.css('right', $('#modMenu .body').css('width'));\r\n            }\r\n        })\r\n    }\r\n\r\n    function initSendAlerts() {\r\n        $('#sendAlerts').on('click', () => {\r\n            const val = $('#sendAlertsText').val();\r\n            if (val.length == 0 || val.length > 2000) return;\r\n\r\n            $('#sendAlertsText').val('');\r\n            globals.socket.sendAlert('all', val);\r\n        })\r\n    }\r\n}\r\n\r\nexport async function fetchCaptcha() {\r\n    const resp = await apiRequest('/captcha/get');\r\n    return await resp.text()\r\n}\r\n\r\nexport async function solveCaptcha(answer) {\r\n    const resp = await apiRequest('/captcha/solve', {\r\n        method: 'POST',\r\n        body: { answer }\r\n    });\r\n\r\n    const json = await resp.json();\r\n\r\n    if (json.success !== undefined)\r\n        return json.success;\r\n\r\n    return false\r\n}\r\n\r\n// an old analog for setPaletteColorsSize\r\nexport function setPaletteRows(rows) {\r\n    let width = (window.innerWidth / 100) * rows;\r\n\r\n    $('#palette').css('max-width', width);\r\n}\r\n\r\n\r\nexport function setPaletteColorsSize(size) {\r\n    if (size === undefined) {\r\n        size = getRecommendedColorSize();\r\n    }\r\n    $('.paletteColor').css('width', size).css('height', size);\r\n}\r\n\r\n// you can't just change css se..\r\nexport function changeSelector(selector, obj) {\r\n    let el;\r\n    if (!(el = document.getElementById('REPLACE-' + selector))) {\r\n        el = document.createElement('style');\r\n        el.id = 'REPLACE-' + selector;\r\n    }\r\n\r\n    let styleArr = Object.keys(obj).map(prop => prop + ':' + obj[prop]);\r\n    el.innerText = `${selector}{${styleArr.join(';')}}`;\r\n\r\n    document.head.appendChild(el);\r\n}\r\n\r\nexport function initMobileMenuToggler() {\r\n    $('.showMenu,.hideMenu').on('click', toggleTopMenu)\r\n}\r\n\r\nexport function toggleEmojis(state) {\r\n    state ? $('#emotions').show() : $('#emotions').hide();\r\n}\r\n\r\nexport function updateEmojis(list) {\r\n    const container = $('#emotions');\r\n    let html = '';\r\n\r\n    for (let el of list) {\r\n        html += `<div class=\"emotion\">${el}</div>`;\r\n    }\r\n\r\n    container.html(html);\r\n\r\n    $('div', container).on('click', e => {\r\n        $('#chatInput')[0].value += e.target.innerText;\r\n        $('#chatInput').trigger('focus');\r\n    })\r\n}\r\n\r\nexport function updateBrush(size) {\r\n    player.brushSize = +size;\r\n    globals.fxRenderer.needRender = true;\r\n\r\n    globals.renderer.preRenderBrush();\r\n\r\n    $('#brushSizeCounter').text(size - 1);\r\n}\r\n\r\nexport function togglePlaced(state) {\r\n    state ? $('#placedPixels').show() : $('#placedPixels').hide();\r\n}\r\n\r\nexport function updatePlaced(count, handCount) {\r\n    // FIXME: move it to interval?\r\n    $('#placedPixels').text(count);\r\n    if (handCount)\r\n        $('#placedPixels').attr('title', handCount);\r\n}\r\n\r\nlet lastPlaced = player.placedCount;\r\nsetInterval(() => {\r\n    if (lastPlaced !== player.placedCount) {\r\n        setLS('placedCount', player.placedCount, true);\r\n        lastPlaced = player.placedCount;\r\n    }\r\n}, 3000)\r\n\r\nexport function fixColorsWidth() {\r\n    const savedWidth = getLS('colorSize', true);\r\n    const calculated = getRecommendedColorSize();\r\n\r\n    const colSize = +savedWidth || calculated\r\n    setPaletteColorsSize(colSize);\r\n    fixChatPosition();\r\n}\r\n\r\nfunction initUISettings() {\r\n    fixColorsWidth();\r\n    toggleEmojis(getLS('hideEmojis') != 1);\r\n    updateEmojis(getOrDefault('emojis', '🙁 🤔 😀 😄 💚 😡 👋 👍 😐').split(' '));\r\n    togglePlaced(!+getOrDefault('hidePlaced', 1))\r\n    updatePlaced(getLS('placedCount', true));\r\n    if (getLS('showPalettePatterns') == 1) {\r\n        showPatternsOnPalette();\r\n        globals.showPatterns = true;\r\n    }\r\n}\r\n\r\nfunction initMobileChatToggle() {\r\n    $('.showChat').on('click', () => {\r\n        $('.showChat').removeClass('showChat-notify');\r\n        chat.mobileShow()\r\n    });\r\n    $('#hideChat').on('click', () => {\r\n        $('.showChat').removeClass('showChat-notify');\r\n        chat.mobileHide()\r\n    });\r\n}\r\n\r\nfunction initHelpButton() {\r\n    $('.helpBtn').on('click', () => {\r\n        help()\r\n    })\r\n}\r\n\r\nexport function initOtherCoolFeatures() {\r\n    initTemplateMoveByMouse();\r\n    initModMenu();\r\n    initMobileMenuToggler();\r\n    initUISettings();\r\n    initMobileChatToggle();\r\n    initHelpButton();\r\n    player.init();\r\n    initCoordsClick();\r\n    initOnlineViewer();\r\n    initMenuResizer();\r\n    showHelpIfFirstTime();\r\n    startWinampRadio();\r\n}\r\n\r\nfunction initCoordsClick() {\r\n    globals.elements.coords.addEventListener('click', function () {\r\n        globals.elements.chatInput.value += this.innerText;\r\n        globals.elements.chatInput.focus();\r\n    })\r\n}\r\n\r\nexport function makeScreenshot() {\r\n    const canvas = globals.chunkManager.dumpAll();\r\n\r\n    const link = document.createElement('a');\r\n    link.download = `GX ${canvasName} ${getPathsafeDate()}.png`;\r\n    link.href = canvas.toDataURL()\r\n    link.click();\r\n}\r\n\r\n// beta and probably temprorary\r\n// purposely not optimised\r\nexport function showPatternsOnPalette() {\r\n    unloadPalettePatterns();\r\n\r\n    palette.forEach(([r, g, b], i) => {\r\n        const pat = patterns[i % patterns.length];\r\n\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvas.height = 14;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.fillStyle = hexPalette[i];\r\n\r\n        for (let i = 0; i < 7 * 7; i++) {\r\n            if (!pat[i]) continue;\r\n            const x = i % 7;\r\n            const y = i / 7 | 0;\r\n\r\n            ctx.fillRect(x * 2, y * 2, 2, 2);\r\n        }\r\n\r\n        function toI(x, y) {\r\n            return (x + y * 14) * 4;\r\n        }\r\n\r\n        // draw contour\r\n        let imd = ctx.getImageData(0, 0, 14, 14).data;\r\n        if (isDarkColor(r, g, b)) {\r\n            ctx.fillStyle = 'white';\r\n            let coords = [];\r\n            for (let x = 0; x < 14; x++) {\r\n                for (let y = 0; y < 14; y++) {\r\n                    if (imd[toI(x, y) + 3]) continue\r\n\r\n                    const top = imd[toI(x, y - 1) + 3];\r\n                    const bottom = imd[toI(x, y + 1) + 3];\r\n                    const left = imd[toI(x - 1, y) + 3];\r\n                    const right = imd[toI(x + 1, y) + 3];\r\n\r\n                    const leftTop = imd[toI(x - 1, y - 1) + 3];\r\n                    const rightTop = imd[toI(x + 1, y - 1) + 3];\r\n                    const leftBottom = imd[toI(x - 1, y + 1) + 3];\r\n                    const rightBottom = imd[toI(x + 1, y + 1) + 3];\r\n\r\n                    if (top || bottom || left || right ||\r\n                        leftTop || rightTop || leftBottom || rightBottom) {\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        imd = ctx.getImageData(0, 0, 14, 14).data;\r\n        ctx.fillStyle = 'black';\r\n        for (let i = 0; i < 14 * 14; i++) {\r\n            if (!imd[i * 4 + 3])\r\n                ctx.fillRect(i % 14, i / 14 | 0, 1, 1)\r\n        }\r\n\r\n\r\n        const dataurl = canvas.toDataURL();\r\n        const img = document.createElement('img');\r\n        img.src = dataurl;\r\n        img.style.cssText =\r\n            `position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%, -50%);\r\n        image-rendering: pixelated;\r\n        width: inherit`;\r\n        $(`#col${i}`).append(img);\r\n    })\r\n}\r\n\r\nexport function unloadPalettePatterns() {\r\n    $('.paletteColor>img').remove();\r\n}\r\n\r\nexport function removeOldKeybinds() {\r\n    try {\r\n        const str = getLS('keyBinds');\r\n        const json = JSON.parse(str);\r\n        for (let bind of Object.values(json)) {\r\n            let key = bind.split('+').slice(-1);\r\n            key = +key;\r\n            if (!isNaN(key)) {\r\n                localStorage.removeItem('keyBinds');\r\n                return\r\n            }\r\n        }\r\n    } catch { }\r\n}\r\n\r\nfunction initOnlineViewer() {\r\n    $('#onlineColumn .columnHeader').on('click', async () => {\r\n        let json;\r\n        try {\r\n            const resp = await fetch('/api/online');\r\n            json = await resp.json();\r\n        } catch (e) {\r\n            toastr.error(e);\r\n            return\r\n        }\r\n\r\n        onlineViewWindow(json);\r\n    });\r\n}\r\n\r\nfunction initChatHeightWorkaround() {\r\n    // -webkit-fill-available does not work since\r\n    // the best way to define height that i know \r\n    // for the moment is through the script\r\n\r\n    function fixChatHeight() {\r\n        document.documentElement.style.setProperty('--gorox-chat-height', $(window).height() + 'px');\r\n    }\r\n\r\n    $(window).on('resize', fixChatHeight);\r\n    fixChatHeight();\r\n}\r\n\r\nexport function fixChatPosition() {\r\n    const paletteHeight = $('#palette').innerHeight();\r\n    $('#chat').css('bottom', paletteHeight + 4);\r\n}\r\n\r\nfunction initMenuResizer() {\r\n    const resizer = $('#menuResizer');\r\n    const resizerStripes = $('#resizingStripes');\r\n\r\n    let curHeight = +getLS('columnHeight');\r\n    if (isNaN(curHeight) || curHeight == 0) {\r\n        curHeight = 123;\r\n    } else if (curHeight < 0) {\r\n        curHeight = 0;\r\n    } else if (curHeight >= (window.screen.height - 250)) {\r\n        curHeight = window.screen.height - 250;\r\n    }\r\n    $('.columnContent').css('height', curHeight);\r\n\r\n    let resizeTimeout;\r\n    let resizeLock = false;\r\n\r\n    function unfade() {\r\n        resizer.css('height', '7px');\r\n        resizer.css('background-color', '#4c4c4c');\r\n        resizerStripes.css('opacity', '1');\r\n    }\r\n\r\n    function fade() {\r\n        clearTimeout(resizeTimeout);\r\n        resizer.css('height', '');\r\n        resizer.css('background-color', '');\r\n        resizerStripes.css('opacity', '');\r\n    }\r\n\r\n    resizer.on('mouseover', () => {\r\n        clearTimeout(resizeTimeout);\r\n        resizeTimeout = setTimeout(() => {\r\n            unfade();\r\n        }, 500)\r\n    })\r\n\r\n    resizer.on('mouseout', () => {\r\n        if (resizeLock) return;\r\n\r\n        fade();\r\n    })\r\n\r\n    function onmousedown() {\r\n        resizeLock = true;\r\n        unfade();\r\n\r\n        function onmousemove(e) {\r\n            curHeight += e.originalEvent.movementY;\r\n            $('.columnContent').css('height', curHeight);\r\n            setLS('columnHeight', curHeight);\r\n        }\r\n        function oncemouseup() {\r\n            $(document).off('mousemove', onmousemove);\r\n            resizeLock = false;\r\n            fade();\r\n        }\r\n\r\n        $(document).on('mousemove', onmousemove)\r\n        $(document).one('mouseup', oncemouseup)\r\n    }\r\n    resizer.on('mousedown', onmousedown);\r\n}\r\n\r\nfunction showHelpIfFirstTime() {\r\n    const shownAlready = getLS('helpShown');\r\n    if (!shownAlready) {\r\n        setLS('helpShown', '1');\r\n        help();\r\n    }\r\n}\r\n\r\nfunction startWinampRadio(){\r\n    const player = new WinampPlayer();\r\n    player.init();\r\n\r\n    window.wPlayer = player;\r\n}","import '../css/colorVars.css'\r\nimport '../css/style.css'\r\nimport '../../node_modules/toastr/build/toastr.css'\r\n\r\nimport '../img/vk-logo.svg';\r\nimport '../img/discord-logo-circle.svg';\r\nimport '../img/fb-logo.svg';\r\nimport '../img/stripes.png';\r\nimport '../img/dots.svg';\r\nimport '../img/goroxels.png';\r\n\r\nimport '../img/telegram.svg';\r\n\r\nimport '../video/clickerMouse.webm'\r\nimport '../video/clicker.webm'\r\nimport '../video/as.webm'\r\nimport '../video/toolC.webm'\r\nimport '../video/brush.webm'\r\nimport '../video/brush2.webm'\r\nimport '../video/line.webm'\r\nimport '../video/flood.webm'\r\nimport '../img/unavailable.png'\r\nimport '../video/ctrlZ.webm'\r\nimport '../video/patternDemo.webm'\r\nimport '../img/3rdcf.png'\r\n\r\nexport default {}","import globals from './globals'\r\nimport {\r\n    boardWidth,\r\n    boardHeight\r\n} from './config'\r\nimport EventEmitter from 'events';\r\nimport { getOrDefault, setLS } from './utils/localStorage';\r\n\r\nconst camera = {\r\n    x: null, y: null,\r\n    zoom: null,\r\n    minX: null, minY: null, \r\n    maxX: null, maxY: null,\r\n\r\n    minZoom: 0.1,\r\n    maxZoom: 64,\r\n\r\n    // when it's needed to disable moving\r\n    noMoving: false,\r\n\r\n    init(){\r\n        Object.assign(this, {\r\n            x: +getOrDefault('posX', 0, true),\r\n            y: +getOrDefault('posY', 0, true),\r\n\r\n            zoom: +getOrDefault('zoom', 1, true),\r\n\r\n            minX: -boardWidth/2,\r\n            minY: -boardHeight/2,\r\n            maxX: boardWidth/2,\r\n            maxY: boardHeight/2,\r\n        })\r\n        if(isNaN(this.x) || isNaN(this.y) || isNaN(this.zoom)){\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.zoom = 1;\r\n        }\r\n    },\r\n\r\n    centerOn(x, y){\r\n        globals.renderer.needRender = true;\r\n        if(this.noMoving) return;\r\n        \r\n        this.x = x - this.maxX;\r\n        this.y = y - this.maxY;\r\n\r\n        this.clampPos();\r\n    },\r\n\r\n    moveTo(movx, movy){\r\n        globals.renderer.needRender = true;\r\n        if(this.noMoving) return;\r\n\r\n        this.x += movx;\r\n        this.y += movy;\r\n\r\n        this.clampPos();\r\n    },\r\n\r\n    clampPos(){\r\n        this.x = Math.min(Math.max(this.x, this.minX), this.maxX);\r\n        this.y = Math.min(Math.max(this.y, this.minY), this.maxY);\r\n    },\r\n\r\n    zoomTo(dir){\r\n        if(dir < 0){\r\n            this.zoom = this.zoom * 2 | 0 || 1;\r\n        }else{\r\n            this.zoom = this.zoom / 2;\r\n        }\r\n        this.checkZoom();\r\n\r\n        this.emit('zoom', this.zoom);\r\n\r\n        globals.renderer.needRender = true;\r\n        globals.fxRenderer.needRender = true;\r\n\r\n        globals.renderer.preRender();\r\n    },\r\n\r\n    checkZoom(){\r\n        this.zoom = Math.min(Math.max(this.zoom, this.minZoom), this.maxZoom)\r\n    }, \r\n\r\n    disableMove(){\r\n        this.noMoving = true;\r\n    },\r\n\r\n    enableMove(){\r\n        this.noMoving = false;\r\n    },\r\n\r\n    __proto__: new EventEmitter\r\n}\r\n\r\nlet lastX, lastY, lastZ;\r\nsetInterval(() => {\r\n    const newX = camera.x,\r\n        newY = camera.y,\r\n        newZ = camera.zoom;\r\n\r\n    if(lastX != newX) setLS('posX', newX, true);\r\n    if(lastY != newY) setLS('posY', newY, true);\r\n    if(lastZ != newZ) setLS('zoom', newZ, true);\r\n\r\n    lastX = newX; lastY = newY; lastZ = newZ;\r\n}, 3000);\r\n\r\nexport default (window.camera = camera);","import { canvasName, game } from './config';\r\nimport { chatInput } from './elements';\r\nimport globals from './globals';\r\nimport { translate as t_ } from './translate';\r\nimport cssColors from './utils/cssColorsList'\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport { htmlspecialchars } from './utils/misc';\r\n\r\n// currently chat supports only one channel\r\n// but socket is designed to handle many\r\n\r\nfunction pad(pad, str, padLeft) {\r\n    if (typeof str === 'undefined')\r\n        return pad;\r\n    if (padLeft) {\r\n        return (pad + str).slice(-pad.length);\r\n    } else {\r\n        return (str + pad).substring(0, pad.length);\r\n    }\r\n}\r\n\r\nconst colorRegEx = new RegExp(/\\[(#?[A-Z0-9]{1,8})*?\\]/gi);\r\n                          // https : / / host.com/img .png       ? q=321123\r\nconst imgRegEx = new RegExp(/http?s:\\/\\/.+?\\.(png|jpg|jpeg|gif)(\\?\\S+)?/i);\r\n\r\nclass Chat {\r\n    constructor() {\r\n        this.element = $('#chat');\r\n\r\n        this.logElems = {};\r\n\r\n        this.colorsEnabled = !JSON.parse(getOrDefault('disableColors', false));\r\n\r\n        this.muted = JSON.parse(getLS('muted')) || [];\r\n\r\n        this.channel = undefined;\r\n\r\n        this.initChatEvents();\r\n    }\r\n\r\n    loadChannelElements(){\r\n        [...$('#chatLog').children()].map(el => {\r\n            let channel = el.dataset.channel;\r\n            if(channel === 'local'){\r\n                channel = canvasName;\r\n            }\r\n            this.logElems[channel] = $(el);\r\n        })\r\n    }\r\n\r\n    // mobile version of hide/show\r\n    mobileShow() {\r\n        this.element.css('top', '0');\r\n    }\r\n\r\n    mobileHide() {\r\n        this.element.css('top', '-100vh');\r\n    }\r\n\r\n    setColors(state) {\r\n        this.colorsEnabled = state;\r\n\r\n        $('.chatColored').toggleClass('noColor', !state);\r\n    }\r\n\r\n    parseColors(str) {\r\n        // colors should be formatted like: [RED]test or [#FF0000]te[]st\r\n\r\n        let colorEntries = 0;\r\n\r\n        let regIter = str.matchAll(colorRegEx);\r\n        while (true) {\r\n            let {\r\n                value: entry,\r\n                done\r\n            } = regIter.next();\r\n            if (done) break;\r\n\r\n            let color = entry[1];\r\n\r\n            if (color) {\r\n                // test for \"#\" and mathing A-F a-f hex alphabet\r\n                if (color.startsWith('#') && !/[G-Zg-z]/.test(color)) {\r\n                    color = pad(color.slice(-1).repeat(6 + 1), color);\r\n                } else if (!cssColors[color]) continue;\r\n\r\n                str = str.replace(entry[0],\r\n                    `<div class=\"chatColored${this.colorsEnabled ? '' : ' noColor'}\" style=\"color:${color}\">`);\r\n                colorEntries++;\r\n            } else { // empty braces\r\n                if (colorEntries > 0) {\r\n                    str = str.replace(entry[0], '</div>');\r\n                    colorEntries--;\r\n                } else {\r\n                    // \"[\" and \"]\"\r\n                    str = str.replace(entry[0], '&#91;&#93;');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (colorEntries > 0) str += '</div>'.repeat(colorEntries);\r\n\r\n        return str\r\n    }\r\n    parseCoords(str) {\r\n        return str.replace(/\\((\\d{1,5}), ?(\\d{1,5})\\)/g,\r\n            `<a class=\"cordgo\" onclick=\"camera.centerOn($1, $2)\">$&</a>`)\r\n    }\r\n    parseImage(str) {\r\n        let matching = str.match(imgRegEx);\r\n\r\n        if (matching) {\r\n            let src = matching[0];\r\n            str = str.replace(src,\r\n                `<span class=\"imageLink\" onclick=\"globals.chat.toggleImage(this)\">${src}</span>`) \r\n        }\r\n\r\n        return str\r\n    }\r\n    toggleImage(target){\r\n        const element = $(target);\r\n        const parent = element.parent();\r\n\r\n        const exists = !!$('img', parent).length;\r\n        if(exists){\r\n            $('.imageLink', parent).css('cursor', 'zoom-in')\r\n            $('img', parent).remove();\r\n        }else{\r\n            $('.imageLink', parent).css('cursor', 'zoom-out');\r\n            const img = $(`<img src=\"${element.text()}\" class=\"chatImg\" onclick=\"globals.chat.toggleImage(this)\">`);\r\n            img.on('load', this.scroll.bind(this, this.channel));\r\n            parent.append(img);\r\n        }\r\n    }\r\n\r\n    parseBB(str){\r\n        // function does not checks for brackets order validity\r\n        let openedTags = [];\r\n\r\n        let regIter = str.matchAll(/\\[(\\/?[bi])\\]/gi);\r\n        while (true) {\r\n            let {\r\n                value: entry,\r\n                done\r\n            } = regIter.next();\r\n            if (done) break;\r\n\r\n            let tag = entry[1];\r\n            str = str.replace(entry[0],\r\n                `<${tag}>`);\r\n            if(!tag.startsWith('/'))\r\n                openedTags.push(tag);\r\n            else{\r\n                openedTags = openedTags.splice(openedTags.indexOf(tag.slice(1)));\r\n            }\r\n        }\r\n\r\n        while(openedTags.length){\r\n            str += `</${openedTags.shift()}>`\r\n        }\r\n\r\n        return str\r\n    }\r\n\r\n    addMessage(message) {\r\n        $('.showChat').addClass('showChat-notify');\r\n\r\n        const channel = message.ch;\r\n\r\n        if (message.server)\r\n            return this.addServerMessage(message.msg, channel);\r\n\r\n        let text = htmlspecialchars(message.msg),\r\n            nick = htmlspecialchars(message.nick);\r\n\r\n        const realNick = nick;\r\n\r\n        if (nick === 'Goroh') {\r\n            nick = `<span style=\"text-shadow:0 0 3px\">[#00f986]${nick}</span>`\r\n        }\r\n\r\n        try{\r\n            text = this.parseColors(text);\r\n            text = this.parseBB(text);\r\n            text = this.parseCoords(text);\r\n            text = this.parseImage(text);\r\n    \r\n            nick = this.parseColors(nick);\r\n        }catch(e){\r\n            console.log(e);\r\n        }\r\n\r\n        const isMuted = ~this.muted.indexOf(realNick);\r\n\r\n        const msgEl = $(\r\n            `<div class=\"chatMessage\" ${isMuted ? 'style=\"display:none\"' : ''}>\r\n            <div class=\"messageNick\" data-nick=\"${realNick}\">${nick}:</div>\r\n            <div class=\"messageText\">${text}</div>\r\n        </div>`);\r\n\r\n        $('.messageNick', msgEl).on('click', function () {\r\n            const visibleNick = this.innerText.slice(0, -1);\r\n            globals.elements.chatInput.value += visibleNick + ', ';\r\n            globals.elements.chatInput.focus();\r\n        })\r\n\r\n        this.logElems[channel].append(msgEl);\r\n\r\n        this.afterAddingMessage(channel);\r\n    }\r\n\r\n    addLocalMessage(text, channel) {\r\n        text = this.parseColors(text);\r\n        text = this.parseBB(text);\r\n        text = this.parseCoords(text);\r\n        text = this.parseImage(text);\r\n\r\n        const msgEl = $(\r\n            `<div class=\"chatMessage\">\r\n                <div class=\"messageText\">${text}</div>\r\n            </div>`)\r\n\r\n        this.logElems[channel].append(msgEl);\r\n\r\n        this.afterAddingMessage(channel);\r\n    }\r\n\r\n    switchChannel(channel){\r\n        if(this.channel === channel){\r\n            return;\r\n        }\r\n\r\n        const channelAlias = channel;\r\n        if(channel === 'local'){\r\n            channel = canvasName;\r\n        }\r\n\r\n        for(let ch of Object.values(this.logElems)){\r\n            ch.hide();\r\n        }\r\n        this.logElems[channel].show();\r\n\r\n        $(`#chatChannels>div`).removeClass('selected');\r\n        $(`#chatChannels>div[data-channel=\"${channelAlias}\"]`).addClass('selected');\r\n\r\n        this.scroll(channel, true);\r\n\r\n        this.channel = channel;\r\n    }\r\n\r\n    addServerMessage(text, channel) {\r\n        this.addLocalMessage(text, channel);\r\n    }\r\n\r\n    afterAddingMessage(channel) {\r\n        const el = this.logElems[channel];\r\n        if (el.children().length > game.chatLimit) {\r\n            el.children()[0].remove();\r\n        }\r\n        this.scroll(channel);\r\n    }\r\n\r\n    // handles messages to send\r\n    handleMessage(message) {\r\n        if (message.startsWith('/')) {\r\n            this.handleCommand(message);\r\n        } else\r\n        globals.socket.sendChatMessage(message, this.channel);\r\n    }\r\n\r\n    sendWhisper(target, message){\r\n        globals.socket.sendChatWhisper(message, this.channel, target);\r\n    }\r\n\r\n    // handles chat commands\r\n    handleCommand(command) {\r\n        let args = command.split(' ');\r\n\r\n        const cmd = args[0];\r\n        args = args.slice(1);\r\n\r\n        console.log(args);\r\n\r\n        switch(cmd){\r\n            case '/mute': {\r\n                const nick = args.join(' ');\r\n                this.mute(nick);\r\n\r\n                break\r\n            }\r\n            case '/unmute': {\r\n                const nick = args.join(' ');\r\n                this.unmute(nick);\r\n\r\n                break\r\n            }\r\n            case '/w': {\r\n                if(args.length < 2){\r\n                    return this.addLocalMessage('Usage: /w &lt;targetAccountId&gt; &lt;message&gt;');\r\n                }\r\n                const id = args[0];\r\n                const msg = args.slice(1).join(' ');\r\n\r\n                this.sendWhisper(id, msg);\r\n                chatInput.val(`/w ${id} `);\r\n\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    mute(nick) {\r\n        const pref = '<b>mute:</b> ';\r\n\r\n        if (!nick.length || nick.length > 32) {\r\n            return this.addLocalMessage(pref + t_('Wrong nick length'))\r\n        }\r\n        if (~this.muted.indexOf(nick)) {\r\n            return this.addLocalMessage(pref + t_('Player is already muted'))\r\n        }\r\n\r\n        this.muted.push(nick);\r\n        setLS('muted', JSON.stringify(this.muted));\r\n\r\n        $('.messageNick').each((_, el) => {\r\n            if (el.dataset.nick === nick) {\r\n                el.parentElement.style.display = 'none';\r\n            }\r\n        })\r\n    }\r\n\r\n    unmute(nick) {\r\n        let pref = '<b>unmute:</b> ', index;\r\n\r\n        if (!nick.length || nick.length > 32) {\r\n            return this.addLocalMessage(pref + t_('Wrong nick length'))\r\n        }\r\n        if (!~(index = this.muted.indexOf(nick))) {\r\n            return this.addLocalMessage(pref + t_('Player is not muted'))\r\n        }\r\n\r\n        this.muted.splice(index, 1);\r\n        setLS('muted', JSON.stringify(this.muted));\r\n\r\n        $('.messageNick').each((_, el) => {\r\n            if (el.dataset.nick === nick) {\r\n                el.parentElement.style.display = 'block';\r\n            }\r\n        })\r\n    }\r\n\r\n    initChatEvents() {\r\n        chatInput.on('input', () => {\r\n            const value = chatInput.val();\r\n            if (imgRegEx.test(value)) {\r\n                chatInput.css('color', 'white');\r\n            } else {\r\n                chatInput.css('color', '');\r\n            }\r\n        })\r\n    }\r\n\r\n    // this function scrolls only if player scrolled chat log to the end\r\n    scroll(channel='global', force=false){\r\n        const el$ = this.logElems[channel];\r\n        const el = el$.parent()[0];\r\n        const lastElemHeight = el$.children().slice(-1).innerHeight() || 0;\r\n        // 2 is message margin and 5 is just for fun\r\n        const scrolled = (el.scrollHeight - el.scrollTop - el.clientHeight - lastElemHeight) <= 2+5;\r\n        if(scrolled || force){\r\n            el.scrollBy(0, 999);\r\n        }\r\n    }\r\n}\r\n\r\nexport default globals.chat = new Chat();","// key codes to human readable string\r\n// !deprecated!\r\nexport const keys = { // others are ok with charCodeAt\r\n    8: \"Backspace\",\r\n    9: \"Tab\",\r\n    12: \"Clear\",\r\n    13: \"Enter\",\r\n    16: \"Shift\",\r\n    17: \"Control\",\r\n    18: \"Alt\",\r\n    19: \"Pause\",\r\n    20: \"CapsLock\",\r\n    27: \"Escape\",\r\n    32: \"Space\",\r\n    33: \"PageUp\",\r\n    34: \"PageDown\",\r\n    35: \"End\",\r\n    36: \"Home\",\r\n    37: \"ArrowLeft\",\r\n    38: \"ArrowUp\",\r\n    39: \"ArrowRight\",\r\n    40: \"ArrowDown\",\r\n    45: \"Insert\",\r\n    46: \"Delete\",\r\n    112: \"F1\",\r\n    113: \"F2\",\r\n    114: \"F3\",\r\n    115: \"F4\",\r\n    116: \"F5\",\r\n    117: \"F6\",\r\n    118: \"F7\",\r\n    119: \"F8\",\r\n    120: \"F9\",\r\n    121: \"F10\",\r\n    122: \"F11\",\r\n    123: \"F12\",\r\n    144: \"NumLock\",\r\n    145: \"ScrollLock\",\r\n    48: \"0\",\r\n    49: \"1\",\r\n    50: \"2\",\r\n    51: \"3\",\r\n    52: \"4\",\r\n    53: \"5\",\r\n    54: \"6\",\r\n    55: \"7\",\r\n    56: \"8\",\r\n    57: \"9\",\r\n    106: \"*\",\r\n    107: \"+\",\r\n    109: \"-\",\r\n    111: \"/\",\r\n    186: \";\",\r\n    187: \"=\",\r\n    188: \",\",\r\n    189: \"-\",\r\n    190: \".\",\r\n    191: \"/\",\r\n    192: \"`\",\r\n    219: \"[\",\r\n    220: \"\\\\\",\r\n    221: \"]\",\r\n    222: \"'\"\r\n}\r\n\r\nexport const ROLE = {\r\n    BANNED: -1,\r\n    GUEST: 0,\r\n    USER: 1,\r\n    TRUSTED: 2,\r\n    MOD: 3,\r\n    ADMIN: 4\r\n}\r\nexport const ROLE_I = {};\r\nObject.keys(ROLE).forEach(x => ROLE_I[ROLE[x]] = x);","export const urlInput = $('#templateURL'),\r\n    xInput = $('#templateX'),\r\n    yInput = $('#templateY'),\r\n    opacInput = $('#templateOpacity'),\r\n\r\n    ui = $('#ui'),\r\n    chat = $('#chat'),\r\n    chatInput = $('#chatInput'),\r\n    template = $('#template'),\r\n    topMenu = $('#topMenu');","import globals from './globals';\r\n\r\nconst NOT_FINISHED = 0,\r\n    FINISHED = 1,\r\n    DELETED = 2;\r\n\r\nexport class FX {\r\n    constructor(renderFunc) {\r\n        this.renderFunc = renderFunc;\r\n\r\n        this.removed = false;\r\n    }\r\n\r\n    render(ctx) {\r\n        return this.renderFunc(ctx);\r\n    }\r\n\r\n    remove() {\r\n        this.removed = true;\r\n    }\r\n}\r\n\r\nexport class FXRenderer {\r\n    constructor() {\r\n        // three layers\r\n        this.fxList = [[], [], []];\r\n        this.ctx = globals.fxCtx;\r\n\r\n        this.needRender = true;\r\n        this.needClear = false;\r\n    }\r\n\r\n    add(fx, layer = 0) {\r\n        this.fxList[layer].push(fx);\r\n\r\n        this.needRender = true;\r\n    }\r\n\r\n    /*\r\n      You can request it by returning zero in rendering\r\n      functions or explicitly ↓\r\n    */\r\n    requestRender() {\r\n        this.needRender = true;\r\n    }\r\n\r\n    render() {\r\n        if (!this.needRender) return;\r\n\r\n        this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n\r\n        this.needRender = false;\r\n\r\n        for (let layer = 0; layer < this.fxList.length; layer++) {\r\n            this.fxList[layer].forEach(fx => {\r\n                if (fx.removed) return this.remove(fx);\r\n\r\n                let r = fx.render(this.ctx);\r\n\r\n                /*\r\n                    0 - not finished yet\r\n                    1 - finished but continue rendering\r\n                    2 - finished\r\n                */\r\n\r\n                if (r == 2) {\r\n                    this.remove(fx);\r\n                } else if (r == 0) {\r\n                    this.needRender = true;\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    remove(fx) {\r\n        for (let layer = 0; layer < this.fxList.length; layer++) {\r\n            let idx = this.fxList[layer].indexOf(fx);\r\n            if (idx != -1) {\r\n                this.fxList[layer][idx].remove();\r\n                this.fxList[layer].splice(idx, 1);\r\n                this.needRender = true;\r\n                break\r\n            }\r\n        }\r\n\r\n    }\r\n}","import EventEmitter from 'events'\r\nimport EventManager from './EventManager'\r\n\r\nimport {\r\n    insanelyLongMobileBrowserCheck\r\n} from './utils/misc'\r\n\r\nexport default {\r\n    socket: null,\r\n    chunkManager: null,\r\n    renderer: null,\r\n    fxRenderer: null,\r\n    player: null,\r\n    toolManager: null,\r\n    events: new EventEmitter,\r\n    eventManager: new EventManager(document.getElementById('board')),\r\n    mainCtx: document.getElementById('board').getContext('2d'),\r\n    fxCtx: document.getElementById('fx').getContext('2d'),\r\n    mobile: insanelyLongMobileBrowserCheck(),\r\n    users: {},\r\n    elements: { // TODO move it to elements.js\r\n        mainCanvas: $('#board')[0],\r\n        fxCanvas: $('#fx')[0],\r\n        palette: $('#palette')[0],\r\n        online: $('#onlineCounter')[0],\r\n        coords: $('#coords')[0],\r\n        topMenu: $('#topMenu')[0],\r\n        topMenuContent: $('#topMenu>.content')[0],\r\n        chatInput: $('#chatInput')[0]\r\n    }\r\n}","export let initiated = false;\r\nexport let database = null;\r\n\r\nlet deferredCallbacks = [];\r\n\r\nexport function init() {\r\n    let openRequest = indexedDB.open(\"db\", 1);\r\n\r\n    function onDone(){\r\n        initiated = true;\r\n        execCallbacks();\r\n    }\r\n\r\n    openRequest.onupgradeneeded = function () {\r\n        database = openRequest.result;\r\n        if (!database.objectStoreNames.contains('chunkPlaceholders')) {\r\n            database.createObjectStore('chunkPlaceholders', { keyPath: 'chunk_key' });\r\n        }\r\n\r\n        onDone();\r\n    };\r\n\r\n    openRequest.onsuccess = () => {\r\n        database = openRequest.result;\r\n        onDone();\r\n    };\r\n}\r\n\r\nfunction execCallbacks(){\r\n    deferredCallbacks.forEach(cb => {\r\n        try {\r\n            cb(database);   \r\n        } catch (error) {\r\n            console.error(error);\r\n        }\r\n    })\r\n    deferredCallbacks.length = 0;\r\n}\r\n\r\nexport function addInitCallback(cb) {\r\n    if (initiated) {\r\n        cb(database);\r\n        return;\r\n    }\r\n\r\n    deferredCallbacks.push(cb);\r\n}","import _ from './assets';\r\n\r\nimport Socket from './Socket';\r\nimport globals from './globals';\r\nimport ChunkManager from './ChunkManager';\r\nimport Renderer from './Renderer';\r\nimport { FXRenderer } from './fxcanvas';\r\nimport player from './player';\r\nimport ToolManager from './ToolManager';\r\nimport { calculateColumnSize, getRecommendedColorSize, initHalfmap } from './utils/misc';\r\n\r\nimport * as config from './config';\r\nimport {\r\n    updateMe,\r\n    initInputs,\r\n    initOtherCoolFeatures,\r\n    fixChatPosition,\r\n    fixColorsWidth,\r\n    showPatternsOnPalette,\r\n    removeOldKeybinds\r\n} from './actions';\r\nimport { init as initTranslate, translate } from './translate';\r\nimport camera from './camera';\r\nimport { Modal } from './Window';\r\nimport { getLS, setLS } from './utils/localStorage';\r\nimport * as indexedDb from './indexedDb';\r\n\r\n(async () => {    \r\n    indexedDb.init();\r\n    await config.download();\r\n\r\n    const {\r\n        elements,\r\n    } = globals;\r\n\r\n    window.onresize = () => {\r\n        elements.mainCanvas.width = window.innerWidth;\r\n        elements.mainCanvas.height = window.innerHeight;\r\n\r\n        elements.fxCanvas.width = window.innerWidth;\r\n        elements.fxCanvas.height = window.innerHeight;\r\n\r\n        const fxCtx = elements.fxCanvas.getContext('2d');\r\n\r\n        ctx.imageSmoothingEnabled = fxCtx.imageSmoothingEnabled = false;\r\n        ctx.webkitImageSmoothingEnabled = fxCtx.webkitImageSmoothingEnabled = false;\r\n        ctx.mozImageSmoothingEnabled = fxCtx.mozImageSmoothingEnabled = false;\r\n        ctx.msImageSmoothingEnabled = fxCtx.msImageSmoothingEnabled = false;\r\n        ctx.oImageSmoothingEnabled = fxCtx.oImageSmoothingEnabled = false;\r\n\r\n        renderer.needRender = true;\r\n        fxRenderer.needRender = true;\r\n\r\n        if (!globals.mobile) {\r\n            calculateColumnSize();\r\n        }\r\n\r\n        fixColorsWidth();\r\n        fixChatPosition();\r\n    }\r\n\r\n\r\n    window.oncontextmenu = function (e) {\r\n        if (e.target === globals.elements.mainCanvas ||\r\n            e.target.classList[0] === 'paletteColor' ||\r\n            e.path[1].classList[0] === 'paletteColor') {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    camera.init();\r\n    initHalfmap();\r\n\r\n    config.palette.forEach((color, id) => {\r\n        const el = document.createElement('div');\r\n        el.style.backgroundColor = `rgb(${color.join(',')})`;\r\n        // el.classList = ['paletteColor ' + (isDarkColor(...color) ? 'dark' : 'light')];\r\n        el.classList = ['paletteColor light'];\r\n        el.id = 'col' + id;\r\n\r\n        // detect long press\r\n        let downtime = 0;\r\n\r\n        var $el = $(el);\r\n\r\n        $el.on('pointerdown', () => {\r\n            downtime = Date.now();\r\n        })\r\n\r\n        $el.on('pointerleave', () => {\r\n            downtime = 0;\r\n        })\r\n\r\n        el.onclick = e => {\r\n            let isLong = false;\r\n            if (downtime != 0) {\r\n                if (Date.now() - downtime > 700) {\r\n                    isLong = true;\r\n                }\r\n                downtime = 0;\r\n            }\r\n\r\n            let f = isLong ? player.switchSecondColor : player.switchColor;\r\n            f.call(player, id);\r\n        }\r\n\r\n        el.oncontextmenu = () => {\r\n            // right button click\r\n            player.switchSecondColor(id);\r\n        }\r\n\r\n        elements.palette.appendChild(el);\r\n    })\r\n\r\n    const ctx = elements.mainCanvas.getContext('2d');\r\n    ctx.imageSmoothingEnabled = false;\r\n\r\n    const wsPort = location.protocol === 'https:' ? 443 : (location.port || 80);\r\n    const socket = new Socket(wsPort);\r\n    globals.socket = socket;\r\n\r\n    const chunkManager = new ChunkManager();\r\n    globals.chunkManager = chunkManager;\r\n\r\n    const renderer = window.renderer = new Renderer(ctx);\r\n    globals.renderer = renderer;\r\n\r\n    const fxRenderer = new FXRenderer();\r\n    globals.fxRenderer = fxRenderer;\r\n\r\n    globals.toolManager = new ToolManager(document.getElementById('board'));\r\n\r\n    globals.player = player;\r\n\r\n    const renderLoop = () => {\r\n        requestAnimationFrame(() => {\r\n            renderer.requestRender();\r\n            renderLoop();\r\n        })\r\n    }\r\n    renderLoop();\r\n\r\n    window.onresize();\r\n\r\n    socket.on('opened', () => { });\r\n    socket.on('online', count => {\r\n        $('.online').text(count);\r\n    });\r\n    socket.on('closed', () => {\r\n        $('.online').text('offline');\r\n    })\r\n\r\n    window.globals = globals;\r\n\r\n    // create nsfw modal\r\n    config.callOnLoad(() => {\r\n        if (config.canvasName !== 'nsfw') return;\r\n        if (getLS('modal18') == 'accepted') return;\r\n\r\n        const m = new Modal;\r\n        const mBody = $(\r\n            `<div style=\"margin:0;padding:5px;text-align:center;\">\r\n                <h1>${translate('WARNING')}</h1>\r\n                <p>${translate('This canvas may contain illustrations, inappropriate for people under age of 18, including:')}\r\n                <br>${translate('Gore, furry, porn, hate, anime and all possible variations of these.')}</p>\r\n                <p><b>${translate('Are you 18 y.o. and fully understanding what are you doing?')}</b></p>\r\n                <button style=\"padding: 8px;\">${translate('I am 18 years old and I take responsibility for my psyche on myself')}</button>\r\n            </div>`)\r\n        m.contEl.appendChild(mBody[0]);\r\n\r\n        $('button', mBody).on('click', () => {\r\n            m.close();\r\n            setLS('modal18', 'accepted');\r\n        })\r\n    });\r\n\r\n    updateMe();\r\n    initTranslate();\r\n    initInputs();\r\n    initOtherCoolFeatures();\r\n})();","import { apiRequest } from './actions';\r\nimport { ROLE } from './constants'\r\n\r\nlet loaded = false;\r\nlet cbs = [];\r\n\r\nexport default {\r\n    registered: false,\r\n    name: null,\r\n    id: null,\r\n    role: ROLE.GUEST,\r\n    update(newMe){\r\n        this.registered = newMe.registered;\r\n        if(newMe.registered){\r\n            this.name = newMe.name;\r\n            this.role = newMe.role;\r\n            this.id = newMe.id;\r\n        }\r\n\r\n        this.updateRoleRelatedHtml();\r\n    },\r\n\r\n    updateRoleRelatedHtml(){\r\n        $('.minrole-admin').hide();\r\n        $('.minrole-mod').hide();\r\n        $('.minrole-trusted').hide();\r\n        $('.minrole-user').hide();\r\n\r\n        switch(this.role){\r\n            case ROLE.ADMIN:\r\n                $('.minrole-admin').show();\r\n            case ROLE.MOD:\r\n                $('.minrole-mod').show();\r\n            case ROLE.TRUSTED:\r\n                $('.minrole-trusted').show();\r\n            case ROLE.USER:\r\n                $('.minrole-user').show();\r\n        }\r\n    },\r\n\r\n    checkCanGetUserInfo(){\r\n        return this.registered && this.role >= ROLE.TRUSTED\r\n    },\r\n\r\n    async load(){\r\n        const response = await apiRequest('/me');\r\n        const user = await response.json();\r\n\r\n        this.update(user);\r\n\r\n        loaded = true;\r\n        this.callStacked();\r\n    },\r\n\r\n    callOnLoaded(cb){\r\n        if(this.loaded)\r\n            return cb();\r\n        cbs.push(cb);\r\n    },\r\n    callStacked(){\r\n        cbs.forEach(cb => cb());\r\n        cbs = [];\r\n    }\r\n}","import Bucket from './Bucket';\r\nimport globals from './globals';\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\n\r\nexport default {\r\n    x: 0,\r\n    y: 0,\r\n    color: -1,\r\n    brushSize: 1,\r\n    secondCol: -1,\r\n    id: -1,\r\n    init(){\r\n        this.loadColors();\r\n        this.switchColor(this.color, true);\r\n        this.switchSecondColor(this.secondCol, true);\r\n    },\r\n    loadColors(){\r\n        this.color = +getOrDefault('color1', -1, true);\r\n        this.secondCol = +getOrDefault('color2', -1, true);\r\n    },\r\n    switchColor(id, initial=false){\r\n        if(this.color === id && !initial)\r\n            id = this.color = -1;\r\n        else\r\n            this.color = id;\r\n        globals.fxRenderer.needRender = true;\r\n        globals.renderer.preRender();\r\n\r\n        $('.paletteColor.selected').removeClass('selected');\r\n        if(id !== -1){\r\n            $('#col' + id).addClass('selected');\r\n        }\r\n\r\n        setLS('color1', id, true);\r\n    },\r\n    switchSecondColor(id, initial){\r\n        if(this.secondCol === id && !initial)\r\n            id = this.secondCol = -1;\r\n        else\r\n            this.secondCol = id;\r\n        globals.fxRenderer.needRender = true;\r\n        globals.renderer.preRender();\r\n\r\n        $('.paletteColor.selectedSecond').removeClass('selectedSecond');\r\n        if(id !== -1){\r\n            $('#col' + id).addClass('selectedSecond');\r\n        }\r\n\r\n        setLS('color2', id, true);\r\n    },\r\n    swapColors(){\r\n        const temp = this.color;\r\n        this.switchColor(this.secondCol);\r\n        this.switchSecondColor(temp);\r\n    },\r\n    resetColors(){\r\n        this.switchColor(-1);\r\n        this.switchSecondColor(-1);\r\n    },\r\n    bucket: null,\r\n    updateBucket([delay, max]) {\r\n        this.bucket = new Bucket(delay, max);\r\n    },\r\n    placed: [],\r\n    maxPlaced: isNaN(+localStorage['maxPlaced']) ? 5000 : +localStorage['maxPlaced'],\r\n    placedCount: +getLS('placedCount', true) || 0\r\n}","// change utils/recorder if changes\r\n\r\nexport const OPCODES = {\r\n    chunk:       0x0,\r\n    place:       0x1,\r\n    online:      0x2,\r\n    canvas:      0x3,\r\n    pixels:      0x4,\r\n    captcha:     0x5,\r\n    ping:        0x6,\r\n    placeBatch:  0x7,\r\n    updateRadio: 0x8\r\n}\r\n\r\nexport const STRING_OPCODES = {\r\n    error: 'e',\r\n    userJoin: 'u',\r\n    userLeave: 'l',\r\n    subscribeChat: 's',\r\n    chatMessage: 'c',\r\n    alert: 'a',\r\n    me: 'm',\r\n    reload: 'r',\r\n    reloadChunks: 'rc'\r\n}\r\n\r\n// max coords is up to 4096\r\nexport function packPixel(x, y, col) {\r\n    return (x << 12 | y) << 7 | col\r\n}\r\n\r\nexport function unpackPixel(num) {\r\n    return [\r\n        num >>> 19,\r\n        num >>> 7 & 0xFFF,\r\n        num & 0b1111111\r\n    ]\r\n}","import camera from './camera';\r\nimport {\r\n    halfMap\r\n} from './utils/misc'\r\n\r\nlet winWid = window.innerWidth / 2,\r\n    winHei = window.innerHeight / 2;\r\n\r\nwindow.addEventListener('resize', () => {\r\n    winWid = window.innerWidth / 2;\r\n    winHei = window.innerHeight / 2;\r\n})\r\n\r\nimport {\r\n    urlInput,\r\n    xInput,\r\n    yInput,\r\n    opacInput\r\n} from './elements';\r\n\r\nconst widthRegEx = /width=(\\d+)$/;\r\n\r\nexport default {\r\n    element: document.getElementById('template'),\r\n\r\n    x: 0,\r\n    y: 0,\r\n\r\n    render() {\r\n        let camX = camera.x + halfMap[0] - this.x - (winWid / camera.zoom);\r\n        let camY = camera.y + halfMap[1] - this.y - (winHei / camera.zoom);\r\n        \r\n        camX = Math.floor(-camX * camera.zoom);\r\n        camY = Math.floor(-camY * camera.zoom);\r\n\r\n        this.element.style.left = camX + 'px';\r\n        this.element.style.top = camY + 'px';\r\n        this.element.style.transform = 'scale(' + camera.zoom + ',' + camera.zoom + ')';\r\n    },\r\n\r\n    update(){\r\n        this.x = parseInt(xInput.val(), 10);\r\n        this.y = parseInt(yInput.val(), 10);\r\n\r\n        this.element.style.opacity = opacInput.val();\r\n\r\n        const url = urlInput.val();\r\n        let match;\r\n        if(match = url.match(widthRegEx)){\r\n            this.element.style.width = match[1] + 'px';\r\n        }else{\r\n            this.element.style.width = 'unset';\r\n        }\r\n\r\n        this.element.src = url;\r\n    },\r\n\r\n    get url(){\r\n        return urlInput.val()\r\n    },\r\n\r\n    get opacity(){\r\n        return +opacInput.val()\r\n    },\r\n    set opacity(val){\r\n        opacInput.val(val);\r\n    }\r\n}","import Tool from './Tool'\r\nimport globals from './globals'\r\n\r\nimport shapes from './utils/shapes';\r\nimport {\r\n    inBounds\r\n} from './utils/camera';\r\nimport {\r\n    boardToScreenSpace,\r\n    screenToBoardSpace\r\n} from './utils/conversions';\r\n\r\nimport player from './player'\r\nimport {\r\n    FX\r\n} from './fxcanvas'\r\nimport {\r\n    boardHeight,\r\n    boardWidth,\r\n    canvasId,\r\n    chunkSize,\r\n    hexPalette,\r\n    palette\r\n} from './config'\r\nimport camera from './camera'\r\nimport {\r\n    chatInput\r\n} from './elements'\r\nimport {\r\n    placePixel,\r\n    toggleChat,\r\n    toggleTopMenu,\r\n    toggleEverything,\r\n    placePixels,\r\n    updateTemplate,\r\n    updateBrush,\r\n    showProtected,\r\n    changeSelector,\r\n    apiRequest\r\n} from './actions'\r\nimport { ROLE } from './constants';\r\n\r\nimport clickerIcon from '../img/toolIcons/clicker.png'\r\nimport moveIcon from '../img/toolIcons/move.png'\r\nimport floodfillIcon from '../img/toolIcons/floodfill.png'\r\n// import pipetteIcon from '../img/toolIcons/pipette.png'\r\nimport lineIcon from '../img/toolIcons/line.png'\r\nimport protectIcon from '../img/toolIcons/protect.png'\r\nimport revertIcon from '../img/toolIcons/revert.png'\r\n\r\nimport template from './template';\r\nimport me from './me';\r\nimport { closestColor } from './utils/color';\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport { htmlspecialchars, testPointInPolygon } from './utils/misc';\r\nimport Bucket from './Bucket';\r\nimport { map } from './utils/math';\r\n\r\nimport min5fontSheet from '../font/pixel/min5.png';\r\nimport min5fontInfo from '../font/pixel/min5.txt';\r\nimport MiniWindow from './MiniWindow';\r\n\r\nconst mobile = globals.mobile;\r\n\r\nfunction getPixel(x, y) {\r\n    return globals.chunkManager.getChunkPixel(x, y)\r\n}\r\n\r\nfunction getProtect(x, y) {\r\n    return globals.chunkManager.getProtect(x, y)\r\n}\r\n\r\nfunction isOdd(x, y) {\r\n    return ((x + y) % 2) === 0\r\n}\r\n\r\nfunction getCurCol() {\r\n    if (player.secondCol === -1) {\r\n        return ~player.color ? player.color : -1;\r\n    }\r\n    if (player.color === -1) return player.secondCol;\r\n\r\n    return isOdd(player.x, player.y) ? player.color : player.secondCol\r\n}\r\n\r\nfunction getColByCord(x, y, first = player.color, second = player.secondCol) {\r\n    if (second === -1) return first;\r\n    if (first === -1) return second;\r\n\r\n    return isOdd(x, y) ? first : second\r\n}\r\n\r\nfunction checkBounds(x, y) {\r\n    return (x >= 0 && x < boardWidth && y >= 0 && y < boardHeight)\r\n}\r\n\r\nlet tmLoaded = false;\r\nlet onTMID = setInterval(() => {\r\n    if (globals.toolManager) {\r\n        clearInterval(onTMID);\r\n        _onTmLoaded();\r\n    }\r\n}, 5);\r\nlet tmCallbacks = [];\r\nfunction _onTmLoaded() {\r\n    tmLoaded = true;\r\n    tmCallbacks.forEach(cb => cb(globals.toolManager));\r\n    tmCallbacks = [];\r\n}\r\nfunction onToolManager(cb) {\r\n    if (tmLoaded) cb(globals.toolManager);\r\n    else tmCallbacks.push(cb)\r\n}\r\n\r\n// fxRenderer is loaded later then tools\r\n// so here is workaround\r\nlet _deferredFX = [];\r\nfunction addFX(fx, layer) {\r\n    if (globals.fxRenderer) {\r\n        globals.fxRenderer.add(fx, layer);\r\n    } else _deferredFX.push([fx, layer]);\r\n}\r\n\r\nfunction removeFX(fx) {\r\n    globals.fxRenderer.remove(fx);\r\n}\r\n\r\nlet fxi = setInterval(() => {\r\n    if (globals.fxRenderer) {\r\n        clearInterval(fxi);\r\n        for (let [fx, layer] of _deferredFX) {\r\n            addFX(fx, layer);\r\n        }\r\n        _deferredFX = [];\r\n    }\r\n}, 5);\r\n\r\nfunction renderFX() {\r\n    globals.fxRenderer.needRender = true;\r\n}\r\n\r\nfunction protectPixels(pixels) {\r\n    globals.socket.sendPixels(pixels, true);\r\n}\r\n\r\nclass Clicker extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this._pendingPixels = {};\r\n        this.minZoom = 2;\r\n\r\n        this.on('down', this.down)\r\n        this.on('up', this.up)\r\n        this.on('move', this.move)\r\n        this.on('leave', this.up)\r\n        this.on('_gesture', this.ongesture);\r\n\r\n        onToolManager(() => {\r\n            // mobile is already subscribed to pointer events\r\n            // so this will duplicate them\r\n            if (!mobile) {\r\n                globals.eventManager.on('mousedown', this.mousedown.bind(this));\r\n                globals.eventManager.on('mouseup', this.mouseup.bind(this));\r\n            }\r\n        })\r\n\r\n        this.clrInterval = setInterval(() => {\r\n            if (this.clearPending())\r\n                renderFX();\r\n        }, 250);\r\n\r\n        // pending pixels debug visualizer\r\n        this.fx = new FX(this.render.bind(this));\r\n        //addFX(this.fx);\r\n    }\r\n\r\n    // mouse zone\r\n    mousedown(e) {\r\n        if (e.button !== 0) return;\r\n        this.screenPos = [e.clientX, e.clientY];\r\n    }\r\n    mouseup(e) {\r\n        if (e.button !== 0 || !this.screenPos) return;\r\n        const dx = Math.abs(e.clientX - this.screenPos[0]);\r\n        const dy = Math.abs(e.clientY - this.screenPos[1]);\r\n        if (dx > 5 || dy > 5) return;\r\n\r\n        const [x, y] = [player.x, player.y];\r\n        const color = getColByCord(x, y);\r\n        if (this.checkPixel(x, y) && ~color)\r\n            placePixel(player.x, player.y, getColByCord(x, y));\r\n    }\r\n    // end of mouse zone\r\n\r\n    down(e) {\r\n        this.lastPos = [player.x, player.y];\r\n        this.screenPos = [e.clientX, e.clientY];\r\n\r\n        if (this.mouseIsDown || camera.zoom < this.minZoom) return;\r\n\r\n        this.mouseIsDown = true;\r\n\r\n        if (!mobile)\r\n            this.emit('move', {});\r\n        else {\r\n            this.pointerId = e.pointerId;\r\n        }\r\n    }\r\n    up(e) {\r\n        if (this.mouseIsDown) {\r\n            if (mobile)\r\n                this.emit('move', e, true);\r\n            this.mouseIsDown = false;\r\n        }\r\n    }\r\n\r\n    ongesture() {\r\n        this.mouseIsDown = false;\r\n        this.lastPos = null;\r\n    }\r\n\r\n    checkPixel(x, y) {\r\n        const key = `${x},${y}`;\r\n        const myColor = getColByCord(x, y);\r\n\r\n        const pixel = getPixel(x, y),\r\n            isProtected = getProtect(x, y);\r\n        if (pixel === myColor || pixel === -1 || (isProtected && me.role < ROLE.MOD)) return;\r\n\r\n        if (this._pendingPixels[key] && this._pendingPixels[key][0] === myColor) return;\r\n        this._pendingPixels[key] = [myColor, Date.now()];\r\n\r\n        return true\r\n    }\r\n\r\n    /*\r\n    */\r\n    move(e, isUp = false) {\r\n        if (e.gesture) {\r\n            // if gesture is started, we reset mousedown state\r\n            this.ongesture();\r\n            return\r\n        }\r\n        if (!this.mouseIsDown ||\r\n            e.gesture ||\r\n            getCurCol() === -1) return;\r\n\r\n        // mobile and same pointerid as at down but also not initiated by 'up' event\r\n        if (mobile && this.pointerId !== e.pointerId)\r\n            return\r\n\r\n        const screenX = e.clientX,\r\n            screenY = e.clientY;\r\n\r\n        const dx = Math.abs(screenX - this.screenPos[0]);\r\n        const dy = Math.abs(screenY - this.screenPos[1]);\r\n\r\n        if (dx < 5 && dy < 5 && !isUp) {\r\n            return;\r\n        }\r\n\r\n        let [x, y] = [player.x, player.y];\r\n\r\n        let line = shapes.line(this.lastPos[0], this.lastPos[1], x, y);\r\n        this.lastPos = [x, y];\r\n\r\n        let circle = [[0, 0]];\r\n        if (player.brushSize !== 1) {\r\n            circle = globals.renderer.preRendered.brush.circle;\r\n        }\r\n\r\n        for (let [x, y] of line) {\r\n            let pixels = [];\r\n\r\n            if (!this.checkAllowance(circle.length)) return;\r\n            circle.forEach(([cx, cy]) => {\r\n                let _x = x + cx;\r\n                let _y = y + cy;\r\n                if (this.checkPixel(_x, _y)) {\r\n                    const myColor = getColByCord(_x, _y); // duplicate\r\n                    pixels.push([_x, _y, myColor]);\r\n                }\r\n            })\r\n\r\n            this.place(pixels);\r\n        }\r\n    }\r\n\r\n    checkAllowance(count) {\r\n        if (player.bucket.allowance < count) {\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    place(pixels) {\r\n        if (pixels.length === 0) return;\r\n\r\n        player.bucket.spend(pixels.length)\r\n\r\n        if (pixels.length == 1) {\r\n            placePixel(...pixels[0])\r\n        } else\r\n            placePixels(pixels);\r\n    }\r\n\r\n    render(ctx) {\r\n        const zoom = camera.zoom;\r\n        ctx.lineWidth = zoom / 5;\r\n        ctx.globalAlpha = .5;\r\n\r\n        for (let key of Object.keys(this._pendingPixels)) {\r\n            let [x, y] = key.split(',').map(x => parseInt(x, 10));\r\n\r\n            const color = this._pendingPixels[key][0];\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.fillStyle = hexPalette[color];\r\n\r\n            const [scrX, scrY] = boardToScreenSpace(x, y);\r\n\r\n\r\n            ctx.strokeRect(scrX, scrY, zoom, zoom);\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n\r\n        return 1\r\n    }\r\n\r\n    clearPending() {\r\n        let deletedSome = false;\r\n        Object.keys(this._pendingPixels).forEach(key => {\r\n            let timestamp = this._pendingPixels[key][1];\r\n\r\n            if (Date.now() - timestamp > 500) {\r\n                delete this._pendingPixels[key];\r\n                deletedSome = true;\r\n            }\r\n        })\r\n\r\n        return deletedSome;\r\n    }\r\n}\r\nconst clicker = new Clicker('clicker', 'Space', clickerIcon);\r\n\r\nclass Protector extends Clicker {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.minZoom = 1;\r\n\r\n        // is this unprotector\r\n        this._alt = false;\r\n        // first touch determines whether protect or not (for full down-move-up):\r\n        // protected => unprotect; unprotected => protect,\r\n        // i.e. inverts pixel state\r\n        this._mobileIsProtect = null;\r\n    }\r\n\r\n    getProtectState() {\r\n        if (mobile)\r\n            return this._mobileIsProtect;\r\n        else\r\n            return this._alt ? false : true;\r\n\r\n    }\r\n\r\n    // override Clicker's mouse events\r\n    mousedown() { }\r\n    mouseup() { }\r\n\r\n    down(e) {\r\n        if (this.mouseIsDown) return;\r\n\r\n        super.down(e);\r\n\r\n        showProtected(); // force protect visibility\r\n        this._mobileIsProtect = !getProtect(...this.lastPos);\r\n    }\r\n\r\n    checkPixel(x, y) {\r\n        const key = `${x},${y}`;\r\n        const state = this.getProtectState();\r\n\r\n        const curState = getProtect(x, y);\r\n        if (curState === state) return;\r\n\r\n        if (this._pendingPixels[key] && this._pendingPixels[key][0] === state) return;\r\n        this._pendingPixels[key] = [state, Date.now()];\r\n\r\n        return true\r\n    }\r\n\r\n    checkAllowance() { return true }\r\n\r\n    place(pixels) {\r\n        // now we should replace colors from\r\n        // clicker's move func with protect state\r\n        const state = this.getProtectState();\r\n        pixels.forEach(p => p[2] = state);\r\n        if (!pixels.length) return;\r\n\r\n        protectPixels(pixels);\r\n    }\r\n\r\n    render() { }\r\n}\r\nconst protector = new Protector('protector', 'KeyV', protectIcon, ROLE.MOD);\r\n\r\nconst altProtector = new Protector('alt protector', 'ALT+KeyV', null, ROLE.MOD);\r\naltProtector._alt = true;\r\n\r\nclass Mover extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n\r\n        this.downPos = [0, 0];\r\n        this.lastPos = [0, 0];\r\n\r\n        this.lastPlayerPos = [0, 0];\r\n\r\n        if (!mobile) {\r\n            this.fx = new FX(this.renderCursor);\r\n\r\n            addFX(this.fx);\r\n        }\r\n    }\r\n\r\n    handlers() {\r\n        // костыль\r\n        onToolManager(() => {\r\n            this.on('down', this.down);\r\n            this.on('up', this.up);\r\n            // bind to toolManager for handling not only on canvas\r\n            globals.toolManager.on('move', this.move.bind(this));\r\n            this.on('leave', this.up);\r\n        })\r\n    }\r\n\r\n    renderCursor(ctx) {\r\n        const zoom = camera.zoom;\r\n\r\n        const color = getCurCol();\r\n\r\n        if (~color && zoom > 1) {\r\n            if (player.brushSize == 1) {\r\n                let [x, y] = boardToScreenSpace(player.x, player.y);\r\n                ctx.strokeStyle = hexPalette[color];\r\n                //ctx.fillStyle = hexPalette[player.color];\r\n                ctx.lineWidth = zoom / 5;\r\n\r\n                let w, h;\r\n                let halfLineWid = ctx.lineWidth / 2;\r\n\r\n                x += halfLineWid;\r\n                y += halfLineWid;\r\n\r\n                w = zoom - ctx.lineWidth;\r\n                h = w;\r\n\r\n                //ctx.fillRect(x, y, zoom, zoom);\r\n                ctx.strokeRect(x, y, w + 1, h + 1);\r\n\r\n                //renderFX();\r\n            } else {\r\n                const [x, y] = boardToScreenSpace(player.x - player.brushSize / 2, player.y - player.brushSize / 2);\r\n                ctx.drawImage(globals.renderer.preRendered.brush.canvas, x, y)\r\n            }\r\n        }\r\n\r\n        return 1\r\n    }\r\n\r\n    down(e) {\r\n        if (e.ctrlKey) return;\r\n\r\n        this.mousedown = true;\r\n\r\n        // little workaround to keep any ui text\r\n        // unselected while canvas moves\r\n        // guess it's uneffictive\r\n        changeSelector('#ui>div>*', { 'pointer-events': 'none' })\r\n\r\n        if (!mobile) {\r\n            this.downPos = this.lastPos = [e.clientX, e.clientY]\r\n        }\r\n    }\r\n    up(e) {\r\n        if (e.ctrlKey) return;\r\n\r\n        this.mousedown = false;\r\n        changeSelector('#ui>div>*', { 'pointer-events': 'all' })\r\n\r\n        if (!mobile && this.moveThresold() && e.type !== 'mouseleave') {\r\n            // right/middle/anything\r\n            if (e instanceof MouseEvent && e.button != 0) return;\r\n        }\r\n    }\r\n\r\n    move(e) {\r\n        // for template mover\r\n        if (e.ctrlKey) return;\r\n\r\n        // idk what was purpose of this\r\n        // but i actually need to render fx on mobiles\r\n        // if (!mobile) {\r\n        if (this.lastPlayerPos[0] != player.x ||\r\n            this.lastPlayerPos[1] != player.y ||\r\n            this.mousedown) {\r\n            renderFX();\r\n        }\r\n\r\n        this.lastPlayerPos = [player.x, player.y];\r\n        // }\r\n\r\n        if (!this.mousedown) return;\r\n\r\n        if (!mobile) {\r\n            this.lastPos = [e.clientX, e.clientY]\r\n\r\n            if (this.moveThresold())\r\n                return\r\n        }\r\n\r\n        // now works without pixel ratio, i'll keep it here if not\r\n        camera.moveTo(-e.movementX / camera.zoom /* / devicePixelRatio */, -e.movementY / camera.zoom /* / devicePixelRatio */);\r\n    }\r\n\r\n    moveThresold() {\r\n        return (Math.abs(this.downPos[0] - this.lastPos[0]) < 5 &&\r\n            Math.abs(this.downPos[1] - this.lastPos[1]) < 5)\r\n    }\r\n}\r\nconst mover = new Mover('mover', null, moveIcon);\r\n\r\nclass FloodFill extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.on('up', this.up);\r\n        this.on('down', this.down);\r\n        this.on('leave', this.up);\r\n\r\n        this.on('tick', this.tick);\r\n\r\n        this.previewing = false;\r\n        this.fx = null;\r\n        this.prevStack = [];\r\n    }\r\n\r\n    up(e, isCancel) {\r\n        if (this.active) { // stop and return\r\n            this.active = false;\r\n            return\r\n        }\r\n\r\n        if (this.previewing) {\r\n            this.fx.remove();\r\n            renderFX();\r\n            this.previewing = false;\r\n        } else return; // means that key wasn't pressed\r\n\r\n\r\n        if (isCancel)\r\n            return;\r\n\r\n        const cord = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (getColByCord(...cord) === -1 || !inBounds(...cord) || e.type === 'mouseleave') {\r\n            return\r\n        }\r\n\r\n        this.active = true;\r\n\r\n        this.stack = [\r\n            [player.x, player.y]\r\n        ];\r\n\r\n        this.playerCol = player.color;\r\n        this.secondPlayerCol = player.secondCol;\r\n        this.fillingCol = getPixel(player.x, player.y);\r\n    }\r\n\r\n    down(e) {\r\n        // preview floodfill\r\n        if (e.repeat || this.previewing || this.active) {\r\n            return\r\n        }\r\n\r\n        const cord = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (getColByCord(...cord) === -1 || !inBounds(...cord)) {\r\n            return\r\n        }\r\n        let _lastX, _lastY;\r\n\r\n        restart.apply(this);\r\n\r\n        this.showedPixels = [];\r\n        this.fillingCol = getPixel(player.x, player.y);\r\n\r\n        let fx = new FX(tick.bind(this));\r\n        addFX(fx, 0);\r\n\r\n        this.fx = fx;\r\n\r\n        //globals.renderer.needRender = true;\r\n\r\n        this.previewing = true;\r\n\r\n        function restart() {\r\n            this.prevStack = [\r\n                [player.x, player.y]\r\n            ];\r\n            this.showedPixels = [];\r\n\r\n            _lastX = player.x;\r\n            _lastY = player.y;\r\n\r\n            this.playerCol = player.color;\r\n            this.secondPlayerCol = player.secondCol;\r\n            this.fillingCol = getPixel(player.x, player.y);\r\n        }\r\n\r\n        function paint() {\r\n            if (!this.prevStack.length) return 1;\r\n\r\n            let [x, y] = this.prevStack.pop();\r\n\r\n            let color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n            let tileCol = getPixel(x, y);\r\n            let painted = this.showedPixels.indexOf(x + ',' + y) !== -1;\r\n\r\n            if (painted || tileCol === color || tileCol !== this.fillingCol || !inBounds(x, y)) {\r\n                return 0\r\n            }\r\n\r\n            this.showedPixels.push(x + ',' + y);\r\n\r\n            let top = this.checkP(x, y - 1);\r\n            let bottom = this.checkP(x, y + 1);\r\n            let left = this.checkP(x - 1, y);\r\n            let right = this.checkP(x + 1, y);\r\n            if (top && left) {\r\n                this.checkP(x - 1, y - 1);\r\n            }\r\n            if (top && right) {\r\n                this.checkP(x + 1, y - 1);\r\n            }\r\n            if (bottom && left) {\r\n                this.checkP(x - 1, y + 1);\r\n            }\r\n            if (bottom && right) {\r\n                this.checkP(x + 1, y + 1);\r\n            }\r\n\r\n            return 0\r\n        }\r\n\r\n        function tick(ctx) {\r\n            if (globals.mobile && globals.toolManager.tool !== this) {\r\n                this.up({}, true);\r\n                return 1;\r\n            }\r\n            if (player.x != _lastX || player.y != _lastY) {\r\n                restart.call(this);\r\n            }\r\n            if (getCurCol() === -1) return 1;\r\n\r\n            let res = 0;\r\n            for (let i = 0; i < 700 && res == 0; i++)\r\n                res = paint.call(this);\r\n\r\n\r\n            ctx.strokeWidth = camera.zoom;\r\n            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)\r\n\r\n            this.showedPixels.forEach((p, i) => {\r\n                let [x, y] = p.split(',').map(x => parseInt(x, 10));\r\n\r\n                let alpha = 1;\r\n                let len = this.showedPixels.length\r\n                if (len >= 100 && i < len / 2) {\r\n                    alpha = 1 - (((len / 2) - i) / (len / 2))\r\n                    if (alpha <= 0) return;\r\n                }\r\n                ctx.globalAlpha = alpha;\r\n\r\n                const color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n                ctx.strokeStyle = hexPalette[color];\r\n\r\n                let [absX, absY] = boardToScreenSpace(x, y);\r\n                ctx.strokeRect(absX, absY, camera.zoom, camera.zoom);\r\n            });\r\n\r\n            return res\r\n        }\r\n    }\r\n\r\n    checkP(x, y) {\r\n        if (getPixel(x, y) !== this.fillingCol) return false;\r\n        this.prevStack.unshift([x, y]);\r\n        return true\r\n    }\r\n\r\n    tick() {\r\n        if (!this.active) return;\r\n\r\n        for (let i = 0; i < 15 && this.stack.length; i++) {\r\n            let nextX = this.stack[this.stack.length - 1][0];\r\n\r\n            if (!player.bucket.spend(1)) break;\r\n\r\n            let [x, y] = this.stack.pop();\r\n\r\n            let color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n            let tileCol = getPixel(x, y);\r\n\r\n            if (tileCol === color || tileCol !== this.fillingCol || !inBounds(x, y)) {\r\n                continue\r\n            }\r\n\r\n            //this.stack.push([x, y]);\r\n\r\n            let top = this.check(x, y - 1);\r\n            let bottom = this.check(x, y + 1);\r\n            let left = this.check(x - 1, y);\r\n            let right = this.check(x + 1, y);\r\n            if (top && left) {\r\n                this.check(x - 1, y - 1);\r\n            }\r\n            if (top && right) {\r\n                this.check(x + 1, y - 1);\r\n            }\r\n            if (bottom && left) {\r\n                this.check(x - 1, y + 1);\r\n            }\r\n            if (bottom && right) {\r\n                this.check(x + 1, y + 1);\r\n            }\r\n\r\n            placePixel(x, y, color);\r\n        }\r\n\r\n        if (!this.stack.length) return this.active = false;\r\n    }\r\n\r\n    check(x, y) {\r\n        if (getPixel(x, y) !== this.fillingCol) return false;\r\n        this.stack.unshift([x, y]);\r\n        return true\r\n    }\r\n}\r\nconst floodfill = new FloodFill('floodfill', 'KeyF', floodfillIcon);\r\n\r\nclass Pipette extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        if (mobile) {\r\n            return\r\n            this.on('down', this.mobileDown.bind(this));\r\n            this.on('up', this.mobileUp.bind(this));\r\n        } else\r\n            this.on('down', this.down);\r\n    }\r\n\r\n    down(e) {\r\n        const color = getPixel(player.x, player.y);\r\n\r\n        if (color === -1) return;\r\n\r\n        if (e.__alt)\r\n            player.switchSecondColor(color);\r\n        else\r\n            player.switchColor(color);\r\n\r\n        renderFX();\r\n    }\r\n\r\n    // separate handlers for handling both\r\n    // primary and seconary colors on mobiles\r\n\r\n    // DISABLED FOR THE MOMENT\r\n    // is pipette really need in game\r\n    // with restricted palette .. ?\r\n    mobileDown() {\r\n        this.downCord = [player.x, player.y];\r\n        this.downTime = Date.now();\r\n    }\r\n\r\n    mobileUp() {\r\n        let lastCord = [player.x, player.y];\r\n        let lastTime = Date.now();\r\n\r\n        this.downCord = null;\r\n        this.downTime = null;\r\n    }\r\n}\r\nconst pipette = new Pipette('pipette', 'KeyC', /*pipetteIcon*/);\r\n\r\nconst altPipette = new Pipette('alt pipette', 'ALT+KeyC');\r\naltPipette.off('down', altPipette.down);\r\naltPipette.on('down', (e) => {\r\n    e.__alt = true;\r\n    altPipette.down.call(altPipette, e)\r\n});\r\n\r\nclass Line extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.drawLength = JSON.parse(getOrDefault('drawLineLen', false));;\r\n\r\n        onToolManager(() => {\r\n            this.handlers();\r\n        })\r\n    }\r\n\r\n    handlers() {\r\n        let startCoords, endCoords, lastCoords = [],\r\n            fx, isDown = false,\r\n            line,\r\n            startColor1, startColor2, startCircleSize;\r\n\r\n        function down() {\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            startCoords = [player.x, player.y];\r\n\r\n            [startColor1, startColor2] = [player.color, player.secondCol];\r\n\r\n            startCircleSize = 1;\r\n            if (player.brushSize !== 1) {\r\n                startCircleSize = globals.renderer.preRendered.brush.circle.length;\r\n            }\r\n\r\n            //this.emit('move');\r\n        }\r\n\r\n        function move(e) {\r\n            if (!isDown || !startCoords) return;\r\n            if (e.gesture) {\r\n                isDown = false;\r\n                return startCoords = null;\r\n            };\r\n\r\n            endCoords = [player.x, player.y];\r\n\r\n            if (player.color === -1 && player.secondCol === -1) {\r\n                fx && removeFX(fx);\r\n                return;\r\n            }\r\n            if (endCoords[0] != lastCoords[0] || endCoords[1] != lastCoords[1]) {\r\n                lastCoords = endCoords;\r\n\r\n                const line = buildLine(...startCoords, ...endCoords)\r\n\r\n                fx && removeFX(fx);\r\n                fx = new FX((ctx) => {\r\n                    ctx.globalAlpha = .5;\r\n\r\n                    // draw line pixel by pixel\r\n                    line.forEach(([x, y]) => {\r\n                        const color = getColByCord(x, y);\r\n                        ctx.fillStyle = hexPalette[color];\r\n\r\n                        let [screenX, screenY] = boardToScreenSpace(x, y);\r\n                        ctx.fillRect(screenX, screenY, camera.zoom, camera.zoom);\r\n                    });\r\n\r\n                    // draw (non pixelated) black line over the line\r\n                    ctx.strokeStyle = '#000000';\r\n                    ctx.lineWidth = camera.zoom / 5;\r\n\r\n                    const startScreen = boardToScreenSpace(...line[0]);\r\n                    const endScreen = boardToScreenSpace(...line[line.length - 1]);\r\n\r\n                    ctx.beginPath();\r\n                    ctx.lineCap = 'round'\r\n                    ctx.moveTo(...startScreen.map(z => z += camera.zoom / 2));\r\n                    ctx.lineTo(...endScreen.map(z => z += camera.zoom / 2));\r\n\r\n                    // draw line length text\r\n\r\n                    function angle(cx, cy, ex, ey) {\r\n                        var dy = ey - cy;\r\n                        var dx = ex - cx;\r\n                        var theta = Math.atan2(dy, dx); // range (-PI, PI]\r\n                        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]\r\n                        //if (theta < 0) theta = 360 + theta; // range [0, 360)\r\n                        return theta;\r\n                    }\r\n\r\n                    function toRadians(angle) {\r\n                        return angle * (Math.PI / 180);\r\n                    }\r\n\r\n                    if (this.drawLength && line.length > 1) {\r\n                        let [startPosX, startPosY] = startScreen;\r\n                        let [endPosX, endPosY] = endScreen;\r\n\r\n                        let minX = Math.min(startPosX, endPosX);\r\n                        let minY = Math.min(startPosY, endPosY);\r\n                        let maxX = Math.max(startPosX, endPosX);\r\n                        let maxY = Math.max(startPosY, endPosY);\r\n\r\n                        let [midPosX, midPosY] = [maxX - Math.abs(maxX - minX) / 2, maxY - Math.abs(maxY - minY) / 2];\r\n\r\n                        // append half-pixel offset to center text in the middle\r\n                        midPosX += camera.zoom * 0.5;\r\n                        midPosY += camera.zoom * 0.5;\r\n\r\n                        let lineAngle = angle(startPosX, startPosY, endPosX, endPosY);\r\n                        if (lineAngle > 90) {\r\n                            lineAngle -= 180;\r\n                        } else if (lineAngle < -90) {\r\n                            lineAngle += 180;\r\n                        }\r\n\r\n                        let lineRads = toRadians(lineAngle);\r\n                        let offsetX = 40 * Math.sin(lineRads);\r\n                        let offsetY = 40 * Math.cos(lineRads);\r\n\r\n                        midPosX += offsetX;\r\n                        midPosY -= offsetY;\r\n\r\n\r\n\r\n                        ctx.save();\r\n                        ctx.globalAlpha = .7;\r\n\r\n                        const fontHei = 20//camera.zoom / 1.5;\r\n                        ctx.font = fontHei + 'px sans-serif';\r\n                        ctx.fillStyle = 'black'\r\n                        ctx.strokeStyle = 'white';\r\n\r\n                        ctx.textAlign = 'center';\r\n                        ctx.textBaseline = 'middle';\r\n                        ctx.lineWidth = fontHei / 6;\r\n\r\n                        const text = line.length;\r\n                        const [x, y] = [midPosX, midPosY];\r\n\r\n                        ctx.strokeText(text, x, y);\r\n                        ctx.fillText(text, x, y);\r\n\r\n                        ctx.restore();\r\n                    }\r\n\r\n                    ctx.stroke();\r\n\r\n                    ctx.globalAlpha = 1;\r\n\r\n                    return 1\r\n                })\r\n                addFX(fx)\r\n            }\r\n        }\r\n\r\n        function buildLine(x1, y1, x2, y2) {\r\n            let circle = [[0, 0]];\r\n            if (player.brushSize !== 1) {\r\n                circle = globals.renderer.preRendered.brush.circle;\r\n            }\r\n\r\n            const w = boardWidth;\r\n\r\n            // to not repeat already added pixels\r\n            const placed = new Set();\r\n\r\n            const bruhLinePixels = [];\r\n            const linePixels = shapes.line(x1, y1, x2, y2);\r\n\r\n            // starting from the end and then\r\n            // reversing brushed array will\r\n            // make pixels rendering looking more brush-like\r\n            for (let i = linePixels.length - 1; i >= 0; i--) {\r\n                const [x, y] = linePixels[i]\r\n                circle.forEach(([offX, offY]) => {\r\n                    const absX = x + offX;\r\n                    const absY = y + offY;\r\n\r\n                    const encoded = absX + absY * w;\r\n\r\n                    if (placed.has(encoded)) return;\r\n                    placed.add((encoded));\r\n\r\n                    bruhLinePixels.push([absX, absY]);\r\n                })\r\n            }\r\n\r\n            return bruhLinePixels.reverse();\r\n        }\r\n\r\n        function up() {\r\n            this.off('tick', tick);\r\n\r\n            if (!isDown || !startCoords) return;\r\n            isDown = false;\r\n\r\n            fx && fx.remove();\r\n\r\n            if (!endCoords) endCoords = [player.x, player.y];\r\n\r\n            line = buildLine(...startCoords, ...endCoords);\r\n            startCoords = null;\r\n            endCoords = null;\r\n\r\n            renderFX();\r\n            this.on('tick', tick);\r\n        }\r\n\r\n        function tick() {\r\n            if (player.color === -1 && player.secondCol === -1) {\r\n                // assume player cancelled line\r\n                line = null;\r\n            }\r\n\r\n            let placed = 0;\r\n            while (true) {\r\n                if (!line || !line.length) {\r\n                    this.off('tick', tick);\r\n                    return;\r\n                }\r\n\r\n                const [x, y] = line.pop();\r\n                const col = getColByCord(x, y, startColor1, startColor2);\r\n\r\n                if (col === undefined || col === -1) return this.off('tick', tick);\r\n                if (!checkBounds(x, y) || getPixel(x, y) === col) continue;\r\n\r\n                if (!player.bucket.spend(1)) return line.push([x, y]);\r\n\r\n                placePixel(x, y, col);\r\n                placed++;\r\n                if (placed >= startCircleSize / 2) {\r\n                    return\r\n                }\r\n            }\r\n        }\r\n\r\n        down = down.bind(this);\r\n        move = move.bind(this);\r\n        up = up.bind(this);\r\n\r\n        tick = tick.bind(this);\r\n\r\n        this.on('down', down);\r\n        // TODO maybe it's too many listeners\r\n        // so it'd be good to make some sort of local signal\r\n        // that there was gesture (this listener is only for e.gesture to reset start coords)\r\n        globals.toolManager.on('move', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst line = new Line('line', 'ShiftLeft', lineIcon);\r\n\r\nconst cordAdd = new Tool('coords to chat', 'KeyU');\r\ncordAdd.on('up', function () {\r\n    const cords = $('#coords').text();\r\n    if (!cords.length) return;\r\n    chatInput[0].value += cords + ' ';\r\n    chatInput.trigger('focus');\r\n});\r\n\r\nconst colorSwap = new Tool('swap colors', 'KeyX');\r\ncolorSwap.on('up', player.swapColors.bind(player));\r\n\r\nconst colorDec = new Tool('left color', 'KeyA');\r\ncolorDec.on('down', function () {\r\n    let color = player.color;\r\n    if (--color < 0) color = hexPalette.length - 1;\r\n\r\n    player.switchColor(color);\r\n});\r\n\r\nconst colorInc = new Tool('right color', 'KeyS');\r\ncolorInc.on('down', function () {\r\n    let color = player.color;\r\n    if (++color >= hexPalette.length) color = 0;\r\n\r\n    player.switchColor(color);\r\n});\r\n\r\nconst chatOpac = new Tool('toggle chat', 'KeyK');\r\nchatOpac.on('down', function () {\r\n    toggleChat();\r\n});\r\n\r\nconst menuOpac = new Tool('toggle menu', 'KeyL');\r\nmenuOpac.on('down', function () {\r\n    toggleTopMenu();\r\n});\r\n\r\nconst allOpac = new Tool('toggle everything', 'Semicolon' /* ; */);\r\nallOpac.on('down', function () {\r\n    toggleEverything();\r\n});\r\n\r\nclass CtrlZ extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n    }\r\n\r\n    handlers() {\r\n        let isDown = false;\r\n\r\n        function reset() {\r\n            isDown = false;\r\n\r\n            this.off('tick', tick);\r\n            tickTime = tickMax;\r\n            lastTick = 0;\r\n        }\r\n        reset = reset.bind(this);\r\n\r\n        const down = function (e) {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (e.gesture) {\r\n                return reset();\r\n            }\r\n\r\n            // i know about e.repeat\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            tick();\r\n            this.on('tick', tick);\r\n        }.bind(this);\r\n\r\n        const move = function (e) {\r\n            if (e.gesture) {\r\n                reset();\r\n            }\r\n        }.bind(this);\r\n\r\n        const up = function () {\r\n            reset();\r\n        }.bind(this);\r\n\r\n        const tickMax = 500;\r\n        const tickMin = 50;\r\n\r\n        const nocdMinTick = 2;\r\n        // ticknow = ticknow - (ts / nocdStepFactor)\r\n        // i.e ms passed since last tick divided by this factor\r\n        const nocdStepFactor = 100;\r\n\r\n        const step = 1.5;\r\n        let tickTime = tickMax;\r\n\r\n        let lastTick = 0;\r\n        const tick = function () {\r\n            const ts = Date.now() - lastTick;\r\n            if (ts < tickTime) return;\r\n            let multiTicks = ts / tickTime | 0;\r\n            // when lastTick is 0 (tool is just activated)\r\n            if (multiTicks < 0) multiTicks = 1;\r\n\r\n            lastTick = Date.now();\r\n\r\n            do {\r\n                // if (tickTime <= tickMin) {\r\n                //     if(player.bucket.delay < tickMin){\r\n                //         tickTime = Math.max(nocdMinTick, tickTime-(ts/nocdStepFactor))\r\n                //     }\r\n                // }else{\r\n                //     tickTime /= step;\r\n                // }\r\n\r\n                // instead of speeding up we'll do it only if alt pressed\r\n                const altFactor = globals.toolManager.altDown ? 0.2 : 1;\r\n                tickTime = Math.max(tickTime / step, tickMin * altFactor);\r\n\r\n                if (player.placed.length > player.maxPlaced) {\r\n                    player.placed = player.placed.slice(-player.maxPlaced);\r\n                }\r\n                if (!player.placed.length) return;\r\n                if (!player.bucket.spend(1)) return;\r\n\r\n                const [x, y, c] = player.placed.pop();\r\n\r\n                placePixel(x, y, c, false);\r\n            }\r\n            while (--multiTicks)\r\n        }.bind(this);\r\n\r\n        this.on('down', down);\r\n        globals.eventManager.on('mousemove', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst ctrlZ = new CtrlZ('ctrlZ', 'KeyZ', revertIcon);\r\n\r\nclass Grid extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.state = 0;\r\n        this.fx = null;\r\n\r\n        this.isLight = JSON.parse(getOrDefault('lightGrid', false));\r\n        this.pattern = null;\r\n\r\n        camera.on('zoom', () => {\r\n            if (this.state == 1) {\r\n                this.tryRender();\r\n            }\r\n        });\r\n\r\n        this.on('down', this.pressed.bind(this));\r\n        if (JSON.parse(getOrDefault('enableGrid', false))) {\r\n            this.show();\r\n        }\r\n    }\r\n\r\n    pressed(e) {\r\n        if (e.repeat) return;\r\n        this.toggle();\r\n    }\r\n\r\n    /**@param {CanvasRenderingContext2D} ctx*/\r\n    drawGrid(ctx) {\r\n        let [x, y] = screenToBoardSpace(0, 0),\r\n            [clientX, clientY] = boardToScreenSpace(x, y);\r\n\r\n        let { width, height } = ctx.canvas;\r\n        const zoom = camera.zoom;\r\n\r\n        // ctx.fillStyle = this.isLight ? 'white' : 'black';\r\n        ctx.fillStyle = 'rgb(127,127,127)'\r\n        ctx.globalAlpha = 0.8;\r\n\r\n        let thickInterval;\r\n        if (chunkSize % 16 == 0) thickInterval = 16;\r\n        else if (chunkSize % 10 == 0) thickInterval = 10;\r\n        else thickInterval = null;\r\n\r\n        // finally, i decided to disable this feature\r\n        thickInterval = null;\r\n\r\n        let wid = 1;\r\n\r\n        // kostyl\r\n        x--; y--;\r\n\r\n        // pixels lines\r\n        for (; clientX < width; clientX += zoom) {\r\n            x++\r\n            if (x % thickInterval == 0) wid = .7;\r\n            else wid = .7;\r\n\r\n            if (x % chunkSize == 0) wid = 1;\r\n\r\n            ctx.fillRect(clientX, 0, wid, height);\r\n        }\r\n\r\n        for (; clientY < height; clientY += zoom) {\r\n            y++\r\n            if (y % thickInterval == 0) wid = .7;\r\n            else wid = .7;\r\n\r\n            if (y % chunkSize == 0) wid = 1;\r\n\r\n            ctx.fillRect(0, clientY, width, wid);\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n    }\r\n\r\n    tryRender() {\r\n        if (!this.fx || this.fx.removed) {\r\n            this.fx = new FX(this.render.bind(this));\r\n            addFX(this.fx, 2);\r\n        }\r\n    }\r\n\r\n    toggle() {\r\n        if (this.state == 0) this.show();\r\n        else this.hide();\r\n        setLS('enableGrid', (!!this.state).toString())\r\n    }\r\n\r\n    show() {\r\n        this.state = 1;\r\n        this.tryRender();\r\n    }\r\n\r\n    hide() {\r\n        this.state = 0;\r\n        this.fx && removeFX(this.fx);\r\n    }\r\n\r\n    render(ctx) {\r\n        if (camera.zoom <= 4) return 1;\r\n\r\n        this.drawGrid(ctx);\r\n    }\r\n}\r\nconst grid = new Grid('grid', 'KeyG');\r\n\r\n// WARNING: it's not supposed to be a bot\r\n// so it won't check for connection or re-check image\r\n// write your own bots please \r\nclass Paste extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        // 0 - idle\r\n        // 1 - choosing\r\n        // 2 - placing\r\n        // 3 - drawing\r\n        this.state = 0;\r\n\r\n        this.moveFX = null;\r\n        this.drawInterval = null;\r\n\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    async down() {\r\n        if (this.state == 0 || this.state == 1) {\r\n            this.state = 1;\r\n\r\n            try {\r\n                const canvas = await this.getImage();\r\n                this.startPlace(canvas);\r\n            } catch {\r\n                this.state = 0;\r\n            }\r\n        } else if (this.state == 2) {\r\n            // this.state = 0\r\n            // this.stopPlace();\r\n        } else if (this.state == 3) {\r\n            this.state = 0;\r\n            this.stopDraw();\r\n        }\r\n    }\r\n\r\n    async getImage() {\r\n        // get file from system\r\n        const input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.accept = 'image/png';\r\n\r\n        input.click();\r\n\r\n        return new Promise((res, rej) => {\r\n            input.onchange = () => {\r\n                input.onchange = null;\r\n\r\n                if (!input.files.length || input.files[0] == \"\") {\r\n                    return rej();\r\n                }\r\n\r\n                // read first file with filereader\r\n                const reader = new FileReader();\r\n                reader.readAsDataURL(input.files[0]);\r\n\r\n                reader.onload = () => {\r\n                    // load image with \"img\" tag\r\n                    const img = new Image();\r\n                    img.src = reader.result;\r\n                    img.onload = () => {\r\n                        // draw image on canvas to get its data\r\n                        const canvas = document.createElement('canvas');\r\n                        canvas.width = img.width;\r\n                        canvas.height = img.height;\r\n\r\n                        const ctx = canvas.getContext('2d');\r\n                        ctx.drawImage(img, 0, 0);\r\n\r\n                        res(canvas);\r\n                    }\r\n                    img.onerror = rej;\r\n                }\r\n                reader.onerror = rej;\r\n            }\r\n        })\r\n    }\r\n\r\n    startPlace(canvas) {\r\n        player.resetColors();\r\n        this.state = 2;\r\n\r\n        let xPos = player.x,\r\n            yPos = player.y;\r\n\r\n        function render(ctx) {\r\n            const [x, y] = boardToScreenSpace(xPos, yPos);\r\n            const z = camera.zoom;\r\n\r\n            const opacity = map(Math.sin(Date.now() / 400), -1, 1, 0.5, 1);\r\n            ctx.globalAlpha = opacity;\r\n\r\n            ctx.save();\r\n            ctx.scale(z, z);\r\n            ctx.drawImage(canvas, x / z, y / z);\r\n            ctx.restore();\r\n\r\n            ctx.globalAlpha = 1;\r\n            return 0\r\n        }\r\n\r\n        const fx = this.moveFX = new FX(render);\r\n        addFX(fx);\r\n\r\n        function move() {\r\n            let newX = player.x,\r\n                newY = player.y;\r\n            if (newX == xPos && newY == yPos)\r\n                return;\r\n\r\n            xPos = newX;\r\n            yPos = newY;\r\n        }\r\n\r\n        let lastX, lastY;\r\n        let down = function (e) {\r\n            lastX = e.clientX;\r\n            lastY = e.clientY;\r\n        }\r\n\r\n        let up = function (e) {\r\n            if (e.button == 2) {\r\n                this.state = 0;\r\n                this.stopPlace(); off();\r\n                return;\r\n            };\r\n\r\n            let [x, y] = [e.clientX, e.clientY];\r\n            if (Math.abs(x - lastX) > 5 || Math.abs(y - lastY) > 5) return;\r\n\r\n            off();\r\n\r\n            this.stopPlace();\r\n            this.startDraw(canvas, xPos, yPos);\r\n        }\r\n        up = up.bind(this);\r\n\r\n        function off() {\r\n            globals.eventManager.off('mousedown', down);\r\n            globals.eventManager.off('mouseup', up);\r\n            globals.toolManager.off('move', move);\r\n        }\r\n\r\n        globals.eventManager.on('mousedown', down);\r\n        globals.eventManager.on('mouseup', up);\r\n        globals.toolManager.on('move', move);\r\n    }\r\n\r\n    stopPlace() {\r\n        removeFX(this.moveFX);\r\n        this.removeAllListeners('move');\r\n    }\r\n\r\n    startDraw(canvas, offx, offy) {\r\n        this.state = 3;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        const { width: w } = canvas;\r\n\r\n        let imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\r\n        let offset = -4;\r\n\r\n        function draw() {\r\n            let allowance = Math.floor(player.bucket.allowance);\r\n            if (allowance == 0) return;\r\n\r\n            let pixels = [];\r\n\r\n            let max = 13106;\r\n            if (getLS('ya', false) === 'polkovnik') {\r\n                max = 52441;\r\n            }\r\n            while (allowance > 0 && offset < imgdata.length - 4 && pixels.length < 13106) {\r\n                offset += 4;\r\n\r\n                let rgba = [\r\n                    imgdata[offset],\r\n                    imgdata[offset + 1],\r\n                    imgdata[offset + 2],\r\n                    imgdata[offset + 3],\r\n                ]\r\n\r\n                if (rgba[3] < 127) continue;\r\n\r\n                let off = offset / 4;\r\n                const x = off % w,\r\n                    y = off / w | 0;\r\n\r\n                const boardX = offx + x,\r\n                    boardY = offy + y;\r\n                if (boardX < 0 || boardX >= boardWidth ||\r\n                    boardY < 0 || boardY >= boardHeight)\r\n                    continue\r\n\r\n                const color = closestColor(rgba, palette);\r\n                const oldCol = globals.chunkManager.getChunkPixel(boardX, boardY);\r\n                if (oldCol == color) continue;\r\n\r\n                allowance--;\r\n\r\n                pixels.push([boardX, boardY, color]);\r\n            }\r\n\r\n            if (pixels.length) {\r\n                player.bucket.spend(pixels.length);\r\n                globals.socket.sendPixels(pixels);\r\n            }\r\n\r\n            if (offset >= imgdata.length - 4) {\r\n                this.state = 0;\r\n                this.stopDraw();\r\n            }\r\n        }\r\n\r\n        this.drawInterval = setInterval(draw.bind(this), 50);\r\n    }\r\n\r\n    stopDraw() {\r\n        clearInterval(this.drawInterval);\r\n    }\r\n}\r\nconst paste = new Paste('paste', 'CTRL+KeyV', null, ROLE.MOD);\r\n\r\n// TODO move it to config or globals\r\nlet tempOpacity = parseFloat(getOrDefault('template.opacity', 0.5, true));\r\nconst templateOp1 = new Tool('template 0/N opaq', 'KeyO');\r\ntemplateOp1.on('down', () => {\r\n    if (template.opacity == 0) {\r\n        template.opacity = tempOpacity;\r\n    } else {\r\n        tempOpacity = template.opacity\r\n        template.opacity = 0;\r\n    }\r\n    updateTemplate();\r\n});\r\n\r\nconst templateOp2 = new Tool('template 1/N opaq', 'KeyP');\r\ntemplateOp2.on('down', () => {\r\n    if (template.opacity == 1) {\r\n        template.opacity = tempOpacity;\r\n    } else {\r\n        tempOpacity = template.opacity\r\n        template.opacity = 1;\r\n    }\r\n    updateTemplate();\r\n});\r\n\r\nclass Square extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n    }\r\n\r\n    handlers() {\r\n        let startCoords, endCoords, lastCoords = [],\r\n            fx, isDown = false,\r\n            square,\r\n            color, color2;\r\n\r\n        function down() {\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            startCoords = [player.x, player.y];\r\n\r\n            [color, color2] = [player.color, player.secondCol];\r\n\r\n            this.emit('move');\r\n        }\r\n\r\n        function move() {\r\n            if (!isDown || !startCoords) return;\r\n\r\n            endCoords = [player.x, player.y];\r\n\r\n            if (endCoords[0] != lastCoords[0] || endCoords[1] != lastCoords[1]) {\r\n                lastCoords = endCoords;\r\n\r\n                const pixels = shapes.square(...startCoords, ...endCoords)\r\n\r\n                fx && removeFX(fx);\r\n                fx = new FX((ctx) => {\r\n                    ctx.globalAlpha = .5;\r\n\r\n                    for (let [x, y] of pixels) {\r\n                        const [sx, sy] = boardToScreenSpace(x, y);\r\n                        const color = getColByCord(x, y);\r\n                        ctx.fillStyle = hexPalette[color];\r\n                        ctx.fillRect(sx, sy, camera.zoom, camera.zoom);\r\n                    }\r\n\r\n                    ctx.globalAlpha = 1;\r\n\r\n                    return 1\r\n                })\r\n                addFX(fx)\r\n            }\r\n        }\r\n\r\n        function up() {\r\n            this.off('tick', tick);\r\n            isDown = false;\r\n\r\n            if (!startCoords) return;\r\n\r\n            fx && fx.remove();\r\n\r\n            if (!endCoords) endCoords = [player.x, player.y];\r\n\r\n            square = shapes.square(...startCoords, ...endCoords);\r\n\r\n            renderFX();\r\n\r\n            if (square.length <= 1) return;\r\n            this.on('tick', tick);\r\n        }\r\n\r\n        function tick() {\r\n            let infCd = (player.bucket.allowance === Infinity);\r\n\r\n            if (!this.lastTick) this.lastTick = Date.now();\r\n\r\n            if (infCd && Date.now() - this.lastTick < 50) return;\r\n            this.lastTick = Date.now();\r\n\r\n            // ограничитель для 0кд\r\n            let counter = 0;\r\n            let toSend = [];\r\n            while (counter < 1000) {\r\n                if (!square || !square.length) {\r\n                    this.off('tick', tick);\r\n                    break;\r\n                }\r\n\r\n                const [x, y] = square.pop();\r\n                const col = getColByCord(x, y, color, color2);\r\n\r\n                if (col === undefined || col === -1) return this.off('tick', tick);\r\n                if (!checkBounds(x, y)) continue;\r\n                if (getPixel(x, y) === col) continue;\r\n                if (!player.bucket.spend(1)) return square.push([x, y]);\r\n\r\n                counter++;\r\n\r\n                if (infCd) {\r\n                    toSend.push([x, y, col]);\r\n                } else {\r\n                    placePixel(x, y, col);\r\n                }\r\n            }\r\n\r\n            if (toSend.length) {\r\n                placePixels(toSend, true);\r\n            }\r\n        }\r\n\r\n        down = down.bind(this);\r\n        move = move.bind(this);\r\n        up = up.bind(this);\r\n\r\n        tick = tick.bind(this);\r\n\r\n        this.on('down', down);\r\n        this.on('move', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst square = new Square('square', 'KeyJ');\r\n\r\nconst incBrush = new Tool('+brush size', 'BracketRight'); // [\r\nincBrush.on('down', () => {\r\n    if (player.brushSize >= 100) return;\r\n    if (player.brushSize == 1) return updateBrush(4);\r\n    updateBrush(player.brushSize + 2);\r\n});\r\n\r\nconst decBrush = new Tool('-brush size', 'BracketLeft'); // ]\r\ndecBrush.on('down', () => {\r\n    if (player.brushSize <= 4) return updateBrush(1);\r\n    updateBrush(player.brushSize - 2);\r\n})\r\n\r\nclass Copy extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        // 0 - idle\r\n        // 1 - started selection\r\n        this.state = 0;\r\n\r\n        this.selectFX = null;\r\n\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    down(e) {\r\n        if (this.state > 0 || paste.state > 0)\r\n            return\r\n\r\n        // since default key is ctrl+c\r\n        const isTextSelected = (window.getSelection().type === 'Range');\r\n        if (isTextSelected) return;\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        camera.disableMove();\r\n        player.resetColors();\r\n        globals.elements.mainCanvas.style.cursor = 'crosshair';\r\n\r\n        this.state = 1;\r\n\r\n        let fx;\r\n        let startX, startY, endX, endY;\r\n\r\n        let altPressed = false,\r\n            lassoMode = false,\r\n            lassoPoints = [];\r\n        function keydown(e) {\r\n            if (e.key === 'Alt')\r\n                altPressed = true;\r\n        }\r\n        // function keyup(e) {\r\n        //     // tf is this ... ???\r\n        //     if (e.key === 'Alt')\r\n        //         altPressed = false;\r\n        // }\r\n\r\n        function mousedown() {\r\n            if (altPressed) {\r\n                lassoMode = true;\r\n                lassoPoints = [[player.x, player.y]];\r\n            } else {\r\n                startX = player.x;\r\n                startY = player.y;\r\n            }\r\n        }\r\n        function mousemove() {\r\n            if (lassoMode) {\r\n                let x = player.x,\r\n                    y = player.y;\r\n\r\n                lassoPoints.push([x, y]);\r\n            } else {\r\n                endX = player.x + 1;\r\n                endY = player.y + 1;\r\n            }\r\n        }\r\n        function mouseup() {\r\n            // area is selected and we can tell Paste tool to draw it\r\n            globals.elements.mainCanvas.style.cursor = '';\r\n\r\n            removeFX(fx);\r\n\r\n            globals.eventManager.off('keydown', keydown);\r\n            // globals.eventManager.off('keyup', keyup);\r\n            globals.eventManager.off('mousedown', mousedown);\r\n            globals.eventManager.off('mousemove', mousemove);\r\n            globals.eventManager.off('mouseup', mouseup);\r\n\r\n            this.state = 0;\r\n\r\n            camera.enableMove();\r\n\r\n            onSelected();\r\n        }\r\n\r\n        function render(ctx) {\r\n            ctx.save();\r\n\r\n            ctx.strokeStyle = 'gray';\r\n            ctx.lineWidth = 2;\r\n            ctx.setLineDash([3, 3]);\r\n            ctx.globalAlpha = 1;\r\n\r\n            if (lassoMode) {\r\n                ctx.beginPath();\r\n                const firstCord = boardToScreenSpace(lassoPoints[0][0], lassoPoints[0][1]);\r\n                ctx.moveTo(...firstCord);\r\n                for (let i = 1; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    ctx.lineTo(...boardToScreenSpace(...point))\r\n                }\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n            } else {\r\n                const [x1, y1] = boardToScreenSpace(startX, startY);\r\n                const [x2, y2] = boardToScreenSpace(endX, endY);\r\n                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);\r\n            }\r\n\r\n            ctx.restore();\r\n            return 1\r\n        }\r\n        fx = new FX(render);\r\n        addFX(fx);\r\n\r\n        keydown = keydown.bind(this);\r\n        // keyup = keyup.bind(this);\r\n        mousedown = mousedown.bind(this);\r\n        mousemove = mousemove.bind(this);\r\n        mouseup = mouseup.bind(this);\r\n\r\n        globals.eventManager.on('keydown', keydown);\r\n        // globals.eventManager.on('keyup', keyup);\r\n        globals.eventManager.on('mousedown', mousedown);\r\n        globals.eventManager.on('mousemove', mousemove);\r\n        globals.eventManager.on('mouseup', mouseup);\r\n\r\n\r\n        function onSelected() {\r\n            let minX, maxX, minY, maxY;\r\n            if (lassoMode) {\r\n                minX = maxX = lassoPoints[0][0];\r\n                minY = maxY = lassoPoints[0][1];\r\n                for (let i = 0; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    if (point[0] < minX)\r\n                        minX = point[0];\r\n                    if (point[0] > maxX)\r\n                        maxX = point[0];\r\n                    if (point[1] < minY)\r\n                        minY = point[1];\r\n                    if (point[1] > maxY)\r\n                        maxY = point[1];\r\n                }\r\n            } else {\r\n                if ([startX, startY, endX, endY].some(x => x === undefined))\r\n                    return;\r\n\r\n                minX = Math.min(startX, endX);\r\n                maxX = Math.max(startX, endX) + 1;\r\n                minY = Math.min(startY, endY);\r\n                maxY = Math.max(startY, endY) + 1;\r\n            }\r\n\r\n            // normalize coordinates\r\n            minX = Math.max(minX, 0);\r\n            maxX = Math.min(maxX, boardWidth);\r\n            minY = Math.max(minY, 0);\r\n            maxY = Math.min(maxY, boardHeight);\r\n\r\n            const w = maxX - minX;\r\n            const h = maxY - minY;\r\n\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n\r\n            const ctx = canvas.getContext('2d');\r\n            const data = ctx.createImageData(w, h);\r\n\r\n            // poly x coordinates and y coordinates arrays\r\n            let vertx, verty;\r\n            if (lassoMode) {\r\n                vertx = new Array(lassoPoints.length);\r\n                verty = new Array(lassoPoints.length);\r\n\r\n                for (let i = 0; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    vertx[i] = point[0];\r\n                    verty[i] = point[1];\r\n                }\r\n            }\r\n\r\n            // local canvas coordinates\r\n            for (let x = 0; x < w; x++) {\r\n                for (let y = 0; y < h; y++) {\r\n                    const i = (x + y * w) * 4;\r\n\r\n                    // absolute board coordinates\r\n                    const cx = minX + x;\r\n                    const cy = minY + y;\r\n\r\n                    if (lassoMode && !testPointInPolygon(lassoPoints.length, vertx, verty, cx, cy)) {\r\n                        continue\r\n                    }\r\n\r\n                    const colId = globals.chunkManager.getChunkPixel(cx, cy);\r\n                    const col = palette[colId];\r\n\r\n                    data.data[i] = col[0];\r\n                    data.data[i + 1] = col[1];\r\n                    data.data[i + 2] = col[2];\r\n                    data.data[i + 3] = 255;\r\n                }\r\n            }\r\n\r\n            ctx.putImageData(data, 0, 0);\r\n\r\n            // let the Paste tool do other stuff\r\n            paste.startPlace(canvas);\r\n        }\r\n    }\r\n}\r\nconst copy = new Copy('copy', 'CTRL+KeyC', null, ROLE.MOD);\r\n\r\nconst pixelInfo = new Tool('pixel info', 'KeyI');\r\n\r\nlet last = null, pinfoFx = null\r\nfunction removeLast() {\r\n    if (last) {\r\n        last.remove();\r\n        last = null;\r\n    }\r\n    if (pinfoFx) {\r\n        pinfoFx.remove();\r\n        pinfoFx = null;\r\n    }\r\n}\r\nglobals.eventManager.on('mouseup', removeLast);\r\n\r\npixelInfo.on('up', async () => {\r\n    removeLast()\r\n\r\n    const [x, y] = [player.x, player.y];\r\n\r\n    const resp = await apiRequest(`/pixelInfo?canvas=${canvasId}&x=${x}&y=${y}`);\r\n    const data = await resp.json();\r\n    if (!data || !data.type) return;\r\n\r\n    const el = $('<div class=\"infoBubble\"><span style=\"user-select:text\"></span></div>');\r\n    last = el;\r\n\r\n    const coordsLegend = $('<div>');\r\n    coordsLegend[0].style.cssText =\r\n        `position: absolute;\r\n    top: -7px;\r\n    left: 0;\r\n    width: 100%;\r\n    font-size: 14px;\r\n    font-weight: bold;\r\n    text-shadow: rgb(255 255 255) -1px 1px 0px, rgb(255 255 255) 1px 1px 0px, rgb(255 255 255) 1px -1px 0px, rgb(255 255 255) -1px -1px 0px;\r\n    text-align: center;`\r\n    coordsLegend.text(`(${x}, ${y})`)\r\n\r\n    el.append(coordsLegend);\r\n\r\n    let text = '';\r\n\r\n    if (data.type === 'UID') {\r\n        const sanitizedName = htmlspecialchars(data.placer.nick);\r\n\r\n        text += '<b>UID</b>&nbsp;' + data.placer.id + '<br>',\r\n            text += '<b>name</b>&nbsp;' + sanitizedName;\r\n    } else {\r\n        text += `<b>${data.type}</b>`;\r\n        if (data.placer) {\r\n            text += '&nbsp;' + data.placer\r\n        }\r\n    }\r\n\r\n    $('span', el).html(text);\r\n\r\n    $('body').append(el);\r\n\r\n    const w = el[0].clientWidth;\r\n    const h = el[0].clientHeight;\r\n\r\n    function fixPos() {\r\n        const [clientX, clientY] = boardToScreenSpace(x, y);\r\n        const posX = clientX + (camera.zoom / 2) - (w / 2)\r\n        const posY = clientY - h - 11;\r\n\r\n        el.css('top', posY).css('left', posX);\r\n\r\n        return 1;\r\n    }\r\n    fixPos();\r\n\r\n\r\n    pinfoFx = new FX(() => {\r\n        fixPos();\r\n    })\r\n    addFX(pinfoFx, 2);\r\n});\r\n\r\nexport class PixelFont {\r\n    static defaultVSpacing = 1;\r\n\r\n    constructor(imagePath, infoPath) {\r\n        this.imagePath = imagePath;\r\n        this.infoPath = infoPath;\r\n\r\n        this.defaultWidth = null;\r\n        this.defaultHeight = null;\r\n        this.letters = {};\r\n\r\n        this.loaded = false;\r\n        this._isLoading = false;\r\n    }\r\n\r\n    async load() {\r\n        if (this._isLoading) return;\r\n        this._isLoading = true;\r\n\r\n        try {\r\n            const fontCanvas = await new Promise((res, rej) => {\r\n                const img = new Image();\r\n\r\n                img.onload = () => {\r\n                    const canvas = document.createElement('canvas');\r\n\r\n                    canvas.width = img.width;\r\n                    canvas.height = img.height;\r\n\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n\r\n                    res(canvas);\r\n                }\r\n\r\n                img.onerror = rej;\r\n\r\n                img.src = this.imagePath;\r\n            })\r\n\r\n            const fontInfoResp = await fetch(this.infoPath);\r\n            const fontInfo = await fontInfoResp.json();\r\n\r\n            const defaultWidth = fontInfo.defaultWidth;\r\n            this.defaultWidth = defaultWidth;\r\n            const height = fontInfo.fixedHeight;\r\n            this.defaultHeight = height;\r\n\r\n            const fontCanvasCtx = fontCanvas.getContext('2d');\r\n            this.letters = {};\r\n\r\n            let offsetX = 0;\r\n            for (let letter of fontInfo.letters) {\r\n                const {\r\n                    letter: letterSymbol,\r\n                    width = defaultWidth\r\n                } = letter;\r\n\r\n                const slice = fontCanvasCtx.getImageData(offsetX, 0, width, height);\r\n                this.letters[letterSymbol] = slice;\r\n\r\n                // extra 1 because it's one white pixel before each next letter\r\n                offsetX += width + 1;\r\n            }\r\n        } catch (error) {\r\n            this._isLoading = false;\r\n            throw error\r\n        }\r\n\r\n        this._isLoading = false;\r\n        this.loaded = true;\r\n    }\r\n\r\n    drawText(text, color='black') {\r\n        if(!this.loaded) throw new Error('font not loaded');\r\n\r\n        text = text.toUpperCase();\r\n\r\n        const {\r\n            width: textWidth,\r\n            height: textHeight\r\n        } = this.measureText(text);\r\n\r\n        if(textWidth == 0 || textHeight == 0){\r\n            return null;\r\n        }\r\n\r\n        const colorCanvas = document.createElement('canvas');\r\n        const textCanvas = document.createElement('canvas');\r\n\r\n        colorCanvas.width = textCanvas.width = textWidth;\r\n        colorCanvas.height = textCanvas.height = textHeight;\r\n\r\n        const colorCanvasCtx = colorCanvas.getContext('2d');\r\n        const textCanvasCtx = textCanvas.getContext('2d');\r\n\r\n        const textLetters = text.split('');\r\n        let cursorX = 0, cursorY = 0;\r\n        for(let letter of textLetters){\r\n            if(letter == '\\n'){\r\n                cursorY += this.defaultHeight + PixelFont.defaultVSpacing;\r\n                cursorX = 0;\r\n                continue\r\n            }\r\n\r\n            if(letter == ' '){\r\n                cursorX += this.defaultWidth;\r\n                continue\r\n            }\r\n\r\n            let letterImData = this.letters[letter];\r\n            if(!letterImData){\r\n                cursorX += this.defaultWidth;\r\n                continue\r\n            }\r\n\r\n            textCanvasCtx.putImageData(letterImData, cursorX, cursorY);\r\n            cursorX += letterImData.width + 1; // 1 is the constant spacing\r\n        }\r\n\r\n        // first, we draw text canvas shaped, colored rect \r\n        // then we will put the text on top of it, using\r\n        // globalComposite property.\r\n        // this will keep only those pixels of colored rect, in which\r\n        // letters are. this will \"color\" the letters in the color of the rect\r\n        colorCanvasCtx.fillStyle = color;\r\n        colorCanvasCtx.fillRect(0, 0, textWidth, textHeight);\r\n\r\n        colorCanvasCtx.globalCompositeOperation = 'destination-atop';\r\n        colorCanvasCtx.drawImage(textCanvas, 0, 0);\r\n\r\n        return colorCanvas;\r\n    }\r\n\r\n    measureText(text){\r\n        if(!this.loaded) throw new Error('font not loaded');\r\n\r\n        text = text.toUpperCase();\r\n\r\n        const textLetters = text.split('');\r\n        let curWidth = 0, maxWidth = 0, height = this.defaultHeight;\r\n\r\n        for(let letter of textLetters){\r\n            if(letter == '\\n'){\r\n                height += this.defaultHeight + PixelFont.defaultVSpacing;\r\n                maxWidth = Math.max(curWidth, maxWidth);\r\n                curWidth = 0;\r\n                continue\r\n            }\r\n\r\n            if(letter == ' '){\r\n                curWidth += this.defaultWidth;\r\n                continue\r\n            }\r\n\r\n            if(this.letters[letter]){\r\n                curWidth += (this.letters[letter].width || this.defaultWidth) + 1;\r\n            }\r\n        }\r\n\r\n        return {\r\n            width: Math.max(curWidth, maxWidth), height\r\n        }\r\n    }\r\n}\r\n\r\nclass Text extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.fonts = [\r\n            new PixelFont(min5fontSheet, min5fontInfo)\r\n        ];\r\n        this.fonts.forEach(f => f.load());\r\n\r\n        this.miniWindow = null;\r\n\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    down(e){\r\n        if(this.miniWindow && !this.miniWindow.closed) return;\r\n\r\n        this.miniWindow = new MiniWindow('Draw text', 2);\r\n        const winEl = this.miniWindow.element;\r\n        if(mobile){\r\n            winEl.css('left', 0).css('top', 0);\r\n        }else{\r\n            winEl.css('left', window.screen.width/3).css('top', window.screen.height/3);\r\n        }\r\n\r\n        const innerHtml = $(`\r\n            <textarea style=\"width: 100%;\"></textarea>\r\n            <div style=\"display:flex; margin: 2px 0\">\r\n                <div style=\"display: flex\">\r\n                    <div>x:</div> <input type=\"number\" class=\"textXCord\" style=\"width: 100%\">\r\n                </div>\r\n                <div style=\"display: flex; margin-left: 2px\">\r\n                    <div>y:</div> <input type=\"number\" class=\"textYCord\" style=\"width: 100%\">\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        this.miniWindow.bodyElement.css('max-width', 200).css('display', 'flex').css('flex-direction', 'column');\r\n        this.miniWindow.bodyElement.append(innerHtml);\r\n        document.body.appendChild(winEl[0]);\r\n\r\n        const textInput = $('textarea', this.miniWindow.bodyElement);\r\n        const xCordInput = $('.textXCord', this.miniWindow.bodyElement);\r\n        const yCordInput = $('.textYCord', this.miniWindow.bodyElement);\r\n\r\n        const lastCord = [player.x, player.y];\r\n        xCordInput.val(lastCord[0]);\r\n        yCordInput.val(lastCord[1]);\r\n\r\n        const font = this.fonts[0];\r\n\r\n        let lastText = null, lastColor = player.color, lastTextCanvas = null\r\n        const previewFx = new FX((ctx) => {\r\n            const text = textInput.val();\r\n            if(!text) return 0;\r\n\r\n            if(!font.loaded){\r\n                return 0;\r\n            }\r\n\r\n            // remap the sine value based on the time\r\n            // to the min-max opacity borders\r\n            ctx.globalAlpha = map(Math.sin(Date.now()/400), -1, 1, 0.2, 0.9);\r\n\r\n            const x = xCordInput.val();\r\n            const y = yCordInput.val();\r\n\r\n            if(lastText !== text || lastColor !== player.color){\r\n                lastText = text;\r\n                lastColor = player.color;\r\n                lastTextCanvas = font.drawText(lastText, hexPalette[lastColor]);\r\n            }\r\n\r\n            const [screenX, screenY] = boardToScreenSpace(x, y);\r\n\r\n            \r\n            ctx.save();\r\n            ctx.scale(camera.zoom, camera.zoom);\r\n\r\n            ctx.imageSmoothingEnabled = false;\r\n\r\n            const deZoomedX = screenX/camera.zoom;\r\n            const deZoomedY = screenY/camera.zoom;\r\n\r\n            if(~player.secondCol){\r\n                ctx.fillStyle = hexPalette[player.secondCol];\r\n                ctx.fillRect(deZoomedX, deZoomedY, lastTextCanvas.width, lastTextCanvas.height);\r\n            }\r\n            ctx.drawImage(lastTextCanvas, deZoomedX, deZoomedY);\r\n\r\n            ctx.restore();\r\n\r\n            return 0\r\n        })\r\n        addFX(previewFx);\r\n\r\n        this.miniWindow.on('okClicked', () => {\r\n            removeFX(previewFx);\r\n\r\n            const text = textInput.val();\r\n            if(!text || !lastTextCanvas) return;\r\n\r\n            // add background if second color is selected\r\n            if(~player.secondCol){\r\n                const ctx = lastTextCanvas.getContext('2d');\r\n                // draw only on opaque pixels\r\n                ctx.globalCompositeOperation = 'destination-over';\r\n                ctx.fillStyle = hexPalette[player.secondCol];\r\n                ctx.fillRect(0, 0, lastTextCanvas.width, lastTextCanvas.height);\r\n            }\r\n            \r\n            const x = +xCordInput.val();\r\n            const y = +yCordInput.val();\r\n\r\n            paste.startDraw(lastTextCanvas, x, y);\r\n        });\r\n\r\n        this.miniWindow.on('cancelClicked', () => {\r\n            removeFX(previewFx);\r\n        });\r\n    }\r\n}\r\nconst text = new Text('text', 'KeyT', null, ROLE.TRUSTED)\r\n\r\nexport default {\r\n    clicker,\r\n    mover,\r\n    floodfill,\r\n    pipette, altPipette,\r\n    line,\r\n    colorInc, colorDec,\r\n    colorSwap,\r\n    chatOpac, menuOpac, allOpac,\r\n    ctrlZ,\r\n    protector, altProtector,\r\n    grid,\r\n    copy,\r\n    paste,\r\n    cordAdd,\r\n    templateOp1, templateOp2,\r\n    square,\r\n    incBrush, decBrush,\r\n    pixelInfo,\r\n    text\r\n}\r\n","const $ = require('jquery');\r\n\r\nimport {\r\n    hexPalette,\r\n} from './config';\r\nimport camera from './camera';\r\nimport { generateTable } from './windows';\r\nimport Window from './Window'\r\nimport globals from './globals';\r\nimport me from './me';\r\n\r\n// import userImg from '../img/user2.png';\r\nimport userImg from '../img/user.svg'\r\nimport { ROLE } from './constants';\r\nimport { apiRequest } from './actions';\r\nimport IP from './utils/ip';\r\nimport { translate as t_ } from './translate';\r\n\r\nimport modBadge from '../img/mod-badge.svg'\r\nimport adminBadge from '../img/admin-badge.svg'\r\nimport creatorBadge from '../img/creator-badge.svg'\r\nimport { htmlspecialchars } from './utils/misc';\r\n\r\n// need to find a way for importing links dynamically\r\nimport badge0link from '../img/badges/badge0.png';\r\nimport badge1link from '../img/badges/badge1.png';\r\nconst badgeLinks = [\r\n    badge0link,\r\n    badge1link\r\n]\r\n\r\nconst usersContainer = $('#usersTable');\r\n\r\nexport default class User {\r\n    // create user window from given object\r\n    // tempId is a temporary id for connection\r\n    static async CreateWindow(info, tempId) {\r\n        const win = new Window({\r\n            center: true,\r\n            title: `${info.name || t_('PLAYER') + ' ' + (tempId || info.id)}`\r\n        });\r\n\r\n        if (info.ip) {\r\n            if (info.cc && info.cc !== 'XX') {\r\n                // adds a flag near the ip address\r\n                info._ip = info.ip;\r\n\r\n                const cc = info.cc;\r\n                info.ip += ` [${cc}]`;\r\n                info.ip += `<img src=\"${location.protocol}//www.countryflagicons.com/FLAT/16/${cc}.png\" style=\"margin-bottom:-5px;margin-left:1px;\">`;\r\n\r\n                delete info['cc'];\r\n            }\r\n        }\r\n\r\n        if (info.role !== undefined && me.role === ROLE.ADMIN && me.id !== info.id) {\r\n            const role = info.role;\r\n            let str = '';\r\n            Object.keys(ROLE).forEach(text => {\r\n                str += `<option ${(text === role) ? 'selected' : ''}>${text}</option>`\r\n            })\r\n            info.role = `<select type=\"role\">${str}<select>`\r\n        }\r\n\r\n        let infoArr = Object.keys(info).map(key => [key, info[key]]), misc = [];\r\n        infoArr = infoArr.filter(x => !x[0].startsWith('_')); // for shit like _ip\r\n\r\n        if (me.role >= ROLE.MOD) {\r\n            misc = [\r\n                [`<input class=\"alertInput\">`, `<button class=\"sendAlert\">${t_('Send Alert')}</button>`],\r\n                [`<button class=\"banByIp\">${t_('Ban by ip')}</button>`]\r\n            ];\r\n        }\r\n\r\n        let together = infoArr.concat(misc);\r\n\r\n        $(win.body).append(generateTable(together));\r\n\r\n        $('select[type=role]', win.body).on('change', async e => {\r\n            const role = e.target.value,\r\n                userId = info.id;\r\n            const resp = await fetch('/api/admin/changerole', {\r\n                method: 'POST',\r\n                body: JSON.stringify({\r\n                    id: userId,\r\n                    role\r\n                }),\r\n                headers: {\r\n                    'Content-Type': 'application/json'\r\n                }\r\n            });\r\n            const body = await resp.json();\r\n            if (body.errors) {\r\n                body.errors.forEach(error => {\r\n                    toastr.error(error, t_('ERROR'));\r\n                })\r\n            } else {\r\n                toastr.success(t_('Changed role to') + ' ' + role);\r\n            }\r\n        })\r\n\r\n\r\n        $('.sendAlert', win.body).on('click', () => {\r\n            const val = $('.alertInput', win.body).val();\r\n\r\n            if (val.length == 0) return;\r\n\r\n            $('.alertInput', win.body).val('');\r\n            globals.socket.sendAlert(tempId, val);\r\n        });\r\n\r\n        $('.banByIp', win.body).on('click', async () => {\r\n            const ip = info._ip || info.ip;\r\n            if (!ip) return toastr.error(t_('No ip!'))\r\n\r\n            const resp = await apiRequest(`/admin/banPlayer?ip=${ip}`);\r\n            const success = (await resp.json()).success;\r\n            if (success)\r\n                toastr.success(t_('Success'));\r\n        });\r\n    }\r\n\r\n\r\n    constructor(name, id, userId, registered, role, badges) {\r\n        if (!name) name = 'ID ' + id;\r\n\r\n        this.name = name;\r\n        this.id = id;\r\n        this.userId = userId;\r\n\r\n        this.registered = registered;\r\n\r\n        this.role = role;\r\n\r\n        this.conns = [id];\r\n\r\n        this.badges = badges;\r\n\r\n\r\n        const safeName = htmlspecialchars(this.name);\r\n        let displayName = globals.chat.parseColors(safeName).replace(/<[^>]*>/g, '');\r\n\r\n        const roleBadgeProps = this.getRoleBadgeAndTitle();\r\n        const badgeImagesHtml = this.getAchieveBadgesHtml();\r\n\r\n        this.element = $(\r\n            `<tr class=\"tableRow\">\r\n                <td title=\"id ${id}\" class=\"user\">\r\n                    ${roleBadgeProps ? `<img src=\"${roleBadgeProps.icon}\" title=\"${roleBadgeProps.tooltip}\" class=\"roleBadge\">` : ''}\r\n                    <button class=\"userInfoBtn minrole-trusted\"><img style=\"height: 20px\" src=\"${userImg}\"></button>\r\n                    <span class=\"name\">${displayName}</span>\r\n                    <span class=\"badges\">${badgeImagesHtml}</span>\r\n                    <span class=\"xConns\"></span>\r\n                </td>\r\n                <td></td>\r\n            </tr>`);\r\n\r\n        this.nameEl = $('.name', this.element);\r\n        this.coordsEl = $(this.element.children()[1]);\r\n\r\n        this.nameEl.on('click', function () {\r\n            const visibleNick = this.innerText;\r\n            globals.elements.chatInput.value += visibleNick + ', ';\r\n            globals.elements.chatInput.focus();\r\n        })\r\n\r\n\r\n        $('.userInfoBtn', this.element).on('click', async () => {\r\n            const isReg = this.registered;\r\n            const id = isReg ? this.userId : this.id;\r\n\r\n            const req = await fetch(`/api/userInfo?id=${id}${isReg ? '' : '&unreg=1'}`);\r\n            const info = await req.json();\r\n            await User.CreateWindow(info, this.id);\r\n        });\r\n\r\n        this.coordsEl.on('click', () => {\r\n            const [x, y] = this.coordsEl.text()\r\n                .slice(1, -1)\r\n                .split(', ')\r\n                .map(x => parseInt(x, 10));\r\n\r\n            if (Number.isInteger(x) && Number.isInteger(y))\r\n                camera.centerOn(x, y);\r\n        })\r\n\r\n        usersContainer[0].appendChild(this.element[0]);\r\n\r\n        me.updateRoleRelatedHtml();\r\n    }\r\n\r\n    getAchieveBadgesHtml(){\r\n        if(!this.badges) return '';\r\n\r\n        let html = '';\r\n        for(let badgeId of this.badges){\r\n            html += `<img src=\"${badgeLinks[badgeId]}\">`\r\n        }\r\n        return html\r\n    }\r\n\r\n    getRoleBadgeAndTitle() {\r\n        if (!this.role) return null;\r\n\r\n        let tooltip, icon;\r\n\r\n        switch (this.role) {\r\n            case 'MOD':\r\n                tooltip = 'mod';\r\n                icon = modBadge;\r\n                break\r\n            case 'ADMIN':\r\n                tooltip = 'admin';\r\n                icon = adminBadge;\r\n                break\r\n            default:\r\n                return null\r\n        }\r\n\r\n        // if (this.userId == 1) {\r\n        //     tooltip = 'creator';\r\n        //     icon = creatorBadge;\r\n        // }\r\n\r\n        return {\r\n            tooltip,\r\n            icon\r\n        }\r\n    }\r\n\r\n    updateCoords(color, x, y) {\r\n        this.coordsEl.css('color', hexPalette[color]);\r\n        this.coordsEl.text(`(${x}, ${y})`);\r\n    }\r\n\r\n    close(clientId) {\r\n        this.conns.splice(this.conns.indexOf(clientId), 1);\r\n        if (this.conns.length === 0)\r\n            this.destroy();\r\n        else\r\n            this.updateX();\r\n\r\n        delete globals.users[clientId]\r\n    }\r\n\r\n    destroy() {\r\n        this.element.remove();\r\n    }\r\n\r\n    newConnection(clientId) {\r\n        this.conns.push(clientId);\r\n        this.updateX();\r\n    }\r\n\r\n    updateX() {\r\n        const text = (this.conns.length > 1) ? `[x${this.conns.length}]` : '';\r\n        $('.xConns', this.element).text(text);\r\n    }\r\n}","import camera from '../camera';\r\nimport { halfMap } from './misc';\r\nimport { screenToBoardSpace } from './conversions';\r\nimport {\r\n    chunkSize,\r\n    boardChunkWid,\r\n    boardChunkHei,\r\n    boardWidth,\r\n    boardHeight\r\n} from '../config';\r\n\r\nexport function isAreaVisible(x, y, w, h){\r\n    let sx = camera.x + halfMap[0],\r\n        sy = camera.y + halfMap[1];\r\n    \r\n    let ex = sx + window.innerWidth / camera.zoom,\r\n        ey = sy + window.innerHeight / camera.zoom;\r\n\r\n    return x + w >= sx && x < ex &&\r\n           y + h >= sy && y < ey\r\n}\r\n\r\nexport function getVisibleChunks() {\r\n    // todo rework it\r\n    // rn it checks left top chunk and right bottom chunk\r\n\r\n    let [sx, sy] = screenToBoardSpace(0, 0);\r\n    let [ex, ey] = screenToBoardSpace(window.innerWidth, window.innerHeight);\r\n\r\n\r\n    let startX = sx / chunkSize | 0, // math floor\r\n        endX = ex / chunkSize + 1 | 0; // math ceil\r\n\r\n    let startY = sy / chunkSize | 0,\r\n        endY = ey / chunkSize + 1 | 0;\r\n\r\n    let arr = []\r\n    for (let x = Math.max(startX, 0); x < Math.min(endX, boardChunkWid); x++) {\r\n        for (let y = Math.max(startY, 0); y < Math.min(endY, boardChunkHei); y++) {\r\n            arr.push([x, y]);\r\n        }\r\n    }\r\n\r\n    return arr\r\n}\r\n\r\nexport function inBounds(x, y){\r\n    if(x < 0 || x >= boardWidth || y < 0 || y >= boardHeight) return false;\r\n    return true;\r\n}","import camera from '../camera';\r\nimport globals from '../globals';\r\nimport {\r\n    halfMap\r\n} from './misc';\r\nimport {\r\n    chunkSize\r\n} from '../config';\r\n\r\nexport function screenToBoardSpace(clientX, clientY) {\r\n    let screenOffsetX = (clientX - (globals.renderer.canvas.width >> 1)) / camera.zoom;\r\n    let screenOffsetY = (clientY - (globals.renderer.canvas.height >> 1)) / camera.zoom;\r\n\r\n    let boardOffsetX = camera.x + halfMap[0];\r\n    let boardOffsetY = camera.y + halfMap[1];\r\n\r\n    let x = boardOffsetX + screenOffsetX,\r\n        y = screenOffsetY + boardOffsetY;\r\n\r\n    return [x | 0, y | 0]\r\n}\r\n\r\nexport function boardToScreenSpace(x, y) {\r\n    x -= camera.x + halfMap[0];\r\n    y -= camera.y + halfMap[1];\r\n\r\n    x *= camera.zoom;\r\n    y *= camera.zoom;\r\n\r\n    x += globals.renderer.canvas.width >> 1; // x >> 1 = x / 2\r\n    y += globals.renderer.canvas.height >> 1;\r\n\r\n    return [Math.floor(x), Math.floor(y)]\r\n}\r\n\r\nexport function boardToChunk(x, y) {\r\n    let cx = x / chunkSize | 0;\r\n    let cy = y / chunkSize | 0;\r\n\r\n    let offx = x % chunkSize;\r\n    let offy = y % chunkSize;\r\n\r\n    return [\r\n        cx,\r\n        cy,\r\n        offx,\r\n        offy\r\n    ]\r\n}\r\n\r\nexport function chunkToBoard(cx, cy, offx, offy) {\r\n    return [cx * chunkSize + offx, cy * chunkSize + offy]\r\n}","export default {\r\n    \"ALICEBLUE\": \"#F0F8FF\",\r\n    \"ANTIQUEWHITE\": \"#FAEBD7\",\r\n    \"AQUA\": \"#00FFFF\",\r\n    \"AQUAMARINE\": \"#7FFFD4\",\r\n    \"AZURE\": \"#F0FFFF\",\r\n    \"BEIGE\": \"#F5F5DC\",\r\n    \"BISQUE\": \"#FFE4C4\",\r\n    \"BLACK\": \"#000000\",\r\n    \"BLANCHEDALMOND\": \"#FFEBCD\",\r\n    \"BLUE\": \"#0000FF\",\r\n    \"BLUEVIOLET\": \"#8A2BE2\",\r\n    \"BROWN\": \"#A52A2A\",\r\n    \"BURLYWOOD\": \"#DEB887\",\r\n    \"CADETBLUE\": \"#5F9EA0\",\r\n    \"CHARTREUSE\": \"#7FFF00\",\r\n    \"CHOCOLATE\": \"#D2691E\",\r\n    \"CORAL\": \"#FF7F50\",\r\n    \"CORNFLOWERBLUE\": \"#6495ED\",\r\n    \"CORNSILK\": \"#FFF8DC\",\r\n    \"CRIMSON\": \"#DC143C\",\r\n    \"CYAN\": \"#00FFFF\",\r\n    \"DARKBLUE\": \"#00008B\",\r\n    \"DARKCYAN\": \"#008B8B\",\r\n    \"DARKGOLDENROD\": \"#B8860B\",\r\n    \"DARKGRAY\": \"#A9A9A9\",\r\n    \"DARKGREY\": \"#A9A9A9\",\r\n    \"DARKGREEN\": \"#006400\",\r\n    \"DARKKHAKI\": \"#BDB76B\",\r\n    \"DARKMAGENTA\": \"#8B008B\",\r\n    \"DARKOLIVEGREEN\": \"#556B2F\",\r\n    \"DARKORANGE\": \"#FF8C00\",\r\n    \"DARKORCHID\": \"#9932CC\",\r\n    \"DARKRED\": \"#8B0000\",\r\n    \"DARKSALMON\": \"#E9967A\",\r\n    \"DARKSEAGREEN\": \"#8FBC8F\",\r\n    \"DARKSLATEBLUE\": \"#483D8B\",\r\n    \"DARKSLATEGRAY\": \"#2F4F4F\",\r\n    \"DARKSLATEGREY\": \"#2F4F4F\",\r\n    \"DARKTURQUOISE\": \"#00CED1\",\r\n    \"DARKVIOLET\": \"#9400D3\",\r\n    \"DEEPPINK\": \"#FF1493\",\r\n    \"DEEPSKYBLUE\": \"#00BFFF\",\r\n    \"DIMGRAY\": \"#696969\",\r\n    \"DIMGREY\": \"#696969\",\r\n    \"DODGERBLUE\": \"#1E90FF\",\r\n    \"FIREBRICK\": \"#B22222\",\r\n    \"FLORALWHITE\": \"#FFFAF0\",\r\n    \"FORESTGREEN\": \"#228B22\",\r\n    \"FUCHSIA\": \"#FF00FF\",\r\n    \"GAINSBORO\": \"#DCDCDC\",\r\n    \"GHOSTWHITE\": \"#F8F8FF\",\r\n    \"GOLD\": \"#FFD700\",\r\n    \"GOLDENROD\": \"#DAA520\",\r\n    \"GRAY\": \"#808080\",\r\n    \"GREY\": \"#808080\",\r\n    \"GREEN\": \"#008000\",\r\n    \"GREENYELLOW\": \"#ADFF2F\",\r\n    \"HONEYDEW\": \"#F0FFF0\",\r\n    \"HOTPINK\": \"#FF69B4\",\r\n    \"INDIANRED\": \"#CD5C5C\",\r\n    \"INDIGO\": \"#4B0082\",\r\n    \"IVORY\": \"#FFFFF0\",\r\n    \"KHAKI\": \"#F0E68C\",\r\n    \"LAVENDER\": \"#E6E6FA\",\r\n    \"LAVENDERBLUSH\": \"#FFF0F5\",\r\n    \"LAWNGREEN\": \"#7CFC00\",\r\n    \"LEMONCHIFFON\": \"#FFFACD\",\r\n    \"LIGHTBLUE\": \"#ADD8E6\",\r\n    \"LIGHTCORAL\": \"#F08080\",\r\n    \"LIGHTCYAN\": \"#E0FFFF\",\r\n    \"LIGHTGOLDENRODYELLOW\": \"#FAFAD2\",\r\n    \"LIGHTGRAY\": \"#D3D3D3\",\r\n    \"LIGHTGREY\": \"#D3D3D3\",\r\n    \"LIGHTGREEN\": \"#90EE90\",\r\n    \"LIGHTPINK\": \"#FFB6C1\",\r\n    \"LIGHTSALMON\": \"#FFA07A\",\r\n    \"LIGHTSEAGREEN\": \"#20B2AA\",\r\n    \"LIGHTSKYBLUE\": \"#87CEFA\",\r\n    \"LIGHTSLATEGRAY\": \"#778899\",\r\n    \"LIGHTSLATEGREY\": \"#778899\",\r\n    \"LIGHTSTEELBLUE\": \"#B0C4DE\",\r\n    \"LIGHTYELLOW\": \"#FFFFE0\",\r\n    \"LIME\": \"#00FF00\",\r\n    \"LIMEGREEN\": \"#32CD32\",\r\n    \"LINEN\": \"#FAF0E6\",\r\n    \"MAGENTA\": \"#FF00FF\",\r\n    \"MAROON\": \"#800000\",\r\n    \"MEDIUMAQUAMARINE\": \"#66CDAA\",\r\n    \"MEDIUMBLUE\": \"#0000CD\",\r\n    \"MEDIUMORCHID\": \"#BA55D3\",\r\n    \"MEDIUMPURPLE\": \"#9370DB\",\r\n    \"MEDIUMSEAGREEN\": \"#3CB371\",\r\n    \"MEDIUMSLATEBLUE\": \"#7B68EE\",\r\n    \"MEDIUMSPRINGGREEN\": \"#00FA9A\",\r\n    \"MEDIUMTURQUOISE\": \"#48D1CC\",\r\n    \"MEDIUMVIOLETRED\": \"#C71585\",\r\n    \"MIDNIGHTBLUE\": \"#191970\",\r\n    \"MINTCREAM\": \"#F5FFFA\",\r\n    \"MISTYROSE\": \"#FFE4E1\",\r\n    \"MOCCASIN\": \"#FFE4B5\",\r\n    \"NAVAJOWHITE\": \"#FFDEAD\",\r\n    \"NAVY\": \"#000080\",\r\n    \"OLDLACE\": \"#FDF5E6\",\r\n    \"OLIVE\": \"#808000\",\r\n    \"OLIVEDRAB\": \"#6B8E23\",\r\n    \"ORANGE\": \"#FFA500\",\r\n    \"ORANGERED\": \"#FF4500\",\r\n    \"ORCHID\": \"#DA70D6\",\r\n    \"PALEGOLDENROD\": \"#EEE8AA\",\r\n    \"PALEGREEN\": \"#98FB98\",\r\n    \"PALETURQUOISE\": \"#AFEEEE\",\r\n    \"PALEVIOLETRED\": \"#DB7093\",\r\n    \"PAPAYAWHIP\": \"#FFEFD5\",\r\n    \"PEACHPUFF\": \"#FFDAB9\",\r\n    \"PERU\": \"#CD853F\",\r\n    \"PINK\": \"#FFC0CB\",\r\n    \"PLUM\": \"#DDA0DD\",\r\n    \"POWDERBLUE\": \"#B0E0E6\",\r\n    \"PURPLE\": \"#800080\",\r\n    \"REBECCAPURPLE\": \"#663399\",\r\n    \"RED\": \"#FF0000\",\r\n    \"ROSYBROWN\": \"#BC8F8F\",\r\n    \"ROYALBLUE\": \"#4169E1\",\r\n    \"SADDLEBROWN\": \"#8B4513\",\r\n    \"SALMON\": \"#FA8072\",\r\n    \"SANDYBROWN\": \"#F4A460\",\r\n    \"SEAGREEN\": \"#2E8B57\",\r\n    \"SEASHELL\": \"#FFF5EE\",\r\n    \"SIENNA\": \"#A0522D\",\r\n    \"SILVER\": \"#C0C0C0\",\r\n    \"SKYBLUE\": \"#87CEEB\",\r\n    \"SLATEBLUE\": \"#6A5ACD\",\r\n    \"SLATEGRAY\": \"#708090\",\r\n    \"SLATEGREY\": \"#708090\",\r\n    \"SNOW\": \"#FFFAFA\",\r\n    \"SPRINGGREEN\": \"#00FF7F\",\r\n    \"STEELBLUE\": \"#4682B4\",\r\n    \"TAN\": \"#D2B48C\",\r\n    \"TEAL\": \"#008080\",\r\n    \"THISTLE\": \"#D8BFD8\",\r\n    \"TOMATO\": \"#FF6347\",\r\n    \"TURQUOISE\": \"#40E0D0\",\r\n    \"VIOLET\": \"#EE82EE\",\r\n    \"WHEAT\": \"#F5DEB3\",\r\n    \"WHITE\": \"#FFFFFF\",\r\n    \"WHITESMOKE\": \"#F5F5F5\",\r\n    \"YELLOW\": \"#FFFF00\",\r\n    \"YELLOWGREEN\": \"#9ACD32\"\r\n}","function isLocal(ip){\r\n    return ip.startsWith('127.0') || ip.startsWith('192.168') || ip.startsWith('::')\r\n}\r\n\r\nexport default {\r\n    isLocal\r\n}","export function mod(n, m) {\r\n    return ((n % m) + m) % m;\r\n}\r\n\r\nexport function dist(x1, y1, x2, y2) {\r\n    return Math.hypot(x2 - x1, y2 - y1)\r\n}\r\n\r\nexport function avrg(...values) {\r\n    return values.reduce((a, b) => a + b) / values.length\r\n}\r\n\r\nexport function map(value, inputMin, inputMax, outputMin, outputMax) {\r\n    return (value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin) + outputMin;\r\n}\r\n\r\nexport function clamp(value, min, max){\r\n    return Math.max(Math.min(value, max), min)\r\n}","import {\r\n    boardWidth,\r\n    boardHeight,\r\n} from '../config';\r\nimport globals from '../globals';\r\n\r\nexport let halfMap = [null, null]\r\nexport function initHalfmap() {\r\n    halfMap = [\r\n        boardWidth / 2,\r\n        boardHeight / 2\r\n    ]\r\n}\r\n\r\nexport function insanelyLongMobileBrowserCheck() {\r\n    let check = false;\r\n    (function (a) {\r\n        if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\r\n    })(navigator.userAgent || navigator.vendor || window.opera);\r\n    return check;\r\n}\r\n\r\nexport function decodeKey(str) {\r\n    let config = {\r\n        alt: false,\r\n        ctrl: false,\r\n        code: null\r\n    }\r\n\r\n    str.split('+').forEach(param => {\r\n        if (param === 'CTRL') {\r\n            config.ctrl = true;\r\n        } else if (param === 'ALT') {\r\n            config.alt = true;\r\n        } else {\r\n            config.code = param;\r\n        }\r\n    })\r\n\r\n    return config\r\n}\r\n\r\nexport function stringifyKeyEvent(ev) {\r\n    let out = '';\r\n    if (ev.altKey) {\r\n        out += 'ALT+'\r\n    }\r\n    if (ev.ctrlKey) {\r\n        out += 'CTRL+'\r\n    }\r\n    return out + ev.code\r\n}\r\n\r\nexport function calculateColumnSize() {\r\n    const columns = $('.column', globals.elements.topMenuContent);\r\n    const windowWidth = window.innerWidth;\r\n\r\n    const colWidth = windowWidth / columns.length;\r\n\r\n    $('.column', globals.elements.topMenuContent).css('width', colWidth);\r\n}\r\n\r\nexport function htmlspecialchars(text) {\r\n    return text\r\n        .replace(/&/g, \"&amp;\")\r\n        .replace(/</g, \"&lt;\")\r\n        .replace(/>/g, \"&gt;\")\r\n        .replace(/\"/g, \"&quot;\")\r\n        .replace(/'/g, \"&#039;\");\r\n}\r\n\r\nexport function getRecommendedColorSize() {\r\n    if(globals.mobile) return 24;\r\n    const max = 30;\r\n    const p = $('#palette');\r\n    // 14 is for palette padding \r\n    let size = Math.floor((window.innerWidth - 14) / p.children().length);\r\n    size = Math.min(size, max);\r\n\r\n    return size\r\n}\r\n\r\nexport function getPathsafeDate() {\r\n    const date = new Date;\r\n\r\n    const day = date.getDate().toString().padStart(2, '0'); // convert \"1\"s to \"01\"s\r\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n    const year = date.getFullYear();\r\n\r\n    const today = `${day}.${month}.${year}`;\r\n\r\n    const hours = date.getHours().toString().padStart(2, '0');\r\n    const minutes = date.getMinutes().toString().padStart(2, '0');\r\n    const seconds = date.getSeconds().toString().padStart(2, '0');\r\n\r\n    const time = `${hours}-${minutes}-${seconds}`;\r\n\r\n    return `${today} - ${time}`\r\n}\r\n\r\nexport function testPointInPolygon(nvert, vertx, verty, testx, testy) {\r\n    // copied and translated to js from some stackoverflow\r\n    let i, j, c = 0;\r\n    for (i = 0, j = nvert - 1; i < nvert; j = i++) {\r\n        if (((verty[i] > testy) != (verty[j] > testy)) &&\r\n            (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))\r\n            c = !c;\r\n    }\r\n    return c;\r\n}\r\n\r\nexport function resizeCanvas(canvas, newWidth, newHeight) {\r\n    const tempCanvas = document.createElement('canvas');\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n\r\n    tempCanvas.width = newWidth;\r\n    tempCanvas.height = newHeight;\r\n\r\n    tempCtx.imageSmoothingEnabled = false;\r\n    tempCtx.drawImage(canvas, 0, 0, newWidth, newHeight);\r\n\r\n    const resizedCanvas = document.createElement('canvas');\r\n\r\n    resizedCanvas.width = newWidth;\r\n    resizedCanvas.height = newHeight;\r\n\r\n    const resizedCtx = resizedCanvas.getContext('2d');\r\n\r\n    resizedCtx.imageSmoothingEnabled = false;\r\n    resizedCtx.drawImage(tempCanvas, 0, 0, newWidth, newHeight);\r\n\r\n    return resizedCanvas;\r\n}\r\n\r\nexport function loadImage(url){\r\n    return new Promise((res, rej) => {\r\n        const img = new Image();\r\n        img.src = url;\r\n\r\n        img.onerror = rej;\r\n        img.onload = () => res(img);\r\n    })\r\n}","export default {\r\n    line: function (x, y, x2, y2) {\r\n        let pointArr = [];\r\n\r\n        let steep = Math.abs(y2 - y) > Math.abs(x2 - x);\r\n        if (steep) {\r\n            [x, y] = [y, x];\r\n            [x2, y2] = [y2, x2];\r\n        }\r\n        let reverseFlag = false;\r\n        if (x > x2) {\r\n            [y, y2] = [y2, y];\r\n            [x, x2] = [x2, x];\r\n            reverseFlag = true;\r\n        }\r\n        let dist = {\r\n            x: x2 - x,\r\n            y: Math.abs(y2 - y)\r\n        }\r\n        let err = dist.x / 2;\r\n        let stepY = (y < y2) ? 1 : -1;\r\n        for (; x <= x2; x++) {\r\n            pointArr.push([steep ? y : x, steep ? x : y]);\r\n            err -= dist.y;\r\n            if (err < 0) {\r\n                y += stepY;\r\n                err += dist.x;\r\n            }\r\n        }\r\n        if (reverseFlag) pointArr.reverse();\r\n\r\n        pointArr.reverse();\r\n\r\n        return pointArr;\r\n    },\r\n\r\n    filledCircle: function (centerX, centerY, r) {\r\n        let pixels = [];\r\n\r\n        const squareR = r * r;\r\n\r\n        for (let _x = -r + centerX; _x < r + centerX; _x++) {\r\n            for (let _y = -r + centerY; _y < r + centerY; _y++) {\r\n                if (isIn(_x, _y)) {\r\n                    pixels.push([_x, _y])\r\n                }\r\n            }\r\n        }\r\n\r\n        function isIn(_x, _y) {\r\n            let dx = _x - centerX,\r\n                dy = _y - centerY;\r\n\r\n            if (dx * dx + dy * dy <= squareR * 0.8)\r\n                return true\r\n            return false\r\n        }\r\n\r\n        return pixels\r\n    },\r\n\r\n    square(x1, y1, x2, y2) {\r\n        const minX = Math.min(x1, x2),\r\n            minY = Math.min(y1, y2),\r\n            maxX = Math.max(x1, x2),\r\n            maxY = Math.max(y1, y2);\r\n\r\n        let pixels = [];\r\n        for (let y = minY; y < maxY+1; y++) {\r\n            for (let x = minX; x < maxX+1; x++) {\r\n                pixels.push([x, y]);\r\n            }\r\n        }\r\n\r\n        return pixels\r\n    }\r\n}","export function capitalize(str) {\r\n    return str.replace(\r\n      /[А-я\\w]+/g,\r\n      function(txt) {\r\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\r\n      }\r\n    );\r\n  }","/*\r\n    A modified version of the https://github.com/samirkumardas/pcm-player/blob/master/pcm-player.js\r\n*/\r\n\r\nfunction PCMPlayer(option) {\r\n    this.init(option);\r\n}\r\n\r\nPCMPlayer.prototype.init = function(option) {\r\n    var defaults = {\r\n        encoding: '16bitInt',\r\n        channels: 1,\r\n        sampleRate: 8000,\r\n        flushingTime: 1000\r\n    };\r\n    this.option = Object.assign({}, defaults, option);\r\n    this.samples = new Float32Array();\r\n    this.flush = this.flush.bind(this);\r\n    this.interval = setInterval(this.flush, this.option.flushingTime);\r\n    this.maxValue = this.getMaxValue();\r\n    this.typedArray = this.getTypedArray();\r\n    this.createContext();\r\n};\r\n\r\nPCMPlayer.prototype.getMaxValue = function () {\r\n    var encodings = {\r\n        '8bitInt': 128,\r\n        '16bitInt': 32768,\r\n        '32bitInt': 2147483648,\r\n        '32bitFloat': 1\r\n    }\r\n\r\n    return encodings[this.option.encoding] ? encodings[this.option.encoding] : encodings['16bitInt'];\r\n};\r\n\r\nPCMPlayer.prototype.getTypedArray = function () {\r\n    var typedArrays = {\r\n        '8bitInt': Int8Array,\r\n        '16bitInt': Int16Array,\r\n        '32bitInt': Int32Array,\r\n        '32bitFloat': Float32Array\r\n    }\r\n\r\n    return typedArrays[this.option.encoding] ? typedArrays[this.option.encoding] : typedArrays['16bitInt'];\r\n};\r\n\r\nPCMPlayer.prototype.createContext = function() {\r\n    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n    // context needs to be resumed on iOS and Safari (or it will stay in \"suspended\" state)\r\n    this.audioCtx.resume();\r\n    this.audioCtx.onstatechange = () => console.log(this.audioCtx.state);   // if you want to see \"Running\" state in console and be happy about it\r\n    \r\n    this.gainNode = this.audioCtx.createGain();\r\n    this.gainNode.gain.value = 1;\r\n\r\n    this.balanceNode = this.audioCtx.createStereoPanner();\r\n    this.balanceNode.pan.value = 0;\r\n\r\n    this.gainNode.connect(this.balanceNode);\r\n    this.balanceNode.connect(this.audioCtx.destination);\r\n\r\n\r\n    this.startTime = this.audioCtx.currentTime;\r\n};\r\n\r\nPCMPlayer.prototype.isTypedArray = function(data) {\r\n    return (data.byteLength && data.buffer && data.buffer.constructor == ArrayBuffer);\r\n};\r\n\r\nPCMPlayer.prototype.feed = function(data) {\r\n    if (!this.isTypedArray(data)) return;\r\n    data = this.getFormatedValue(data);\r\n    var tmp = new Float32Array(this.samples.length + data.length);\r\n    tmp.set(this.samples, 0);\r\n    tmp.set(data, this.samples.length);\r\n    this.samples = tmp;\r\n};\r\n\r\nPCMPlayer.prototype.getFormatedValue = function(data) {\r\n    var data = new this.typedArray(data.buffer),\r\n        float32 = new Float32Array(data.length),\r\n        i;\r\n\r\n    for (i = 0; i < data.length; i++) {\r\n        float32[i] = data[i] / this.maxValue;\r\n    }\r\n    return float32;\r\n};\r\n\r\nPCMPlayer.prototype.volume = function(volume) {\r\n    this.gainNode.gain.value = volume;\r\n};\r\n\r\nPCMPlayer.prototype.balance = function(hrBalance) {\r\n    this.balanceNode.pan.value = hrBalance;\r\n};\r\n\r\nPCMPlayer.prototype.destroy = function() {\r\n    if (this.interval) {\r\n        clearInterval(this.interval);\r\n    }\r\n    this.samples = null;\r\n    this.audioCtx.close();\r\n    this.audioCtx = null;\r\n};\r\n\r\nPCMPlayer.prototype.flush = function() {\r\n    if (!this.samples.length) return;\r\n    var bufferSource = this.audioCtx.createBufferSource(),\r\n        length = this.samples.length / this.option.channels,\r\n        audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate),\r\n        audioData,\r\n        channel,\r\n        offset,\r\n        i,\r\n        decrement;\r\n\r\n    for (channel = 0; channel < this.option.channels; channel++) {\r\n        audioData = audioBuffer.getChannelData(channel);\r\n        offset = channel;\r\n        decrement = 50;\r\n        for (i = 0; i < length; i++) {\r\n            audioData[i] = this.samples[offset];\r\n            /* fadein */\r\n            if (i < 50) {\r\n                audioData[i] =  (audioData[i] * i) / 50;\r\n            }\r\n            /* fadeout*/\r\n            if (i >= (length - 51)) {\r\n                audioData[i] =  (audioData[i] * decrement--) / 50;\r\n            }\r\n            offset += this.option.channels;\r\n        }\r\n    }\r\n    \r\n    if (this.startTime < this.audioCtx.currentTime) {\r\n        this.startTime = this.audioCtx.currentTime;\r\n    }\r\n\r\n    bufferSource.buffer = audioBuffer;\r\n    bufferSource.connect(this.gainNode);\r\n    bufferSource.start(this.startTime);\r\n    this.startTime += audioBuffer.duration;\r\n    this.samples = new Float32Array();\r\n};\r\n\r\nexport default PCMPlayer","import PcmPlayer from './PcmPlayer';\r\nimport { getLS, setLS } from '../utils/localStorage';\r\nimport { loadImage } from '../utils/misc';\r\nimport globals from '../globals';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\nimport { FX } from '../fxcanvas';\r\nimport { clamp, map } from '../utils/math';\r\nimport camera from '../camera';\r\nimport player from '../player';\r\nimport { apiRequest } from '../actions';\r\n\r\nimport winampFontPng from '../../font/pixel/winamp.png';\r\nimport winampFontDesc from '../../font/pixel/winamp.txt';\r\nimport { PixelFont } from '../tools';\r\n\r\n\r\nasync function importMaterials() {\r\n    require.context('../../img/winamp', false, /\\.png$/)\r\n    const images = {\r\n        bg: await import('../../img/winamp/bg2.png'),\r\n        hrSlider: await import('../../img/winamp/hr-slider-btn-small.png'),\r\n        hrSliderBig: await import('../../img/winamp/slider-btn.png'),\r\n        digits: await import('../../img/winamp/digits.png'),\r\n    }\r\n\r\n    const wFont = new PixelFont(winampFontPng, winampFontDesc);\r\n    await wFont.load();\r\n\r\n    return {\r\n        images,\r\n        fonts: {\r\n            winamp: wFont\r\n        }\r\n    }\r\n}\r\n\r\nclass UIRect {\r\n    constructor(x, y, w, h) {\r\n        Object.assign(this, {\r\n            x, y, w, h\r\n        });\r\n    }\r\n}\r\n\r\nlet tempColors;\r\nfunction preserveColors() {\r\n    tempColors = [player.color, player.secondCol];\r\n\r\n    player.switchColor(-1);\r\n    player.switchSecondColor(-1);\r\n}\r\nfunction restoreColors() {\r\n    player.switchColor(tempColors[0]);\r\n    player.switchSecondColor(tempColors[1]);\r\n}\r\n\r\nclass WinampPlayer {\r\n    constructor() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        this.playerPosition = JSON.parse(getLS('winamp.position', true) || '[0,0]');\r\n        this.sndBalance = 0; // -1; 1\r\n        this.volumeLvl = +(getLS('winamp.volume', true) || '0.001'); // 0; 1\r\n\r\n        this.queue = null;\r\n        this.currentTrack = null;\r\n\r\n        this.images = null;\r\n        this.needRender = true;\r\n\r\n        this.pcmPlayer = null;\r\n\r\n        this.config = {\r\n            width: 275,\r\n            height: 348,\r\n\r\n            headerRect: new UIRect(2, 2, 262, 12),\r\n            closeBtnRect: new UIRect(265, 4, 7, 7),\r\n            volumeBoundsRect: new UIRect(108, 61, 63, 4),\r\n            soundBalanceBoundsRect: new UIRect(178, 61, 35, 4),\r\n\r\n            // needs calculation\r\n            volumeSliderRect: new UIRect(-1, -1, -1, -1),\r\n            balanceSliderRect: new UIRect(-1, -1, -1, -1),\r\n\r\n            titleRect: new UIRect(111, 24, 155, 12),\r\n\r\n            kbpsRect: new UIRect(111, 41, 16, 10),\r\n            khzRect: new UIRect(156, 41, 11, 10),\r\n\r\n            // big mm:ss clock\r\n            mm1Rect: new UIRect(48, 26, 9, 13),\r\n            mm2Rect: new UIRect(60, 26, 9, 13),\r\n            ss1Rect: new UIRect(78, 26, 9, 13),\r\n            ss2Rect: new UIRect(90, 26, 9, 13),\r\n\r\n            progressSliderBndRect: new UIRect(16, 72, 249, 10),\r\n\r\n            queueBoxRect: new UIRect(18, 257, 238, 48)\r\n        }\r\n\r\n        this._cache = {};\r\n\r\n        this._holdingButton = null;\r\n        this._lastHoldPos = null;\r\n\r\n        this._destroyed = false;\r\n        this.noFeed = false;\r\n\r\n        this.title = null;\r\n        this.visibleTitle = null;\r\n    }\r\n\r\n    rebuildPcmPlayer(sampleRate) {\r\n        if (this.pcmPlayer) {\r\n            this.pcmPlayer.destroy();\r\n        }\r\n\r\n        this.pcmPlayer = new PcmPlayer({\r\n            inputCodec: 'Int16',\r\n            channels: 2,\r\n            sampleRate,\r\n            flushTime: 2000\r\n        })\r\n\r\n        this.pcmPlayer.volume(this.volumeLvl);\r\n        this.pcmPlayer.balance(this.sndBalance);\r\n    }\r\n\r\n    async init() {\r\n        await this.loadMaterials();\r\n        this.recalculateButtons();\r\n        this.initTouchControls();\r\n\r\n        this.setTitle('Goroxels Radio 1.0 alpha');\r\n\r\n        this.canvas.width = this.config.width;\r\n        this.canvas.height = this.config.height;\r\n\r\n        globals.fxRenderer.add(new FX(this.render.bind(this)), 2);\r\n\r\n        await this.updateSong();\r\n        await this.updateQueue();\r\n        this.startPolling();\r\n\r\n        globals.socket.on('radio', type => {\r\n            switch(type){\r\n                case 0:\r\n                    this.updateSong();\r\n                case 1:\r\n                    this.updateQueue();\r\n            }\r\n        });\r\n\r\n        globals.socket.on('opened', () => {\r\n            this.updateSong();\r\n            this.updateQueue();\r\n        })\r\n\r\n        this.ackRender();\r\n        this.initAutoRender();\r\n    }\r\n\r\n    initAutoRender() {\r\n        setInterval(() => {\r\n            this.ackRender();\r\n        }, 1000);\r\n    }\r\n\r\n    initTouchControls() {\r\n        globals.eventManager.on('mousedown', e => {\r\n            if(this._destroyed) return;\r\n\r\n            if (e.gesture) return mouseup(e);\r\n\r\n            mousedown(e);\r\n        });\r\n        globals.eventManager.on('mouseup', e => {\r\n            if(this._destroyed) return;\r\n\r\n            mouseup(e);\r\n        });\r\n        globals.eventManager.on('mousemove', e => {\r\n            if(this._destroyed) return;\r\n\r\n            if (e.gesture) return;\r\n\r\n            mousemove(e);\r\n        });\r\n\r\n        const self = this;\r\n\r\n        function mousedown(e) {\r\n            if (self._holdingButton) mouseup(e);\r\n\r\n\r\n            let obj = self.getObjectAtPosition(e.clientX, e.clientY);\r\n            if (obj) {\r\n                preserveColors();\r\n\r\n                camera.disableMove();\r\n\r\n                self.onObjMousedown.call(self, obj, e);\r\n                self._lastHoldPos = screenToBoardSpace(e.clientX, e.clientY);\r\n            }\r\n        }\r\n        function mouseup(e) {\r\n            self._lastHoldPos = null;\r\n\r\n            camera.enableMove();\r\n\r\n            if (self._holdingButton) {\r\n                self.onObjMouseup.call(self, self._holdingButton, e);\r\n\r\n                self._holdingButton = false;\r\n\r\n                setTimeout(restoreColors);\r\n            }\r\n        }\r\n        function mousemove(e) {\r\n            if (self._holdingButton) {\r\n                self.onObjMousemove.call(self, self._holdingButton, e);\r\n\r\n                self._lastHoldPos = screenToBoardSpace(e.clientX, e.clientY);\r\n            }\r\n        }\r\n    }\r\n\r\n    getObjectAtPosition(screenX, screenY) {\r\n        const objsToCheck = [\r\n            this.config.headerRect,\r\n            this.config.closeBtnRect,\r\n            this.config.volumeSliderRect,\r\n            this.config.balanceSliderRect,\r\n        ];\r\n\r\n        const [boardX, boardY] = screenToBoardSpace(screenX, screenY);\r\n        const [playerX, playerY] = this.getRelPos(boardX, boardY);\r\n\r\n        for (let obj of objsToCheck) {\r\n            if (playerX >= obj.x && playerX < obj.x + obj.w &&\r\n                playerY >= obj.y && playerY < obj.y + obj.h) {\r\n                return obj;\r\n            }\r\n        }\r\n    }\r\n\r\n    onObjMousedown(obj) {\r\n        this._holdingButton = obj;\r\n    }\r\n    onObjMouseup(obj, e) {\r\n        switch(obj){\r\n            case this.config.closeBtnRect: {\r\n                if(this.getObjectAtPosition(e.clientX, e.clientY) === this.config.closeBtnRect){\r\n                    this.close();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    onObjMousemove(obj, e) {\r\n        const [movX, movY] = this.calcMovement(e);\r\n\r\n        switch (obj) {\r\n            case this.config.headerRect: {\r\n                this.playerPosition[0] += movX;\r\n                this.playerPosition[1] += movY;\r\n\r\n                setLS('winamp.position', JSON.stringify(this.playerPosition), true);\r\n\r\n                this.ackRender();\r\n\r\n                break;\r\n            }\r\n            case this.config.volumeSliderRect: {\r\n                const [relX] = this.getRelPos(...screenToBoardSpace(e.clientX, e.clientY));\r\n\r\n                const bndRect = this.config.volumeBoundsRect;\r\n                const sliderImg = this.images.hrSlider;\r\n\r\n                const [clampedX, clampedY] = this.clampHrSliderPos(relX, bndRect, sliderImg);\r\n\r\n                this.config.volumeSliderRect.x = clampedX;\r\n                this.config.volumeSliderRect.y = clampedY;\r\n\r\n                const newValue = this.mapHrSliderPos(clampedX, bndRect, sliderImg, 0, 1);\r\n                this.volumeLvl = newValue;\r\n\r\n                this.pcmPlayer.volume(this.volumeLvl);\r\n\r\n                setLS('winamp.volume', this.volumeLvl.toString(), true);\r\n\r\n                this.ackRender();\r\n\r\n                break;\r\n            }\r\n\r\n            case this.config.balanceSliderRect: {\r\n                const [relX] = this.getRelPos(...screenToBoardSpace(e.clientX, e.clientY));\r\n\r\n                const bndRect = this.config.soundBalanceBoundsRect;\r\n                const sliderImg = this.images.hrSlider;\r\n\r\n                const [clampedX, clampedY] = this.clampHrSliderPos(relX, bndRect, sliderImg);\r\n\r\n                this.config.balanceSliderRect.x = clampedX;\r\n                this.config.balanceSliderRect.y = clampedY;\r\n\r\n                const newValue = this.mapHrSliderPos(clampedX, bndRect, sliderImg, -1, 1);\r\n                this.sndBalance = newValue;\r\n\r\n                this.pcmPlayer.balance(this.sndBalance);\r\n\r\n                this.ackRender();\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // clamp mouse position to slider bounds\r\n    clampHrSliderPos(relX, bndRect, sliderImg) {\r\n        // center the slider to the mouse pos\r\n        relX -= sliderImg.width / 2;\r\n\r\n        const clampX = clamp(relX, bndRect.x, bndRect.x + bndRect.w - sliderImg.width);\r\n        const constY = bndRect.y + (bndRect.h / 2) - (sliderImg.height / 2) + 1;\r\n\r\n        return [clampX | 0, constY | 0];\r\n    }\r\n\r\n    // convert slider position to output value\r\n    mapHrSliderPos(posX, bndRect, sliderImg, minValue, maxValue) {\r\n        const minPosX = bndRect.x;\r\n        const maxPosX = bndRect.x + bndRect.w - sliderImg.width;\r\n\r\n        const mappedVal = map(posX, minPosX, maxPosX, minValue, maxValue);\r\n        return mappedVal;\r\n    }\r\n\r\n    // convert value to position\r\n    reverseMapHrSliderPos(value, bndRect, sliderImg, minValue, maxValue) {\r\n        const minPosX = bndRect.x;\r\n        const maxPosX = bndRect.x + bndRect.w - sliderImg.width;\r\n\r\n        const mappedPosX = map(value, minValue, maxValue, minPosX, maxPosX);\r\n        return mappedPosX | 0;\r\n    }\r\n\r\n    // convert global board position to local canvas position\r\n    getRelPos(boardX, boardY) {\r\n        const playerX = boardX - this.playerPosition[0];\r\n        const playerY = boardY - this.playerPosition[1];\r\n\r\n        return [playerX, playerY];\r\n    }\r\n\r\n    // getHrSliderPos(minX, maxX, )\r\n\r\n    calcMovement(e) {\r\n        if (!this._lastHoldPos) {\r\n            return null;\r\n        }\r\n\r\n        const curBoardPos = screenToBoardSpace(e.clientX, e.clientY);\r\n\r\n        const diffX = curBoardPos[0] - this._lastHoldPos[0];\r\n        const diffY = curBoardPos[1] - this._lastHoldPos[1];\r\n\r\n        return [diffX, diffY];\r\n    }\r\n\r\n    async loadMaterials() {\r\n        const {\r\n            images: urlsObj,\r\n            fonts\r\n        } = await importMaterials();\r\n\r\n        const imgObj = {};\r\n        for (let key of Object.keys(urlsObj)) {\r\n            let url = urlsObj[key].default;\r\n\r\n            imgObj[key] = await loadImage(url);\r\n        }\r\n\r\n        this.images = imgObj;\r\n        this.fonts = fonts;\r\n    }\r\n\r\n    ackRender() {\r\n        this.needRender = true;\r\n        globals.fxRenderer.requestRender();\r\n    }\r\n\r\n    render(ctx) {\r\n        if(this._destroyed) return 2;\r\n\r\n        const [x, y] = boardToScreenSpace(this.playerPosition[0], this.playerPosition[1]);\r\n        const z = camera.zoom;\r\n\r\n        if(this.needRender)\r\n            this.redraw();\r\n\r\n        ctx.save();\r\n        ctx.scale(z, z);\r\n        ctx.drawImage(this.canvas, x / z, y / z);\r\n        ctx.restore();\r\n\r\n        return 1\r\n    }\r\n\r\n    generateQueueText() {\r\n        if (!this.queue) return '';\r\n\r\n        const queue = [\r\n            ...this.queue.queue,\r\n            ...this.queue.defaultQueue\r\n        ].slice(0, 7);\r\n\r\n        const str = queue.map(s => {\r\n            let title = s.title;\r\n            if(title.length > 42){\r\n                title = title.slice(0, 42-3) + '...';\r\n            }\r\n            return `${s.id}. ${title} <${s.duration / 60 | 0}:${pad2(s.duration % 60 | 0)}>`\r\n        }).join('\\n');\r\n\r\n        return str;\r\n    }\r\n\r\n    redraw() {\r\n        this.needRender = false;\r\n\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.drawImage(this.images.bg, 0, 0);\r\n        this.ctx.drawImage(this.images.hrSlider, this.config.volumeSliderRect.x, this.config.volumeSliderRect.y);\r\n        this.ctx.drawImage(this.images.hrSlider, this.config.balanceSliderRect.x, this.config.balanceSliderRect.y);\r\n\r\n        this.drawTextInInput(this.title, this.config.titleRect, '#00E200');\r\n\r\n        if (this.currentTrack) {\r\n            const kbps = (2 * 2 * this.currentTrack.sampleRate) / 1000 | 0; // channels*sampleSize(16bit=2byte)*sampleRate\r\n            const khz = this.currentTrack.sampleRate / 1000 | 0;\r\n\r\n            this.drawTextInInput(kbps.toString(), this.config.kbpsRect, '#00E200');\r\n            this.drawTextInInput(khz.toString(), this.config.khzRect, '#00E200');\r\n\r\n            const sPassed = (Date.now() - this.currentTrack.startedAt) / 1000;\r\n\r\n            const mmPassed = pad2((sPassed / 60 | 0).toString());\r\n            const ssPassed = pad2((sPassed % 60 | 0).toString());\r\n\r\n            this.drawBigDigit(this.config.mm1Rect, mmPassed[0]);\r\n            this.drawBigDigit(this.config.mm2Rect, mmPassed[1]);\r\n            this.drawBigDigit(this.config.ss1Rect, ssPassed[0]);\r\n            this.drawBigDigit(this.config.ss2Rect, ssPassed[1]);\r\n\r\n            const progressPosX = this.reverseMapHrSliderPos(sPassed, this.config.progressSliderBndRect, this.images.hrSliderBig, 0, this.currentTrack.duration);\r\n            const progressPosY = this.config.progressSliderBndRect.y;\r\n\r\n            this.ctx.drawImage(this.images.hrSliderBig, progressPosX, progressPosY);\r\n        }\r\n\r\n        // this shit eats a lot of cpu\r\n        const queueText = this.generateQueueText();\r\n        if(queueText && queueText !== this._cache.queueText){\r\n            const qTextImg = this.fonts.winamp.drawText(queueText, '#00E200');\r\n            if(qTextImg){\r\n                this._cache.queueTextImg = qTextImg;\r\n                this._cache.queueText = queueText;\r\n                this.ctx.drawImage(qTextImg, this.config.queueBoxRect.x, this.config.queueBoxRect.y);\r\n            }\r\n        }else if(queueText){\r\n            this.ctx.drawImage(this._cache.queueTextImg, this.config.queueBoxRect.x, this.config.queueBoxRect.y);\r\n        }\r\n    }\r\n\r\n    drawBigDigit(rect, number) {\r\n        const digitW = rect.w;\r\n        this.ctx.drawImage(this.images.digits, digitW * number, 0, rect.w, rect.h, rect.x, rect.y, rect.w, rect.h);\r\n    }\r\n\r\n    drawTextInInput(text, inputRect, color) {\r\n        const drawnText = this.fonts.winamp.drawText(text, color);\r\n        this.ctx.drawImage(drawnText, 0, 0, inputRect.w, drawnText.height, inputRect.x, ((inputRect.y + inputRect.h / 2) - drawnText.height / 2) | 0, inputRect.w, drawnText.height);\r\n    }\r\n\r\n    recalculateButtons() {\r\n        const smallSliderWidth = this.images.hrSlider.width;\r\n        const smallSliderHeight = this.images.hrSlider.height;\r\n\r\n        const volRect = this.config.volumeBoundsRect;\r\n        const volSliderX = map(this.volumeLvl, 0, 1, volRect.x, (volRect.x + volRect.w) - smallSliderWidth);\r\n        const volSliderY = ((volRect.y + volRect.h / 2) - smallSliderHeight / 2) + 1\r\n\r\n        this.config.volumeSliderRect.x = volSliderX | 0;\r\n        this.config.volumeSliderRect.y = volSliderY | 0;\r\n        this.config.volumeSliderRect.w = smallSliderWidth;\r\n        this.config.volumeSliderRect.h = smallSliderHeight;\r\n\r\n        const balRect = this.config.soundBalanceBoundsRect;\r\n        const balSliderX = map(this.sndBalance, -1, 1, balRect.x, (balRect.x + balRect.w) - smallSliderWidth);\r\n        const balSliderY = ((balRect.y + balRect.h / 2) - smallSliderHeight / 2) + 1\r\n\r\n        this.config.balanceSliderRect.x = balSliderX | 0;\r\n        this.config.balanceSliderRect.y = balSliderY | 0;\r\n        this.config.balanceSliderRect.w = smallSliderWidth;\r\n        this.config.balanceSliderRect.h = smallSliderHeight;\r\n    }\r\n\r\n    close() {\r\n        this.pcmPlayer.destroy();\r\n\r\n        clearTimeout(this.__pollTimeout);\r\n        clearInterval(this._titleRollerInterval);\r\n\r\n\r\n        this._destroyed = true;\r\n    }\r\n\r\n    async startPolling() {\r\n        try {\r\n            const aborter = new AbortController();\r\n\r\n            const resp = await fetch(`${location.protocol}//${location.hostname}/api/radio/stream`, {\r\n                signal: aborter.signal\r\n            });\r\n            const reader = resp.body.getReader();\r\n\r\n            let acc = new Uint8Array();\r\n\r\n            while (1) {\r\n                if(this._destroyed) {\r\n                    aborter.abort('destroy');\r\n                };\r\n                const { done, value } = await reader.read();\r\n                if (done) break;\r\n\r\n                // this fuck sometimes causes an error like \"new Uint16array length should divide by 2 bla bla bla\"\r\n                // i guess this is because of transmission issues, so let's workaround\r\n                if(value.length % 2 !== 0 || acc.length > 0){\r\n                    acc = joinByteArrays(acc, value);\r\n\r\n                    if(acc.length % 2 == 0){\r\n                        this.feed(acc.subarray());\r\n                        acc = new Uint8Array();\r\n                    }\r\n                }else{\r\n                    this.feed(value)\r\n                }\r\n            }\r\n\r\n            function joinByteArrays(arr1, arr2){\r\n                const mergedArray = new Uint8Array(arr1.length + arr2.length);\r\n                mergedArray.set(arr1);\r\n                mergedArray.set(arr2, arr1.length);\r\n\r\n                return mergedArray;\r\n            }\r\n        } catch (error) {\r\n            if(this._destroyed) return;\r\n\r\n            console.error('player stream ERRORed, restart in 1s');\r\n            clearTimeout(this.__pollTimeout);\r\n            this.__pollTimeout = setTimeout(this.startPolling.bind(this), 1000);\r\n            return;\r\n        }\r\n\r\n        console.warn('player stream stopped, restart in 10s');\r\n        clearTimeout(this.__pollTimeout);\r\n        this.__pollTimeout = setTimeout(this.startPolling.bind(this), 10000);\r\n    }\r\n\r\n    feed(data) {\r\n        if (this.noFeed || !this.pcmPlayer) return;\r\n\r\n        this.pcmPlayer.feed(data);\r\n    }\r\n\r\n    async updateSong() {\r\n        this.noFeed = true;\r\n\r\n        const song = await this.fetchCurTrack();\r\n        if (!this.currentTrack || this.currentTrack.sampleRate != song.sampleRate) {\r\n            this.rebuildPcmPlayer(song.sampleRate);\r\n        }\r\n\r\n        this.currentTrack = song;\r\n\r\n        const curTrackMins = song.duration / 60 | 0;\r\n        const curTrackSecs = song.duration % 60 | 0;\r\n        this.setTitle(this.currentTrack.title + ` <${curTrackMins}:${pad2(curTrackSecs)}>`);\r\n\r\n\r\n        this.noFeed = false;\r\n\r\n        this.ackRender();\r\n    }\r\n\r\n    async updateQueue(){\r\n        const queue = await this.fetchQueue();\r\n        if(!queue) return;\r\n\r\n        this.queue = queue;\r\n        this.ackRender();\r\n    }\r\n\r\n    async fetchCurTrack() {\r\n        const resp = await apiRequest('/radio/current-song');\r\n        const json = await resp.json();\r\n        if (!json.success) {\r\n            toastr.error('cannot fetch current song! reload the page.');\r\n            return\r\n        }\r\n\r\n        return json.song;\r\n    }\r\n\r\n    async fetchQueue() {\r\n        const resp = await apiRequest('/radio/get-queue');\r\n        const json = await resp.json();\r\n        if (!json.success) {\r\n            toastr.warn('cannot fetch song queue');\r\n            return\r\n        }\r\n\r\n        return json.queues;\r\n    }\r\n\r\n    setTitle(title) {\r\n        this._titleSet = Date.now();\r\n\r\n        this.title = title;\r\n\r\n        clearInterval(this._titleRollerInterval)\r\n\r\n        // roll only if it exceeds input width\r\n        if (this.fonts.winamp.measureText(this.title).width > this.config.titleRect.w) {\r\n            this._titleRollerInterval = setInterval(() => {\r\n                // rotate title by 1 char\r\n                const titleArr = this.title.split('');\r\n                titleArr.push(titleArr.shift());\r\n\r\n                this.title = titleArr.join('');\r\n                this.ackRender();\r\n            }, 300);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction pad2(num) {\r\n    return num.toString().padStart(2, '0');\r\n}\r\n\r\nexport default WinampPlayer","import {\r\n    ROLE,\r\n    keys\r\n} from './constants';\r\nimport {\r\n    translate as tr,\r\n    translate\r\n} from './translate';\r\n\r\nimport { ROLE_I } from './constants'\r\nimport Window from './Window';\r\nimport { decodeKey } from './utils/misc';\r\nimport { game } from './config'\r\nimport globals from './globals';\r\nimport me from './me';\r\nimport player from './player'\r\nimport { apiRequest, fetchCaptcha, fixChatPosition, makeScreenshot, setPaletteColorsSize, showPatternsOnPalette, showProtected, solveCaptcha, toggleEmojis, togglePlaced, unloadPalettePatterns, updateBrush, updateEmojis, updateMe } from './actions';\r\nimport toastr from 'toastr';\r\nimport tools from './tools';\r\nimport chat from './chat';\r\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\r\nimport User from './user';\r\nimport { htmlspecialchars } from './utils/misc';\r\n\r\nimport userImg from '../img/user2.png';\r\nimport arrowSvg from '../img/arrow.svg'\r\nimport { capitalize } from './utils/strings';\r\n\r\nimport vkLogo from '../img/vk-logo.svg';\r\nimport dsLogo from '../img/discord-logo-circle.svg';\r\nimport fbLogo from '../img/fb-logo.svg';\r\n\r\nexport function generateTable(arr = []) {\r\n    const table = $('<table class=\"columnTable\"></table>');\r\n    arr.forEach(([title, content]) => {\r\n        let tableBlock = $(`\r\n                <tr>\r\n                    ${content === void 0 ?\r\n                `<td colspan=\"2\">${title}</td>` :\r\n                `<td>${title}</td>\r\n                        <td>${content}</td>`\r\n            }\r\n                </tr>`);\r\n        table.append(tableBlock)\r\n    });\r\n\r\n    return table\r\n}\r\n\r\nexport function accountSettings() {\r\n    const settingsWin = new Window({\r\n        title: capitalize(translate('account settings')),\r\n        center: true\r\n    });\r\n    if (!settingsWin.created) return;\r\n\r\n    let html = generateTable([\r\n        [tr('role'), ROLE_I[me.role].toUpperCase()],\r\n        [\r\n            tr('change name'),\r\n            `<input type=\"text\" id=\"name\" style=\"width:50%\"><button id=\"changeName\">yes</button>`\r\n        ],\r\n        [\r\n            `<button id=\"logout\">${tr('logout')}</button>`\r\n        ],\r\n        // [\r\n        //     `<button id=\"deleteAccount\">${tr('delete_account')}</button>`\r\n        // ]\r\n\r\n    ]);\r\n\r\n    $(settingsWin.body).append(html);\r\n\r\n    $('#name').val(me.name)\r\n    $('#changeName').on('click', () => {\r\n        const newName = $('#name').val();\r\n\r\n        if (!me.registered) {\r\n            return toastr.error('Hey wtf', '0_o');\r\n        }\r\n        if (newName.length < 0 || newName.length > 32) {\r\n            return toastr.error('Name length is not 0 < length < 32', 'Name change')\r\n        }\r\n        if (me.name === newName) {\r\n            return toastr.error('Name is the same as was', 'Name change')\r\n        }\r\n\r\n        fetch('/api/changename', {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                name: newName\r\n            }),\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            }\r\n        }).then(async r => {\r\n            const result = await r.json();\r\n            if (!result.errors.length) {\r\n                globals.socket.close();\r\n                toastr.success('Name successfully changed');\r\n                updateMe();\r\n            } else {\r\n                result.errors.map(e => {\r\n                    toastr.error(e, 'Name change error')\r\n                })\r\n            }\r\n        })\r\n    })\r\n\r\n    $('#logout').on('click', async () => {\r\n        if (me.registered) {\r\n            const req = await apiRequest('/auth/logout');\r\n            const success = await req.json();\r\n            if (success) {\r\n                location.pathname = '/';\r\n            } else {\r\n                toastr.error('Can\\'t log out');\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nexport function keyBinds() {\r\n    const keysWin = new Window({\r\n        title: capitalize(translate('toolbinds settings')),\r\n        center: true\r\n    });\r\n    if (!keysWin.created) return;\r\n\r\n    let table = generateTable();\r\n\r\n    for (const tool of Object.values(tools)) {\r\n        if (!tool.key) continue;\r\n        if (tool.requiredRole > me.role) continue;\r\n\r\n        const tableRow = $(\r\n            `<tr>\r\n            <td>${tool.name}</td>\r\n            <td>\r\n                <span id=\"MODS-${tool.name}\"></span>\r\n                <input id=\"KEY-${tool.name}\" class=\"key\" style=\"width:130px\">\r\n            </td>\r\n        </tr>`);\r\n\r\n        table.append(tableRow);\r\n\r\n        const input = $('input', tableRow);\r\n        const modsElement = $('span', tableRow);\r\n        input.on('keydown', e => {\r\n            e.preventDefault();\r\n\r\n            if (!e.code || e.code === 'ControlLeft' || e.code === 'AltLeft') return\r\n\r\n            const altUsed = e.altKey;\r\n            const ctrlUsed = e.ctrlKey;\r\n\r\n            let key = '';\r\n\r\n            modsElement.text('');\r\n            if (altUsed) {\r\n                modsElement.text('ALT + ');\r\n                key += 'ALT+'\r\n            }\r\n            if (ctrlUsed) {\r\n                modsElement.text(modsElement.text() + 'CTRL + ');\r\n                key += 'CTRL+'\r\n            }\r\n            key += e.code;\r\n            input.val(e.code);\r\n\r\n            // removing same values\r\n            for (let _tool of Object.values(tools)) {\r\n                if (tool.name != _tool.name && _tool.key == key) {\r\n                    $('#MODS-' + _tool.name).text('')\r\n                    $('#KEY-' + _tool.name).val('')\r\n                }\r\n            }\r\n\r\n            globals.toolManager.changeKey(tool, key);\r\n        });\r\n        input.on('keyup', e => {\r\n            e.preventDefault();\r\n            if (!e.code || e.code === 'ControlLeft' || e.code === 'AltLeft') return\r\n\r\n            // saving ALL key binds\r\n            let toSave = {};\r\n\r\n            for (const tool of Object.values(tools)) {\r\n                if (!tool.key) continue;\r\n\r\n                toSave[tool.name] = tool.key;\r\n            }\r\n\r\n            setLS('keyBinds', JSON.stringify(toSave));\r\n        });\r\n\r\n        const parsed = decodeKey(tool.key);\r\n\r\n        modsElement.text((parsed.alt ? 'ALT + ' : '') + (parsed.ctrl ? 'CTRL + ' : ''));\r\n\r\n        input.val(parsed.code);\r\n    }\r\n\r\n    $(keysWin.body).append(table);\r\n}\r\n\r\nexport function uiSettings() {\r\n    const setWin = new Window({\r\n        title: capitalize(translate('ui settings')),\r\n        center: true\r\n    });\r\n    if (!setWin.created) return;\r\n\r\n    const table = generateTable([\r\n        [translate('colors size'), '<input type=\"range\" min=\"16\", max=\"64\" step=\"1\" id=\"colSize\"><div style=\"width:50px;\"><div>'],\r\n        [translate('hide emojis'), '<input type=\"checkbox\" id=\"toggleEmojis\">'],\r\n        [translate('emoji list'), '<input type=\"text\" id=\"emojiList\">'],\r\n        [`<button id=\"moreEmojis\">${translate('super secret button')}</button>`],\r\n        [translate('show placed pixels'), '<input type=\"checkbox\" id=\"togglePlaced\">'],\r\n        [translate('show patterns over the palette'), '<input type=\"checkbox\" id=\"showPatterns\">']\r\n    ]);\r\n    $(setWin.body).append(table);\r\n\r\n    function colorSizeChanged() {\r\n        const val = $('#colSize').val();\r\n        setPaletteColorsSize(val);\r\n        $('#colSize').next().text(val + 'px');\r\n        setLS('colorSize', val, true);\r\n        fixChatPosition();\r\n    }\r\n\r\n    const colSizeVal = getOrDefault('colorSize', 24, true);\r\n    $('#colSize').next().text(colSizeVal);\r\n    $('#colSize').val(colSizeVal)\r\n    $('#colSize').on('input', colorSizeChanged);\r\n\r\n    $('#toggleEmojis')[0].checked = getLS('hideEmojis') == 1;\r\n    $('#toggleEmojis').on('click', e => {\r\n        const state = !e.target.checked;\r\n        setLS('hideEmojis', state ? 0 : 1);\r\n        toggleEmojis(state);\r\n    });\r\n\r\n    $('#emojiList').val(getOrDefault('emojis', '🙁 🤔 😀 😄 💚 😡 👋 👍 😐'));\r\n    $('#emojiList').on('change', e => {\r\n        setLS('emojis', e.target.value);\r\n        updateEmojis(e.target.value.split(' '));\r\n    })\r\n\r\n    $('#moreEmojis').on('click', () => {\r\n        const w = new Window(translate('more emojis!'));\r\n        if (!w.created) return;\r\n\r\n        w.body.innerHTML = '😁😂😃😄😅😆😉😊😋😌😍😏😒😓😔😖😘😚😜😝😞😠😡😢😣😤😥😨😩😪😫😭😰😱😲😳😵😷😸😹😺😻😼😽😾😿🙀🙅🙆🙇🙈🙉🙊🙋🙌🙍🙎🙏✂✅✈✉✊✋✌✏✒✔✖✨✳✴❄❇❌❎❓❔❕❗❤➕➖➗➡➰🚀🚃🚄🚅🚇🚉🚌🚏🚑🚒🚓🚕🚗🚙🚚🚢🚤🚥🚧🚨🚩🚪🚫🚬🚭🚲🚶🚹🚺🚻🚼🚽🚾🛀Ⓜ🅰🅱🅾🅿🆎🆑🆒🆓🆔🆕🆖🆗🆘🆙🆚🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑©®‼⁉™ℹ↔↕↖↗↘↙↩↪⌚⌛⏩⏪⏫⏬⏰⏳▪▫▶◀◻◼◽◾☀☁☎☑☔☕☝☺♈♉♊♋♌♍♎♏♐♑♒♓♠♣♥♦♨♻♿⚓⚠⚡⚪⚫⚽⚾⛄⛅⛎⛔⛪⛲⛳⛵⛺⛽⤴⤵⬅⬆⬇⬛⬜⭐⭕〰〽㊗㊙🀄🃏🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌏🌑🌓🌔🌕🌙🌛🌟🌠🌰🌱🌴🌵🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍌🍍🍎🍏🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🎠🎡🎢🎣🎤🎥🎦🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏆🏈🏊🏠🏡🏢🏣🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🐌🐍🐎🐑🐒🐔🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾👀👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👦👧👨👩👪👫👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💮💯💰💱💲💳💴💵💸💹💺💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📑📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📮📰📱📲📳📴📶📷📹📺📻📼🔃🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔖🔗🔘🔙🔚🔛🔜🔝🔞🔟🔠🔡🔢🔣🔤🔥🔦🔧🔨🔩🔪🔫🔮🔯🔰🔱🔲🔳🔴🔵🔶🔷🔸🔹🔺🔻🔼🔽🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛🗻🗼🗽🗾🗿😀😇😈😎😐😑😕😗😙😛😟😦😧😬😮😯😴😶🚁🚂🚆🚈🚊🚍🚎🚐🚔🚖🚘🚛🚜🚝🚞🚟🚠🚡🚣🚦🚮🚯🚰🚱🚳🚴🚵🚷🚸🚿🛁🛂🛃🛄🛅🌍🌎🌐🌒🌖🌗🌘🌚🌜🌝🌞🌲🌳🍋🍐🍼🏇🏉🏤🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐏🐐🐓🐕🐖🐪👥👬👭💭💶💷📬📭📯📵🔀🔁🔂🔄🔅🔆🔇🔉🔕🔬🔭🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕧'\r\n        w.body.style.userSelect = 'text';\r\n    });\r\n    $('#togglePlaced')[0].checked = getOrDefault('hidePlaced', 1) == 0;\r\n    $('#togglePlaced').on('click', e => {\r\n        const show = e.target.checked;\r\n        setLS('hidePlaced', show ? 0 : 1);\r\n        togglePlaced(show);\r\n    });\r\n\r\n    $('#showPatterns')[0].checked = globals.showPatterns;\r\n    $('#showPatterns').on('click', e => {\r\n        const show = e.target.checked;\r\n        globals.showPatterns = show;\r\n        setLS('showPalettePatterns', show ? '1' : '0');\r\n        show ? showPatternsOnPalette() : unloadPalettePatterns();\r\n    });\r\n}\r\n\r\nexport function gameSettings() {\r\n    const win = new Window({\r\n        title: capitalize(translate('game settings')),\r\n        center: true\r\n    });\r\n    if (!win.created) return;\r\n\r\n    // 1 for guests (packets disabled by server), 20 for admins, and 10 for others \r\n    let maxBrushSize = (me.role === ROLE.ADMIN ? 20 : (me.role < ROLE.USER ? 1 : 10))\r\n\r\n    const table = generateTable([\r\n        [\r\n            translate('show protected'),\r\n            `<input type=\"checkbox\" id=\"showProtected\" ${game.showProtected ? 'checked' : ''}>`\r\n        ],\r\n        [\r\n            translate('brush size'),\r\n            `<input type=\"checkbox\" id=\"customBrushSize\" ${player.brushSize > 1 ? 'checked' : ''}>\r\n            <input id=\"brushSize\" type=\"range\" value=\"${player.brushSize}\" ` +\r\n            `${player.brushSize == 1 ? 'disabled' : ''} min=\"2\" ` +\r\n            `max=\"${maxBrushSize}\" step=\"2\">` +\r\n            `<span id=\"brushSizeCounter\">${player.brushSize - 1}<span>`\r\n        ],\r\n        [\r\n            translate('max saved pixels'),\r\n            `<input id=\"savePixelsInp\" type=\"number\" min=\"0\" value=\"${player.maxPlaced}\" style=\"width:4rem\">`\r\n        ],\r\n        [\r\n            translate('disable chat colors'),\r\n            `<input type=\"checkbox\" id=\"disableChatColors\" ${chat.colorsEnabled ? '' : 'checked'}>`\r\n        ],\r\n        [\r\n            translate('chat messages limit'),\r\n            `<input type=\"number\" id=\"chatLimit\" value=\"${game.chatLimit}\" title=\"maximum messages in chat\">`\r\n        ],\r\n        [\r\n            translate('light grid'),\r\n            `<input type=\"checkbox\" id=\"lightGridCB\" ${tools.grid.isLight ? 'checked' : ''} title=\"will grid be light?\">`\r\n        ],\r\n        [\r\n            translate('enable grid'),\r\n            `<input type=\"checkbox\" id=\"enableGridCB\" ${tools.grid.state == 1 ? 'checked' : ''}>`\r\n        ],\r\n        [\r\n            translate('draw line length'),\r\n            `<input type=\"checkbox\" id=\"drawLineLenCB\" ${tools.line.drawLength ? 'checked' : ''} title=\"draw line length near it\">`\r\n        ],\r\n    ]);\r\n\r\n    $(win.body).append(table);\r\n\r\n    $('#showProtected').on('change', e => {\r\n        const show = e.target.checked;\r\n        game.showProtected = show;\r\n        showProtected(show);\r\n    });\r\n\r\n    $('#customBrushSize').on('change', e => {\r\n        const use = e.target.checked;\r\n\r\n        if (use) {\r\n            // TODO thing below does not work\r\n            $('#brushSize').removeAttr('disabled');\r\n            updateBrush($('#brushSize').val());\r\n        } else {\r\n            $('#brushSize').attr('disabled');\r\n            updateBrush(1);\r\n        }\r\n    });\r\n\r\n    $('#brushSize').on('input', e => {\r\n        updateBrush(e.target.value);\r\n    });\r\n\r\n    $('#savePixelsInp').on('change', e => {\r\n        e = e.target;\r\n        if (+e.value < 0) e.value = 0;\r\n\r\n        player.maxPlaced = +e.value;\r\n        setLS('maxPlaced', player.maxPlaced)\r\n    });\r\n\r\n    $('#disableChatColors').on('change', e => {\r\n        const checked = e.target.checked\r\n\r\n        setLS('disableColors', checked.toString());\r\n\r\n        chat.setColors(!checked)\r\n    });\r\n\r\n    $('#chatLimit').on('change', e => {\r\n        const value = parseInt(e.target.value, 10);\r\n        if (isNaN(value) || value < 1) return;\r\n\r\n        setLS('chatLimit', value.toString());\r\n\r\n        game.chatLimit = value;\r\n    });\r\n\r\n    $('#lightGridCB').on('change', e => {\r\n        const checked = e.target.checked;\r\n\r\n        setLS('lightGrid', checked.toString());\r\n\r\n        tools.grid.isLight = checked;\r\n    });\r\n\r\n    $('#enableGridCB').on('change', e => {\r\n        const checked = e.target.checked;\r\n\r\n        setLS('enableGrid', checked.toString());\r\n\r\n        if (checked) tools.grid.show();\r\n        else tools.grid.hide();\r\n    });\r\n\r\n    $('#drawLineLenCB').on('change', e => {\r\n        const checked = e.target.checked;\r\n\r\n        setLS('drawLineLen', checked.toString());\r\n\r\n        tools.line.drawLength = checked;\r\n    });\r\n}\r\n\r\nexport async function captchaModal() {\r\n    let win = new Window({\r\n        title: translate('Captcha'),\r\n        center: true,\r\n        closeable: false\r\n    });\r\n\r\n    if (win.created) {\r\n        const [help, cont, inp] = $(\r\n            `<div>${translate('Case insensitive, 0/o i/l are same')}. <a href=\"#\">${translate('Can\\'t recognize?')}</a></div>` +\r\n            '<div class=\"captchaContainer\"></div>' +\r\n            '<input class=\"fullWidthInput\" type=\"text\"></input>'\r\n        );\r\n\r\n        help.children[0].onclick = captchaModal;\r\n\r\n        const [line] = $(`<div style=\"display:flex;justify-content:center\">${translate('Captcha').toUpperCase()}:&nbsp;&nbsp;</div>`);\r\n        line.appendChild(inp);\r\n\r\n        win.body.appendChild(help)\r\n        win.body.appendChild(cont);\r\n        win.body.appendChild(line);\r\n\r\n        inp.addEventListener('keydown', async e => {\r\n            if (e.key === 'Enter') {\r\n                if (inp.value.length == 0) return;\r\n                let val = inp.value;\r\n                inp.value = '';\r\n\r\n                const success = await solveCaptcha(val);\r\n\r\n                if (success) {\r\n                    win.close();\r\n                } else {\r\n                    captchaModal();\r\n                }\r\n            }\r\n        })\r\n    } else win = win.oldWindow;\r\n\r\n    let svg;\r\n    try {\r\n        svg = await fetchCaptcha();\r\n    } catch (e) {\r\n        console.error('error downloading captcha image: ' + e);\r\n\r\n        globals.socket.close();\r\n        return win.close();\r\n    }\r\n\r\n    // according to default dark theme\r\n    svg = svg.replace('stroke=\"black\"', 'stroke=\"white\"');\r\n\r\n    $('.captchaContainer', win.body).html(svg);\r\n\r\n    win.moveToCenter();\r\n    $('input', win.body).trigger('focus');\r\n}\r\n\r\nexport function toolsWindow() {\r\n    const toolWin = new Window({\r\n        title: capitalize(translate('tools')),\r\n        center: true\r\n    });\r\n    if (!toolWin.created) return;\r\n\r\n    const tableArr = [\r\n        [`<a href=\"/convert\" target=\"_blank\">${translate('convert image into palette')}</a>`],\r\n        [`<button id=\"screenshot\">${translate('save canvas')}</button>`]\r\n    ]\r\n\r\n    if(me.role >= ROLE.MOD){\r\n        tableArr.unshift([`<button id=\"searchUsersB\">${translate('search users')}</button>`])\r\n    }\r\n\r\n    const table = generateTable(tableArr);\r\n    $(toolWin.body).append(table);\r\n\r\n    $('#searchUsersB', table).on('click', () => {\r\n        const win = new Window({\r\n            title: capitalize(translate('search users')),\r\n            center: true\r\n        });\r\n        if (!win.created) return;\r\n\r\n        const table = generateTable([\r\n            [`<input type=\"text\" placeholder=\"nickname\" id=\"userSearchText\" max=\"32\" style=\"width:250px\"> ${translate('OR')} ` +\r\n                '<input type=\"text\" placeholder=\"id\" id=\"userSearchId\" max=\"32\" style=\"width:50px\">' +\r\n                `<input type=\"checkbox\" id=\"searchIsBanned\"><label for=\"searchIsBanned\">${translate('banned?')}</label>`],\r\n            ['<div id=\"searchUsersBody\">']\r\n        ]);\r\n        console.log(table)\r\n        $(win.body).append(table);\r\n\r\n        const input = $('#userSearchText');\r\n\r\n        $('#userSearchId').on('input', async e => {\r\n            let num = e.target.value.trim();\r\n            num = +num;\r\n\r\n            if (isNaN(num) || num < 1 || num > Number.MAX_SAFE_INTEGER) {\r\n                return\r\n            }\r\n\r\n            const isBanned = $('#searchIsBanned')[0].checked;\r\n\r\n            const searchResp = await search(null, num, isBanned);\r\n            afterSearch(searchResp);\r\n        })\r\n\r\n        $('#userSearchText').on('input', async _ => {\r\n            let text = input.val().trim();\r\n            text = text.slice(0, 32);\r\n\r\n            const isBanned = $('#searchIsBanned')[0].checked;\r\n\r\n            const searchResp = await search(text, null, isBanned);\r\n            afterSearch(searchResp);\r\n        });\r\n\r\n        function afterSearch(resp) {\r\n            if (!resp || !resp.length) {\r\n                // clean up if nothing found\r\n                $('#searchUsersBody').html('');\r\n                return\r\n            };\r\n\r\n            let table = document.createElement('table');\r\n            table.className = 'innerTable';\r\n            table.innerHTML += '<tr><th>NICK</th><th>ID</th><th>ROLE</th><th>&nbsp;</th></tr>'\r\n\r\n            for (let user of resp) {\r\n                const safeNick = htmlspecialchars(user.name);\r\n\r\n                // little workaround with click listener,\r\n                // this might be shorter\r\n                const uinfoButton = document.createElement('button');\r\n                uinfoButton.className = 'userInfoBtn';\r\n                uinfoButton.innerHTML = `<img src=\"${userImg}\">`;\r\n                uinfoButton.addEventListener('click', async () => {\r\n                    const req = await apiRequest(`/userInfo?id=${user.id}`);\r\n                    const info = await req.json();\r\n                    await User.CreateWindow(info);\r\n                })\r\n\r\n                const row = $(\r\n                    `<tr>\r\n                        <td>${safeNick}</td><td>${user.id}</td>` +\r\n                    `<td>${user.role}</td>` +\r\n                    `<td></td>\r\n                    </tr>`\r\n                );\r\n\r\n                row[0].lastElementChild.appendChild(uinfoButton);\r\n                table.appendChild(row[0]);\r\n            }\r\n\r\n            $('#searchUsersBody').html(table);\r\n        }\r\n\r\n        async function search(term, id, isBanned) {\r\n            if (!isBanned) {\r\n                if (!term && !id) return;\r\n            }\r\n            if (term && id) return;\r\n\r\n            if (term) {\r\n                term = encodeURIComponent(term);\r\n            }\r\n            const req = await apiRequest(`/admin/users/search?isBanned=${isBanned ? 1 : 0}&${id ? `id=${id}` : `t=${term}`}`)\r\n\r\n            const json = await req.json();\r\n            return json\r\n        }\r\n    });\r\n\r\n    $('#screenshot').on('click', makeScreenshot);\r\n}\r\n\r\nexport function authWindow() {\r\n    const win = new Window({\r\n        title: capitalize(translate('LOG IN')),\r\n        center: true\r\n    });\r\n    if (!win.created) return;\r\n\r\n    const tableArr = [\r\n        [`<a href=\"/api/auth/vk\"><img src=\"${vkLogo}\" class=\"authLogo\">VK</a>`],\r\n        [`<a href=\"/api/auth/discord\"><img src=\"${dsLogo}\" class=\"authLogo\">DISCORD</a>`],\r\n        [`<a href=\"/api/auth/facebook\"><img src=\"${fbLogo}\" class=\"authLogo\">FACEBOOK</a>`]\r\n    ]\r\n\r\n    const table = generateTable(tableArr);\r\n\r\n    $('td', table).css('text-align', 'left');\r\n    $('a', table).css('margin-left', '15px');\r\n    \r\n    $(win.body).append(table);\r\n}\r\n\r\nfunction createCollapsibleBlock(title, bodyHtml, collapsed = true) {\r\n    const head = $('<div>');\r\n    head[0].style.cssText =\r\n        `width: 100%;\r\n    height: 30px;\r\n    background-color: #5f5f5f;\r\n    position: relative;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    user-select: none;\r\n    cursor: pointer`\r\n\r\n    head.append(`<div style=\"font-size:20px;text-transform:uppercase;\">${title}</div>`)\r\n\r\n    const arrow = $('<div>');\r\n    arrow[0].style.cssText =\r\n        `position: absolute;\r\n    top: 50%;\r\n    transform: translate(0, -50%);\r\n    left: 5px;\r\n    background-image: url(${arrowSvg});\r\n    background-size: 100%;\r\n    background-repeat: no-repeat;\r\n    transition: transform .2s ease-in-out;\r\n    width: 20px;\r\n    height: 20px;`\r\n\r\n    head.append(arrow);\r\n\r\n    const body = $('<div>');\r\n    body[0].style.cssText =\r\n        `max-height: 0;\r\n    overflow: hidden;\r\n    transition: max-height 0.3s linear;\r\n    font-size: 20px;`\r\n\r\n    const innerBody = $('<div>');\r\n    innerBody[0].style.cssText =\r\n        `padding:8px`\r\n    innerBody.html(bodyHtml);\r\n\r\n    body.append(innerBody);\r\n\r\n    const headBodyContainer = $('<div>');\r\n    headBodyContainer[0].style.cssText =\r\n        `margin-bottom: 1px;`\r\n    headBodyContainer.append(head, body)\r\n\r\n    let state = 0; // 0 - closed, 1 - opened\r\n    function toggle() {\r\n        if (state) {\r\n            arrow.css('transform', 'translate(0px, -50%) rotate(0deg)');\r\n            body.css('max-height', 0);\r\n        } else {\r\n            arrow.css('transform', 'translate(0px, -50%) rotate(180deg)');\r\n            body.css('max-height', $(body)[0].scrollHeight);\r\n        }\r\n\r\n        // becomes true/false analog\r\n        state = !state;\r\n    }\r\n    if (!collapsed) setTimeout(toggle);\r\n\r\n    head.on('click', toggle);\r\n\r\n    return headBodyContainer\r\n}\r\n\r\nexport function help() {\r\n    const helpWin = new Window({\r\n        title: translate('help'),\r\n        center: true\r\n    });\r\n    if (!helpWin.created) return;\r\n\r\n    helpWin.body.style.width = '90vw'\r\n    helpWin.body.style.height = '90vh'\r\n\r\n    // TODO move this to translations\r\n    const intro = createCollapsibleBlock(translate('intro.introHeader'),\r\n        `<div style=\"width:100%;text-align:center;\"><img src=\"./img/goroxels.png\" style=\"vertical-align: middle;\">${translate('intro.desc')}</div><br><br>\r\n    ${translate('intro.desc2')}<br>\r\n    ${translate('intro.desc3')}`, false);\r\n\r\n    const howto = createCollapsibleBlock(translate('how to play?'),\r\n        `<div style=\"display:inline-flex\">\r\n            <div>${translate('intro.howToPlayDecs')}</div>\r\n            <div style=\"padding-left: 10px;\">\r\n                <video autoplay loop muted style=\"height:196px\"><source src=\"./video/clickerMouse.webm\" type=\"video/webm\"></video>\r\n            </div>\r\n        </div>`, false);\r\n\r\n    const tools = createCollapsibleBlock(translate('tools'),\r\n        `${translate('intro.toolsDecs')}<br><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.toolsClicker')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/clicker.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.toolsAS')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/as.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.toolC')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/toolC.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.brush')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/brush2.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.line')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/line.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.flood')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/flood.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.grid')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <img src=\"./img/unavailable.png\" style=\"height:196px\">\r\n        </div>\r\n    </div><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.ctrlZ')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/ctrlZ.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>\r\n    ${translate('intro.resetColors')}<br>`);\r\n\r\n    const tools2 = createCollapsibleBlock(translate('intro.tools2header'),\r\n        `<div style=\"width:100%;text-align:center;\"><b>${translate('intro.tools2desc')}</b></div><br><br>\r\n    ${translate('intro.toolsHiders')}<br><br>\r\n    ${translate('intro.multicol')}<br>\r\n    ${translate('intro.multicol2')}<br>\r\n    ${translate('intro.multicol3')}<br><br>\r\n    ${translate('intro.sendCoords')}<br><br>\r\n    ${translate('intro.templateTools')}<br>`);\r\n\r\n    const template = createCollapsibleBlock(translate('template'),\r\n        `<div style=\"width:100%;text-align:center;\"><b>${translate('intro.templateIntro')}</b></div><br><br>\r\n    ${translate('intro.templateDesc')}<br><br>\r\n    ${translate('intro.templateDescConvert')}<br><br>\r\n    <div class=\"helpWithVideoCont\">\r\n        <div>${translate('intro.templateDescReminder')}<br><br></div>\r\n        <div class=\"desktop\">\r\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/patternDemo.webm\" type=\"video/webm\"></video>\r\n        </div>\r\n    </div><br>`);\r\n\r\n    const author = createCollapsibleBlock(translate('intro.authorHeader'),\r\n        `${translate('intro.authorText')}<br>\r\n        ${translate('intro.authorContacts')}<br>\r\n        <div style=\"text-align:center\"><img src=\"./img/3rdcf.png\" title=\"ТРЕТЬЯ КОНФА\"></div>`);\r\n\r\n\r\n    $(helpWin.body).append(intro, howto, tools, tools2, template, author);\r\n}\r\n\r\nexport function onlineViewWindow(json){\r\n    let win = new Window({\r\n        title: capitalize(translate('online')),\r\n        center: true,\r\n        closeable: true\r\n    });\r\n\r\n    if (!win.created) {\r\n        win = win.oldWindow;\r\n    }\r\n\r\n    win.body.style.width = '325px';\r\n    win.moveToCenter();\r\n\r\n    const tableArr = [];\r\n    Object.keys(json).forEach(key => {\r\n        if(key === 'TOTAL'){\r\n            win.updateTitle(translate('online') + ` (${json[key]})`, true);\r\n            return;\r\n        }\r\n\r\n        const firstEl = `<a href=\"/${key}\" target=\"_shagorox\"><h3>${key}<h3></a>`;\r\n        const secondEl = `<h2>${json[key]}</h2>`;\r\n\r\n        tableArr.push([firstEl, secondEl]);\r\n    })\r\n\r\n    const table = generateTable(tableArr);\r\n\r\n    $('*', win.body).remove();\r\n    $(win.body).append(table);\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \".\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"game\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkgoroxels_client\"] = self[\"webpackChunkgoroxels_client\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"penis\"], () => (__webpack_require__(\"./src/js/main.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}