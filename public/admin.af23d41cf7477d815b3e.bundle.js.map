{"version":3,"file":"admin.af23d41cf7477d815b3e.bundle.js","mappings":";;;;;;;;;;;;;;AAAA,iEAAe,qBAAuB,iBAAiB;;;;;;;;;;;;ACAvD;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAC6B;AACH;AAC4B;AACtD;AACqC;AACQ;AACmB;AAChE;AACA;AACA;AACA;AACA,kBAAkB,kDAAqB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C,yBAAyB,sBAAsB;AAC/C,2BAA2B,GAAG,GAAG,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,CAAC;AACd,YAAY,CAAC;AACb;AACA;AACA;AACA,yBAAyB,CAAC;AAC1B,yBAAyB,CAAC;AAC1B,uBAAuB,CAAC;AACxB,uBAAuB,CAAC;AACxB;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA,kCAAkC,IAAI;AACtC,YAAY,CAAC;AACb;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA,yCAAyC,KAAK,IAAI,wBAAwB;AAC1E,YAAY,CAAC;AACb;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,CAAC;AAChC;AACA;AACA;AACA,oEAAoE,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0DAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,iCAAiC,SAAS;AAC1C,+BAA+B,UAAU,IAAI,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC,4BAA4B,CAAC;AACtC,QAAQ,CAAC;AACT;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA;AACA,aAAa,CAAC;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL,2CAA2C,CAAC;AAC5C;AACA,KAAK;AACL;AACA;AACA,IAAI,CAAC;AACL,wBAAwB,CAAC;AACzB;AACA,YAAY,CAAC;AACb;AACA,YAAY,CAAC;AACb,KAAK;AACL;AACA,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,MAAM;AAChC,aAAa,MAAM;AACnB,KAAK;AACL;AACA;AACA;AACA,QAAQ,MAAM;AACd,KAAK;AACL;AACA;AACA;AACA,IAAI,CAAC;AACL,oBAAoB,CAAC;AACrB,kBAAkB,CAAC;AACnB;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,kBAAkB;AACrD,SAAS;AACT;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,0BAA0B,MAAM;AAChC,aAAa,MAAM;AACnB,KAAK;AACL;AACA;AACA,IAAI,CAAC;AACL,sBAAsB,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,OAAO;AAC1C,SAAS;AACT;AACA;AACA;AACA,YAAY,MAAM;AAClB,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL,sBAAsB,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,eAAe;AAClD,SAAS;AACT;AACA;AACA;AACA,YAAY,MAAM;AAClB,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC;AACb,UAAU;AACV,YAAY,CAAC;AACb;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA,sBAAsB,CAAC;AACvB,sBAAsB,CAAC;AACvB;AACA;AACA,uBAAuB,CAAC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,gCAAgC,MAAM;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG,GAAG,GAAG;AACzD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA,4EAA4E,MAAM,IAAI,MAAM;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM,IAAI,MAAM;AACnF;AACA,QAAQ,MAAM;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC,8CAA8C,GAAG,IAAI,UAAU;AACxE,KAAK;AACL;AACA,IAAI,CAAC;AACL,oBAAoB,CAAC;AACrB;AACA,QAAQ,CAAC;AACT;AACA;AACA,YAAY,CAAC;AACb;AACA,KAAK;AACL;AACA,IAAI,CAAC;AACL,oBAAoB,CAAC;AACrB;AACA;AACA,qBAAqB,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,CAAC;AACvB,sBAAsB,CAAC;AACvB,sBAAsB,CAAC;AACvB,sBAAsB,CAAC;AACvB;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,MAAM;AACd,eAAe,MAAM;AACrB;AACA;AACA,kBAAkB,gEAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAI;AACjB,YAAY,CAAC;AACb,aAAa,gEAAI;AACjB,YAAY,CAAC;AACb;AACA;AACA,gBAAgB,CAAC;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA,QAAQ,CAAC;AACT,8BAA8B,EAAE,IAAI,0BAA0B,GAAG,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;AChyBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCtCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;;;;;WCFA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;;;;UEhDA;UACA;UACA;UACA;UACA","sources":["webpack://goroxels-client/./src/img/sha.jpg","webpack://goroxels-client/./src/css/waiter.css","webpack://goroxels-client/./src/js/admin/main.js","webpack://goroxels-client/../goroxels-server/src/constants.js","webpack://goroxels-client/webpack/bootstrap","webpack://goroxels-client/webpack/runtime/amd define","webpack://goroxels-client/webpack/runtime/chunk loaded","webpack://goroxels-client/webpack/runtime/compat get default export","webpack://goroxels-client/webpack/runtime/define property getters","webpack://goroxels-client/webpack/runtime/hasOwnProperty shorthand","webpack://goroxels-client/webpack/runtime/make namespace object","webpack://goroxels-client/webpack/runtime/publicPath","webpack://goroxels-client/webpack/runtime/jsonp chunk loading","webpack://goroxels-client/webpack/before-startup","webpack://goroxels-client/webpack/startup","webpack://goroxels-client/webpack/after-startup"],"sourcesContent":["export default __webpack_public_path__ + \"/img/sha.jpg\";","// extracted by mini-css-extract-plugin\nexport {};","// TODO add protected pixels support\r\n\r\nimport '../../css/waiter.css'\r\nimport '../../img/sha.jpg'\r\nimport '../../../node_modules/toastr/build/toastr.css'\r\n\r\nimport querystring from 'querystring'\r\nimport { rgb2uint32 } from '../convert/color'\r\nimport { ROLE } from '../../../../goroxels-server/src/constants'\r\n\r\nlet canvases;\r\n\r\nasync function apiRequest(path, args, isPost = false, isBinary = false) {\r\n    const query = querystring.stringify(args)\r\n\r\n    const resp = await fetch('/api/' + path + '?' + query, {\r\n        method: isPost ? 'POST' : 'GET'\r\n    });\r\n\r\n    if (resp.headers.get('Content-Type').startsWith('plain/binary') || isBinary) {\r\n        return await resp.arrayBuffer();\r\n    }\r\n    const json = await resp.json();\r\n\r\n    if (json.errors) {\r\n        json.errors.forEach(e => toastr.error(e));\r\n        return null\r\n    }\r\n\r\n    return json\r\n}\r\n\r\n// returns cancelAnimation callback\r\nfunction addWaiter(container) {\r\n    const el =\r\n        $(`<div class=\"waitContainer\" style=\"opacity: 0\">\r\n        <div class=\"waitElement\">\r\n            <div class=\"waitShape\"></div>\r\n            <div class=\"waitShape\"></div>\r\n            <div class=\"waitShape\"></div>\r\n            <div class=\"waitShape\"></div>\r\n        </div>\r\n    </div>`);\r\n\r\n    const rect = container.getBoundingClientRect();\r\n\r\n    $(container).append(el);\r\n\r\n    el.css('top', rect.top)\r\n        .css('left', rect.left)\r\n        .css('width', rect.width)\r\n        .css('height', rect.height);\r\n\r\n    setTimeout(() => {\r\n        el.css('opacity', 1);\r\n    })\r\n\r\n    return () => {\r\n        el.remove();\r\n    }\r\n}\r\n\r\nfunction parseBackupResponse(respAB) {\r\n    const respUI8 = new Uint8Array(respAB);\r\n\r\n    let curChar, currentOffset = 0;\r\n    while (curChar !== 0) {\r\n        curChar = respUI8[currentOffset++];\r\n        if (currentOffset > 0xffff) {\r\n            throw new Error('Metadata length is too long, aborting');\r\n        }\r\n    }\r\n\r\n    const metadataText = new TextDecoder().decode(respUI8.subarray(0, currentOffset - 1));\r\n\r\n    const metadata = JSON.parse(metadataText);\r\n\r\n    const chunkLength = metadata.chunkSize ** 2;\r\n\r\n    const chunks = {};\r\n    for (let cx = 0; cx < metadata.width; cx++) {\r\n        for (let cy = 0; cy < metadata.height; cy++) {\r\n            const key = `${cx},${cy}`;\r\n            const localOffset = chunkLength * (cx + cy * metadata.width)\r\n            const offset = currentOffset + localOffset;\r\n            chunks[key] = respUI8.subarray(offset, offset + chunkLength);\r\n        }\r\n    }\r\n\r\n    return {\r\n        metadata, chunks\r\n    }\r\n}\r\n\r\nasync function initBackup() {\r\n    function getCropVals() {\r\n        if (!$(\"#cropCB\").is(':checked')) {\r\n            $('#cropXStart,#cropYStart,#cropXEnd,#cropYEnd').removeAttr('placeholder');\r\n            return null\r\n        };\r\n\r\n        let cropXstart = $('#cropXStart').val();\r\n        let cropYstart = $('#cropYStart').val();\r\n        let cropXend = $('#cropXEnd').val();\r\n        let cropYend = $('#cropYEnd').val();\r\n\r\n        if (!cropXstart.length) {\r\n            cropXstart = 0;\r\n            $('#cropXStart').attr('placeholder', cropXstart);\r\n        }\r\n        if (!cropYstart.length) {\r\n            cropYstart = 0;\r\n            $('#cropYStart').attr('placeholder', cropYstart);\r\n        }\r\n\r\n        if (!cropXend.length) {\r\n            cropXend = cropXstart\r\n            $('#cropXEnd').attr('placeholder', cropXend);\r\n        }\r\n        if (!cropYend.length) {\r\n            cropYend = cropYstart\r\n            $('#cropYEnd').attr('placeholder', cropYend);\r\n        }\r\n\r\n        cropXstart = +cropXstart;\r\n        cropXend = +cropXend;\r\n        cropYstart = +cropYstart;\r\n        cropYend = +cropYend;\r\n\r\n        if (cropXstart < 0 || cropXstart > cropXend ||\r\n            cropYstart < 0 || cropYstart > cropYend) {\r\n            return null\r\n        }\r\n\r\n        return {\r\n            cropXstart, cropXend,\r\n            cropYstart, cropYend\r\n        }\r\n    }\r\n    async function updateDays(canvas) {\r\n        let days = await apiRequest('admin/backup/getDays', { canvas });\r\n        if (!days) return false;\r\n\r\n        days = sortDates(days);\r\n\r\n        $('#dateSelect option').remove();\r\n\r\n        for (let day of days) {\r\n            const el = `<option>${day}</option>`;\r\n            $('#dateSelect').append(el);\r\n        }\r\n\r\n        $('#dateSelect option:last-child').attr('selected', true);\r\n\r\n        return days\r\n    }\r\n\r\n    async function updateTimes(canvas, day) {\r\n        const times = await apiRequest('admin/backup/getTimes', { canvas, day })\r\n        if (!times) return false;\r\n\r\n        $('#timeSelect option').remove();\r\n\r\n        for (let time of times) {\r\n            const el = `<option value=\"${time}\">${time.replace(/-/g, ':')}</option>`;\r\n            $('#timeSelect').append(el);\r\n        }\r\n\r\n        $('#timeSelect option:last-child').attr('selected', true);\r\n\r\n        return times\r\n    }\r\n\r\n    let lastData = {};\r\n    async function updateBackup(canvas, day, time, forceUpdate) {\r\n        // TODO cache rendered and uncompressed canvas instead?\r\n        let waiterCB = null;\r\n        if (forceUpdate) {\r\n            const canvasCont = $('#bkCanvasWrapper')[0]\r\n            if (canvasCont)\r\n                waiterCB = addWaiter(canvasCont);\r\n\r\n            let resp = await apiRequest('admin/backup/getBackup', { canvas, day, time }, false, true);\r\n            if (!resp) return;\r\n\r\n            lastData = parseBackupResponse(resp);\r\n        }\r\n\r\n        const timer = Date.now();\r\n        renderBackup(lastData.chunks, lastData.metadata, getCurrentChunkCrop(), isUseGrid());\r\n        console.log('renderBackup in ' + (Date.now() - timer));\r\n        createZoomView($('#bkCanvasWrapper>canvas')[0]);\r\n\r\n        if (waiterCB) {\r\n            waiterCB();\r\n        }\r\n    }\r\n\r\n    function renderBackup(chunks, metadata, crop, useGrid) {\r\n        const chunkSize = metadata.chunkSize;\r\n\r\n        let width = chunkSize * metadata.width,\r\n            height = chunkSize * metadata.height;\r\n\r\n        let offX = 0,\r\n            offY = 0;\r\n\r\n        if (crop !== null) {\r\n            crop.startX = Math.min(metadata.width, crop.startX);\r\n            crop.startY = Math.min(metadata.height, crop.startY);\r\n            crop.endX = Math.min(metadata.width, crop.endX);\r\n            crop.endY = Math.min(metadata.height, crop.endY);\r\n\r\n            offX = -(crop.startX * chunkSize);\r\n            offY = -(crop.startY * chunkSize);\r\n\r\n            width = ((crop.endX + 1) - crop.startX) * chunkSize;\r\n            height = ((crop.endY + 1) - crop.startY) * chunkSize;\r\n        }\r\n\r\n        const encodedPal = metadata.palette.map(x => rgb2uint32(x));\r\n\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        const imgData = ctx.createImageData(width, height);\r\n        const u32a = new Uint32Array(imgData.data.buffer);\r\n\r\n        Object.keys(chunks).forEach(chunkId => {\r\n            const [cx, cy] = chunkId.split(',').map(x => +x);\r\n            if (crop !== null) {\r\n                if (cx < crop.startX || cx > crop.endX ||\r\n                    cy < crop.startY || cy > crop.endY) {\r\n                    return\r\n                }\r\n            }\r\n\r\n            let rawData = chunks[chunkId];\r\n\r\n            let color, i = 0, j, preY;\r\n\r\n            const startX = cx * chunkSize + offX,\r\n                endX = startX + chunkSize;\r\n            const startY = cy * chunkSize + offY,\r\n                endY = startY + chunkSize;\r\n\r\n            for (let y = startY; y < endY; y++) {\r\n                preY = y * width\r\n                for (let x = startX; x < endX; x++) {\r\n                    if (x < 3 && y == 0) {\r\n                        console.log({\r\n                            x, y,\r\n                            rdn: rawData[i] & 0x7F,\r\n                            rd: rawData[i]\r\n                        })\r\n                    }\r\n                    color = encodedPal[rawData[i++] & 0x7F];\r\n                    j = x + preY;\r\n\r\n                    u32a[j] = color;\r\n                }\r\n            }\r\n        })\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n\r\n        if (useGrid) {\r\n            ctx.beginPath();\r\n\r\n            ctx.strokeStyle = 'red';\r\n            ctx.lineWidth = 3;\r\n            ctx.setLineDash([ctx.lineWidth / 0.75, ctx.lineWidth / 0.66666]);\r\n\r\n            for (let y = chunkSize; y < height - 1; y += chunkSize) {\r\n                ctx.moveTo(0, y);\r\n                ctx.lineTo(width - 1, y);\r\n            }\r\n            for (let x = chunkSize; x < width - 1; x += chunkSize) {\r\n                ctx.moveTo(x, 0);\r\n                ctx.lineTo(x, height - 1);\r\n            }\r\n\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            ctx.setLineDash([]);\r\n\r\n            const halfChunk = chunkSize / 2,\r\n                fontHei = chunkSize / 4;\r\n            ctx.font = fontHei + 'px sans-serif';\r\n            ctx.fillStyle = 'red'\r\n            ctx.strokeStyle = 'white';\r\n\r\n            ctx.textAlign = 'center';\r\n            ctx.textBaseline = 'middle';\r\n            ctx.lineWidth = fontHei / 6;\r\n\r\n            let text,\r\n                offx = 0, offy = 0;\r\n            if (crop) {\r\n                offx = crop.startX || 0;\r\n                offy = crop.startY || 0;\r\n            }\r\n\r\n            const cw = canvas.width / chunkSize,\r\n                ch = canvas.height / chunkSize;\r\n            for (let cy = 0; cy < ch; cy++) {\r\n                for (let cx = 0; cx < cw; cx++) {\r\n                    text = `(${cx + offx}, ${cy + offy})`;\r\n\r\n                    let x = (cx * chunkSize) + halfChunk,\r\n                        y = (cy * chunkSize) + halfChunk;\r\n\r\n                    ctx.strokeText(text, x, y);\r\n                    ctx.fillText(text, x, y);\r\n                }\r\n            }\r\n        }\r\n\r\n        $('#backupContainer *').remove();\r\n        $('#backupContainer').append($('<div id=\"bkCanvasWrapper\">'));\r\n        $('#bkCanvasWrapper').append(canvas);\r\n\r\n        // убрать\r\n        $('body').scrollTop(999);\r\n    }\r\n\r\n    function getCurrentCanvas() {\r\n        return $('#buCanvasSelect').val()\r\n    }\r\n\r\n    function getCurrentDay() {\r\n        return $('#dateSelect').val()\r\n    }\r\n\r\n    function getCurrentTime() {\r\n        return $('#timeSelect').val()\r\n    }\r\n\r\n    function isUseGrid() {\r\n        return $('#gridCB').is(':checked')\r\n    }\r\n\r\n    function getCurrentChunkCrop() {\r\n        if (!$(\"#cropCB\").is(':checked')) return null;\r\n\r\n        const vals = getCropVals();\r\n        if (!vals) {\r\n            return null;\r\n        }\r\n\r\n        const {\r\n            cropXstart, cropXend,\r\n            cropYstart, cropYend\r\n        } = vals;\r\n\r\n\r\n        return {\r\n            startX: cropXstart,\r\n            startY: cropYstart,\r\n            endX: cropXend,\r\n            endY: cropYend\r\n        }\r\n    }\r\n\r\n    async function initialRequest() {\r\n        await onCanvasUpdated();\r\n    }\r\n\r\n    function onSomethingChanged(forceUpdate) {\r\n        const curCanvas = getCurrentCanvas();\r\n        const curDay = getCurrentDay();\r\n        const curTime = getCurrentTime();\r\n\r\n        if ([curCanvas, curDay, curTime].some(x => x == \"\")) {\r\n            return\r\n        }\r\n\r\n        updateBackup(curCanvas, curDay, curTime, forceUpdate);\r\n    }\r\n\r\n    async function onCanvasUpdated() {\r\n        const canvas = getCurrentCanvas();\r\n\r\n        const days = await updateDays(canvas),\r\n            day = days[days.length - 1];\r\n        const times = await updateTimes(canvas, day),\r\n            time = times[times.length - 1]\r\n\r\n        await updateBackup(canvas, day, time, true);\r\n    }\r\n\r\n    $('#gridCB, #cropCB, #timeSelect, .cropInput').on('change', e => {\r\n        if (e.className == 'cropInput' && !$(\"#cropCB\").is(':checked')) return;\r\n        onSomethingChanged(e.target.id === 'timeSelect');\r\n    });\r\n\r\n    // just to add and remove \"disabled\" attr from/to rollback checkbock\r\n    $('#cropCB').on('change', () => {\r\n        const enabled = $(\"#cropCB\").is(':checked');\r\n        if (enabled)\r\n            $('#cropRollbackCB').removeAttr('disabled');\r\n        else\r\n            $('#cropRollbackCB').attr('disabled', '');\r\n    })\r\n\r\n    $('#buCanvasSelect').on('change', onCanvasUpdated);\r\n    $('#dateSelect').on('change', async () => {\r\n        await updateTimes(getCurrentCanvas(), getCurrentDay());\r\n        onSomethingChanged(true);\r\n    });\r\n\r\n    function sortDates(dates) {\r\n        return dates.sort((a, b) => {\r\n            return dateToInt(a) - dateToInt(b)\r\n        });\r\n    }\r\n\r\n    function dateToInt(date) {\r\n        const [\r\n            day,\r\n            month,\r\n            year\r\n        ] = date.split('.').map(x => parseInt(x, 10));\r\n\r\n        let int = 0;\r\n\r\n        int += year * 365;\r\n        int += month * 31;\r\n        int += day;\r\n\r\n        return int\r\n    }\r\n\r\n    $('#rollback').on('click', async () => {\r\n        const canvas = getCurrentCanvas();\r\n        const day = getCurrentDay();\r\n        const time = getCurrentTime();\r\n        const crop = getCurrentChunkCrop();\r\n\r\n        if ([canvas, day, time].some(x => x == \"\")) {\r\n            return\r\n        }\r\n\r\n        const cropEnabled = crop && $(\"#cropRollbackCB\").is(':checked');\r\n\r\n        if(!cropEnabled){\r\n            alert('Ебанулся?');\r\n            return;\r\n        }\r\n\r\n        // let p = prompt('Are you sure?');\r\n        // if(p == null) return;\r\n\r\n        const resp = await apiRequest('/admin/backup/rollback', {\r\n            canvas, day, time,\r\n            crop: cropEnabled ? [crop.startX, crop.startY, crop.endX, crop.endY].join(',') : ''\r\n        }, true);\r\n        const json = await resp.json();\r\n        if (json.success) toastr.success('Rollbacked!');\r\n        else toastr.error(json.errors);\r\n    })\r\n\r\n    initialRequest().catch(e => {\r\n        console.error(e);\r\n        toastr.error(e);\r\n    });\r\n}\r\n\r\nfunction initIP() {\r\n    $('#sendIps').on('click', async () => {\r\n        const act = $('input[name=\"ipAction\"]:checked').val();\r\n        let ips = $('#ips').val();\r\n\r\n        ips = ips.split('\\n');\r\n\r\n        if (ips.length == 0) {\r\n            toastr.error('All ips are invalid');\r\n            return\r\n        }\r\n\r\n        const resp = await fetch('/api/admin/ip', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({ ips, action: act })\r\n        });\r\n        const json = await resp.json();\r\n\r\n        for (let error of json.errors)\r\n            toastr.error(error);\r\n\r\n        if (json.success) toastr.success('Success');\r\n        else toastr.error('Bad luck');\r\n    })\r\n}\r\nfunction initOther() {\r\n    $('#sendCaptchaEnabled').on('click', async () => {\r\n        const state = $('#captchaState')[0].checked;\r\n\r\n        const resp = await fetch('/api/admin/config/captchaState', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({ state })\r\n        })\r\n\r\n        const json = await resp.json();\r\n        if (json.success) {\r\n            toastr.success('Success');\r\n        } else {\r\n            toastr.error('Failed');\r\n            console.log(json);\r\n        }\r\n    });\r\n\r\n    $('#sendJoinDelay').on('click', async () => {\r\n        const value = $('#joinDelay').val();\r\n        if (!value) return;\r\n\r\n        const parsed = parseInt(value, 10);\r\n        if (parsed < 0 || isNaN(parsed)) return;\r\n\r\n        const resp = await fetch('/api/admin/config/afterJoinDelay', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({ value: parsed })\r\n        })\r\n\r\n        const json = await resp.json();\r\n        if (json.success) {\r\n            toastr.success('Success');\r\n        } else {\r\n            toastr.error('Failed');\r\n            console.log(json);\r\n        }\r\n    });\r\n\r\n    initApplyMask();\r\n}\r\nfunction initApplyMask() {\r\n    const fileInp = $('#protectMaskFile');\r\n    let lastFile;\r\n    fileInp.on('change', e => {\r\n        if (fileInp[0].files.length) {\r\n            const file = fileInp[0].files[0];\r\n            lastFile = file;\r\n            $('label[for=protectMaskFile]').text(file.name);\r\n        } else {\r\n            $('label[for=protectMaskFile]').text('Choose image');\r\n        }\r\n    });\r\n\r\n    $('#submitProtectMask').on('click', async () => {\r\n        if (!lastFile) return;\r\n\r\n        const xOff = +$('#protectMaskXOff').val();\r\n        const yOff = +$('#protectMaskYOff').val();\r\n        if ([xOff, yOff].some(n => isNaN(n) || n < 0)) return;\r\n\r\n        const canvas = $('#pmCanvasSelect').val();\r\n\r\n        const img = await new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = e => {\r\n                const image = new Image();\r\n                image.onload = () => resolve(image);\r\n                image.onerror = reject;\r\n                image.src = e.target.result;\r\n            };\r\n            reader.onerror = reject;\r\n            reader.readAsDataURL(lastFile);\r\n        });\r\n\r\n        const tileSize = 500;\r\n        const tilesX = Math.ceil(img.width / tileSize);\r\n        const tilesY = Math.ceil(img.height / tileSize);\r\n        const total = tilesX * tilesY;\r\n        let done = 0;\r\n\r\n        let toast = toastr.info(`Uploading mask... (0 / ${total})`, \"Mask Upload\", {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: true,\r\n            tapToDismiss: false\r\n        });\r\n\r\n        const canvasEl = document.createElement('canvas');\r\n        const ctx = canvasEl.getContext('2d');\r\n\r\n        for (let ty = 0; ty < tilesY; ty++) {\r\n            for (let tx = 0; tx < tilesX; tx++) {\r\n                const sx = tx * tileSize;\r\n                const sy = ty * tileSize;\r\n                const w = Math.min(tileSize, img.width - sx);\r\n                const h = Math.min(tileSize, img.height - sy);\r\n\r\n                canvasEl.width = w;\r\n                canvasEl.height = h;\r\n                ctx.clearRect(0, 0, w, h);\r\n                ctx.drawImage(img, sx, sy, w, h, 0, 0, w, h);\r\n\r\n                const blob = await new Promise(res => canvasEl.toBlob(res, 'image/png'));\r\n                const fd = new FormData();\r\n                fd.append('x', xOff + sx);\r\n                fd.append('y', yOff + sy);\r\n                fd.append('canvas', canvas);\r\n                fd.append('img', blob, `chunk_${tx}_${ty}.png`);\r\n\r\n                const resp = await fetch('/api/admin/canvas/applyProtectMask', {\r\n                    method: 'POST',\r\n                    body: fd\r\n                });\r\n                const respJson = await resp.json();\r\n                respJson?.errors?.forEach(e => toastr.error(e));\r\n\r\n                done++;\r\n                if (toast && toast.find('.toast-message').length) {\r\n                    toast.find('.toast-message').text(`Uploading mask... (${done} / ${total})`);\r\n                }\r\n            }\r\n        }\r\n\r\n        toast.remove()\r\n        if (toast && toast.find('.toast-message').length) {\r\n            toast.find('.toast-message').text(`Upload complete! (${done} / ${total})`);\r\n        }\r\n        toastr.success(\"Protect mask applied successfully\");\r\n    });\r\n}\r\n\r\n\r\nfunction initCanvasActions() {\r\n    canvases.forEach((canv, id) => {\r\n        $('#selectActCanvas').append(`<option value=\"${id}\">${canv.name}</option>`);\r\n    })\r\n\r\n    $('#canvasAction').on('change', () => {\r\n        const act = $('#canvasAction').val();\r\n        // hide all (if will be more in future)\r\n        $('.hidden.enlargeConfig').addClass('hidden');\r\n        // and then show one\r\n        if (act === 'enlarge') {\r\n            $('.hidden.enlargeConfig').removeClass('hidden');\r\n        }\r\n    })\r\n\r\n    $('#doCanvasAction').on('click', async () => {\r\n        const act = $('#canvasAction').val();\r\n        if (!act) return;\r\n\r\n        const canv = $('#selectActCanvas').val();\r\n        if (!canv) return;\r\n\r\n        if (act === 'wipe')\r\n            await wipeCanvas(canv);\r\n        if (act === 'enlarge') {\r\n            const t = $('#enTop').val();\r\n            const r = $('#enRight').val();\r\n            const b = $('#enBot').val();\r\n            const l = $('#enLeft').val();\r\n\r\n            if ([t, r, b, l].some(x => x > 254))\r\n                return toastr.error('Max canvas size is 255!');\r\n            if ([t, r, b, l].some(x => x < 0))\r\n                return toastr.error('ENLARGE only, one way road');\r\n\r\n            await enlargeCanvas(canv, t, r, b, l);\r\n        }\r\n    })\r\n\r\n    async function wipeCanvas(id) {\r\n        await apiRequest('admin/canvas/wipe', {\r\n            canvas: id\r\n        }, true);\r\n        toastr.success('Canvas ' + canvases[id].name + ' wiped!')\r\n    }\r\n\r\n    async function enlargeCanvas(id, t, r, b, l) {\r\n        // TODO check for errors\r\n        await apiRequest('admin/canvas/enlarge', {\r\n            canvas: id,\r\n\r\n            top: t,\r\n            right: r,\r\n            bottom: b,\r\n            left: l\r\n        }, true);\r\n        toastr.success('Canvas ' + canvases[id].name + ' enlarged!')\r\n    }\r\n}\r\n\r\nasync function loadConfig() {\r\n    const resp = await fetch('/config.json');\r\n    return await resp.json();\r\n}\r\n\r\n/**\r\n * \r\n * @param {HTMLCanvasElement} canvas \r\n */\r\nfunction createZoomView(canvas) {\r\n    const size = 200;\r\n    const halfSize = size / 2 | 0;\r\n\r\n    $('#zoomedCanvasView').remove();\r\n\r\n    const zoomedViewCanvas = document.createElement('canvas');\r\n    zoomedViewCanvas.id = 'zoomedCanvasView';\r\n    zoomedViewCanvas.width = zoomedViewCanvas.height = size;\r\n    zoomedViewCanvas.style.cssText =\r\n        `border: 1px solid black; \\nposition: absolute; \\ndisplay: none`\r\n\r\n    document.body.appendChild(zoomedViewCanvas);\r\n\r\n    const ctx = zoomedViewCanvas.getContext('2d');\r\n    const origCtx = canvas.getContext('2d');\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    const canvasSizeDiffX = canvas.width / rect.width;\r\n    const canvasSizeDiffY = canvas.height / rect.height;\r\n\r\n    canvas.addEventListener('mousemove', e => {\r\n        zoomedViewCanvas.style.display = ''\r\n\r\n        const posX = Math.max(e.offsetX, 0);\r\n        const posY = Math.max(e.offsetY, 0);\r\n\r\n        const cordX = posX * canvasSizeDiffX;\r\n        const cordY = posY * canvasSizeDiffY;\r\n\r\n        const leftBound = cordX - halfSize;\r\n        const topBound = cordY - halfSize;\r\n\r\n        const rightBound = cordX + halfSize;\r\n        const bottomBound = cordY + halfSize;\r\n\r\n        render(leftBound, topBound, rightBound, bottomBound);\r\n\r\n        zoomedViewCanvas.style.left = (e.clientX + 10) + 'px';\r\n        zoomedViewCanvas.style.top = (e.clientY + 10) + 'px';\r\n    });\r\n\r\n    canvas.addEventListener('mouseleave', () => {\r\n        zoomedViewCanvas.style.display = 'none';\r\n    });\r\n\r\n\r\n    function render(startX, startY, endX, endY) {\r\n        const imdata = origCtx.getImageData(startX, startY, endX - startX, endY - startY);\r\n        ctx.putImageData(imdata, 0, 0);\r\n    }\r\n}\r\n\r\n(async () => {\r\n    let resp;\r\n    try {\r\n        resp = await fetch('/api/me');\r\n    } catch (e) {\r\n        toastr.error(e)\r\n        return toastr.error('Error while fetching /api/me:')\r\n    }\r\n    const me = await resp.json();\r\n    if (me.role < ROLE.MOD) {\r\n        location.href = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';\r\n        return\r\n    }\r\n\r\n    canvases = (await loadConfig()).canvases;\r\n\r\n    switch (me.role) {\r\n        case ROLE.ADMIN:\r\n            $('.admin').show();\r\n        case ROLE.MOD:\r\n            $('.mod').show();\r\n        default: {\r\n            if (me.id == 1) {\r\n                $('.superadmin').show();\r\n            }\r\n            break\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < canvases.length; i++) {\r\n        const canvas = canvases[i];\r\n        $('.canvasSelect').append(\r\n            `<option value=\"${i}\" ${i === 0 ? 'selected' : ''}>${canvas.name}</option>`\r\n        )\r\n    }\r\n\r\n    initBackup();\r\n    initIP();\r\n    initOther();\r\n    initCanvasActions()\r\n})()","const SECOND = 1000,\r\n    MINUTE = SECOND * 60,\r\n    HOUR = MINUTE * 60,\r\n    DAY = HOUR * 24,\r\n    WEEK = DAY * 7,\r\n    MONTH = DAY * 30;\r\n\r\nconst ROLE = {\r\n    BANNED: -1,\r\n    GUEST: 0,\r\n    USER: 1,\r\n    TRUSTED: 2,\r\n    MOD: 3,\r\n    ADMIN: 4\r\n}\r\n\r\nconst ROLE_I = {};\r\nObject.keys(ROLE).forEach(x => ROLE_I[ROLE[x]] = x);\r\n\r\nconst chatBucket = {\r\n    USER: [2000, 3],\r\n    TRUSTED: [1000, 4],\r\n    MOD: [500, 5],\r\n    ADMIN: [0, 32],\r\n}\r\n\r\nmodule.exports = {\r\n    SECOND,\r\n    MINUTE,\r\n    HOUR,\r\n    DAY,\r\n    WEEK,\r\n    MONTH,\r\n\r\n    ROLE,\r\n    ROLE_I,\r\n\r\n    chatBucket\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \".\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"admin\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkgoroxels_client\"] = self[\"webpackChunkgoroxels_client\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"penis\"], () => (__webpack_require__(\"./src/js/admin/main.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}